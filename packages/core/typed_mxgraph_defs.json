{
  "mxCellState": [
    null,
    {
      "constructor": [
        "constructor(view: mxGraphView, cell: mxCell, style: { [key: string]: any });",
        null
      ],
      "control": [
        "control: mxShape;",
        null
      ],
      "view": [
        "view: mxGraphView;",
        [
          "/**",
          " * Variable: view",
          " *",
          " * Reference to the enclosing <mxGraphView>.",
          " */"
        ]
      ],
      "cell": [
        "cell: mxCell;",
        [
          "/**",
          " * Variable: cell",
          " *",
          " * Reference to the <mxCell> that is represented by this state.",
          " */"
        ]
      ],
      "style": [
        "style: { [key: string]: any };",
        [
          "/**",
          " * Variable: style",
          " *",
          " * Contains an array of key, value pairs that represent the style of the",
          " * cell.",
          " */"
        ]
      ],
      "invalid": [
        "invalid: boolean;",
        [
          "/**",
          " * Variable: invalid",
          " *",
          " * Specifies if the state is invalid. Default is true.",
          " */"
        ]
      ],
      "origin": [
        "origin: mxPoint;",
        [
          "/**",
          " * Variable: origin",
          " *",
          " * <mxPoint> that holds the origin for all child cells. Default is a new",
          " * empty <mxPoint>.",
          " */"
        ]
      ],
      "absolutePoints": [
        "absolutePoints: mxPoint[];",
        [
          "/**",
          " * Variable: absolutePoints",
          " *",
          " * Holds an array of <mxPoints> that represent the absolute points of an",
          " * edge.",
          " */"
        ]
      ],
      "absoluteOffset": [
        "absoluteOffset: mxPoint;",
        [
          "/**",
          " * Variable: absoluteOffset",
          " *",
          " * <mxPoint> that holds the absolute offset. For edges, this is the",
          " * absolute coordinates of the label position. For vertices, this is the",
          " * offset of the label relative to the top, left corner of the vertex.",
          " */"
        ]
      ],
      "visibleSourceState": [
        "visibleSourceState: mxCellState;",
        [
          "/**",
          " * Variable: visibleSourceState",
          " *",
          " * Caches the visible source terminal state.",
          " */"
        ]
      ],
      "visibleTargetState": [
        "visibleTargetState: mxCellState;",
        [
          "/**",
          " * Variable: visibleTargetState",
          " *",
          " * Caches the visible target terminal state.",
          " */"
        ]
      ],
      "terminalDistance": [
        "terminalDistance: number;",
        [
          "/**",
          " * Variable: terminalDistance",
          " *",
          " * Caches the distance between the end points for an edge.",
          " */"
        ]
      ],
      "length": [
        "length: number;",
        [
          "/**",
          " * Variable: length",
          " *",
          " * Caches the length of an edge.",
          " */"
        ]
      ],
      "segments": [
        "segments: number[];",
        [
          "/**",
          " * Variable: segments",
          " *",
          " * Array of numbers that represent the cached length of each segment of the",
          " * edge.",
          " */"
        ]
      ],
      "shape": [
        "shape: mxShape;",
        [
          "/**",
          " * Variable: shape",
          " *",
          " * Holds the <mxShape> that represents the cell graphically.",
          " */"
        ]
      ],
      "text": [
        "text: mxText;",
        [
          "/**",
          " * Variable: text",
          " *",
          " * Holds the <mxText> that represents the label of the cell. Thi smay be",
          " * null if the cell has no label.",
          " */"
        ]
      ],
      "unscaledWidth": [
        "unscaledWidth: number;",
        [
          "/**",
          " * Variable: unscaledWidth",
          " *",
          " * Holds the unscaled width of the state.",
          " */"
        ]
      ],
      "getPerimeterBounds": [
        "getPerimeterBounds(border?: number, bounds?: mxRectangle): mxRectangle;",
        [
          "/**",
          " * Function: getPerimeterBounds",
          " *",
          " * Returns the <mxRectangle> that should be used as the perimeter of the",
          " * cell.",
          " *",
          " * Parameters:",
          " *",
          " * border - Optional border to be added around the perimeter bounds.",
          " * bounds - Optional <mxRectangle> to be used as the initial bounds.",
          " */"
        ]
      ],
      "setAbsoluteTerminalPoint": [
        "setAbsoluteTerminalPoint(point: mxPoint, isSource: boolean): void;",
        [
          "/**",
          " * Function: setAbsoluteTerminalPoint",
          " *",
          " * Sets the first or last point in <absolutePoints> depending on isSource.",
          " *",
          " * Parameters:",
          " *",
          " * point - <mxPoint> that represents the terminal point.",
          " * isSource - Boolean that specifies if the first or last point should",
          " * be assigned.",
          " */"
        ]
      ],
      "setCursor": [
        "setCursor(cursor: string): void;",
        [
          "/**",
          " * Function: setCursor",
          " *",
          " * Sets the given cursor on the shape and text shape.",
          " */"
        ]
      ],
      "getVisibleTerminal": [
        "getVisibleTerminal(source: boolean): mxCell;",
        [
          "/**",
          " * Function: getVisibleTerminal",
          " *",
          " * Returns the visible source or target terminal cell.",
          " *",
          " * Parameters:",
          " *",
          " * source - Boolean that specifies if the source or target cell should be",
          " * returned.",
          " */"
        ]
      ],
      "getVisibleTerminalState": [
        "getVisibleTerminalState(source?: boolean): mxCellState;",
        [
          "/**",
          " * Function: getVisibleTerminalState",
          " *",
          " * Returns the visible source or target terminal state.",
          " *",
          " * Parameters:",
          " *",
          " * source - Boolean that specifies if the source or target state should be",
          " * returned.",
          " */"
        ]
      ],
      "setVisibleTerminalState": [
        "setVisibleTerminalState(terminalState: mxCellState, source: boolean): void;",
        [
          "/**",
          " * Function: setVisibleTerminalState",
          " *",
          " * Sets the visible source or target terminal state.",
          " *",
          " * Parameters:",
          " *",
          " * terminalState - <mxCellState> that represents the terminal.",
          " * source - Boolean that specifies if the source or target state should be set.",
          " */"
        ]
      ],
      "getCellBounds": [
        "getCellBounds(): mxRectangle;",
        [
          "/**",
          " * Function: getCellBounds",
          " *",
          " * Returns the unscaled, untranslated bounds.",
          " */"
        ]
      ],
      "getPaintBounds": [
        "getPaintBounds(): mxRectangle;",
        [
          "/**",
          " * Function: getPaintBounds",
          " *",
          " * Returns the unscaled, untranslated paint bounds. This is the same as",
          " * <getCellBounds> but with a 90 degree rotation if the shape's",
          " * isPaintBoundsInverted returns true.",
          " */"
        ]
      ],
      "updateCachedBounds": [
        "updateCachedBounds(): void;",
        [
          "/**",
          " * Function: updateCachedBounds",
          " *",
          " * Updates the cellBounds and paintBounds.",
          " */"
        ]
      ],
      "setState": [
        "setState(state: mxCellState): void;",
        [
          "/**",
          " * Destructor: setState",
          " *",
          " * Copies all fields from the given state to this state.",
          " */"
        ]
      ],
      "clone": [
        "clone(): mxCellState;",
        [
          "/**",
          " * Function: clone",
          " *",
          " * Returns a clone of this <mxPoint>.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Destructor: destroy",
          " *",
          " * Destroys the state and all associated resources.",
          " */"
        ]
      ]
    }
  ],
  "mxSwimlaneManager": [
    [
      "/**",
      " * @class mxSwimlaneManager",
      " * @extends mxEventSource",
      " *",
      " * Manager for swimlanes and nested swimlanes that sets the size of newly added",
      " * swimlanes to that of their siblings, and propagates changes to the size of a",
      " * swimlane to its siblings, if {@link siblings} is true, and its ancestors, if",
      " * {@link bubbling} is true.",
      " */"
    ],
    {
      "constructor": [
        "constructor(graph: mxGraph, horizontal?: boolean, addEnabled?: boolean, resizeEnabled?: boolean);",
        [
          "/**",
          " * Constructs a new swimlane manager for the given graph.",
          " *",
          " * @param {mxGraph} graph             Reference to the enclosing graph.",
          " * @param {boolean} [horizontal]",
          " * @param {boolean} [addEnabled]",
          " * @param {boolean} [resizeEnabled]",
          " */"
        ]
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Reference to the enclosing {@link mxGraph}.",
          " */"
        ]
      ],
      "enabled": [
        "enabled: boolean;",
        [
          "/**",
          " * Specifies if event handling is enabled.",
          " * @default true",
          " */"
        ]
      ],
      "horizontal": [
        "horizontal: boolean;",
        [
          "/**",
          " * Specifies the orientation of the swimlanes.",
          " * @default true",
          " */"
        ]
      ],
      "addEnabled": [
        "addEnabled: boolean;",
        [
          "/**",
          " * Specifies if newly added cells should be resized to match the size of their",
          " * existing siblings.",
          " * @default true",
          " */"
        ]
      ],
      "resizeEnabled": [
        "resizeEnabled: boolean;",
        [
          "/**",
          " * Specifies if resizing of swimlanes should be handled.",
          " * @default true",
          " */"
        ]
      ],
      "addHandler": [
        "addHandler: Function;",
        [
          "/**",
          " * Holds the function that handles the move event.",
          " */"
        ]
      ],
      "resizeHandler": [
        "resizeHandler: Function;",
        [
          "/**",
          " * Holds the function that handles the move event.",
          " */"
        ]
      ],
      "isEnabled": [
        "isEnabled(): boolean;",
        [
          "/**",
          " * Returns true if events are handled. This implementation",
          " * returns {@link enabled}.",
          " */"
        ]
      ],
      "setEnabled": [
        "setEnabled(value: boolean): void;",
        [
          "/**",
          " * Enables or disables event handling. This implementation",
          " * updates {@link enabled}.",
          " *",
          " * @param enabled Boolean that specifies the new enabled state.",
          " */"
        ]
      ],
      "isHorizontal": [
        "isHorizontal(): boolean;",
        [
          "/**",
          " * Returns {@link horizontal}.",
          " */"
        ]
      ],
      "setHorizontal": [
        "setHorizontal(value: boolean): void;",
        [
          "/**",
          " * Sets {@link horizontal}.",
          " */"
        ]
      ],
      "isAddEnabled": [
        "isAddEnabled(): boolean;",
        [
          "/**",
          " * Returns {@link addEnabled}.",
          " */"
        ]
      ],
      "setAddEnabled": [
        "setAddEnabled(value: boolean): void;",
        [
          "/**",
          " * Sets {@link addEnabled}.",
          " */"
        ]
      ],
      "isResizeEnabled": [
        "isResizeEnabled(): boolean;",
        [
          "/**",
          " * Returns {@link resizeEnabled}.",
          " */"
        ]
      ],
      "setResizeEnabled": [
        "setResizeEnabled(value: boolean): void;",
        [
          "/**",
          " * Sets {@link resizeEnabled}.",
          " */"
        ]
      ],
      "getGraph": [
        "getGraph(): mxGraph;",
        [
          "/**",
          " * Returns the graph that this manager operates on.",
          " */"
        ]
      ],
      "setGraph": [
        "setGraph(graph: mxGraph): void;",
        [
          "/**",
          " * Sets the graph that the manager operates on.",
          " */"
        ]
      ],
      "isSwimlaneIgnored": [
        "isSwimlaneIgnored(swimlane: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given swimlane should be ignored.",
          " */"
        ]
      ],
      "isCellHorizontal": [
        "isCellHorizontal(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is horizontal. If the given cell is not a",
          " * swimlane, then the global orientation is returned.",
          " */"
        ]
      ],
      "cellsAdded": [
        "cellsAdded(cells: Array<mxCell>): void;",
        [
          "/**",
          " * Called if any cells have been added.",
          " *",
          " * @param cell Array of {@link mxCell} that have been added.",
          " */"
        ]
      ],
      "swimlaneAdded": [
        "swimlaneAdded(swimlane: mxCell): void;",
        [
          "/**",
          " * Updates the size of the given swimlane to match that of any existing",
          " * siblings swimlanes.",
          " *",
          " * @param swimlane {@link mxCell} that represents the new swimlane.",
          " */"
        ]
      ],
      "cellsResized": [
        "cellsResized(cells: Array<mxCell>): void;",
        [
          "/**",
          " * Called if any cells have been resizes. Calls {@link swimlaneResized} for all",
          " * swimlanes where {@link isSwimlaneIgnored} returns false.",
          " *",
          " * @param cells Array of {@link mxCell} whose size was changed.",
          " */"
        ]
      ],
      "resizeSwimlane": [
        "resizeSwimlane(swimlane: mxCell, w: number, h: number, parentHorizontal: boolean): void;",
        [
          "/**",
          " * Called from {@link cellsResized} for all swimlanes that are not ignored to update",
          " * the size of the siblings and the size of the parent swimlanes, recursively,",
          " * if {@link bubbling} is true.",
          " *",
          " * @param swimlane {@link mxCell} whose size has changed.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Removes all handlers from the {@link graph} and deletes the reference to it.",
          " */"
        ]
      ]
    }
  ],
  "mxGraphSelectionModel": [
    [
      "/**",
      " * @class mxGraphSelectionModel",
      " *",
      " * Implements the selection model for a graph. Here is a listener that handles",
      " * all removed selection cells.",
      " *",
      " * @example",
      " * ```javascript",
      " * graph.getSelectionModel().addListener(mxEvent.CHANGE, function(sender, evt)",
      " * {",
      " *   var cells = evt.getProperty('added');",
      " *",
      " *   for (var i = 0; i < cells.length; i++)",
      " *   {",
      " *     // Handle cells[i]...",
      " *   }",
      " * });",
      " * ```",
      " *",
      " * ### Event: mxEvent.UNDO",
      " *",
      " * Fires after the selection was changed in {@link changeSelection}. The",
      " * `edit` property contains the {@link mxUndoableEdit} which contains the",
      " * {@link mxSelectionChange}.",
      " *",
      " * ### Event: mxEvent.CHANGE",
      " *",
      " * Fires after the selection changes by executing an {@link mxSelectionChange}. The",
      " * `added` and `removed` properties contain arrays of",
      " * cells that have been added to or removed from the selection, respectively.",
      " * The names are inverted due to historic reasons. This cannot be changed.",
      " */"
    ],
    {
      "constructor": [
        "constructor(graph: mxGraph);",
        [
          "/**",
          " * @constructor",
          " * Constructs a new graph selection model for the given {@link mxGraph}.",
          " *",
          " * @param graph Reference to the enclosing {@link mxGraph}.",
          " */"
        ]
      ],
      "doneResource": [
        "doneResource: 'done' | '';",
        [
          "/**",
          " * Specifies the resource key for the status message after a long operation.",
          " * If the resource for this key does not exist then the value is used as",
          " * the status message. Default is 'done'.",
          " */"
        ]
      ],
      "updatingSelectionResource": [
        "updatingSelectionResource: 'updatingSelection' | '';",
        [
          "/**",
          " * Specifies the resource key for the status message while the selection is",
          " * being updated. If the resource for this key does not exist then the",
          " * value is used as the status message. Default is 'updatingSelection'.",
          " */"
        ]
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Reference to the enclosing {@link mxGraph}.",
          " */"
        ]
      ],
      "singleSelection": [
        "singleSelection: boolean;",
        [
          "/**",
          " * Specifies if only one selected item at a time is allowed.",
          " * Default is false.",
          " */"
        ]
      ],
      "isSingleSelection": [
        "isSingleSelection(): boolean;",
        [
          "/**",
          " * Returns {@link singleSelection} as a boolean.",
          " */"
        ]
      ],
      "setSingleSelection": [
        "setSingleSelection(singleSelection: boolean): void;",
        [
          "/**",
          " * Sets the {@link singleSelection} flag.",
          " *",
          " * @param {boolean} singleSelection Boolean that specifies the new value for",
          " * {@link singleSelection}.",
          " */"
        ]
      ],
      "isSelected": [
        "isSelected(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given {@link mxCell} is selected.",
          " */"
        ]
      ],
      "isEmpty": [
        "isEmpty(): boolean;",
        [
          "/**",
          " * Returns true if no cells are currently selected.",
          " */"
        ]
      ],
      "clear": [
        "clear(): void;",
        [
          "/**",
          " * Clears the selection and fires a {@link change} event if the selection was not",
          " * empty.",
          " */"
        ]
      ],
      "setCell": [
        "setCell(cell: mxCell): void;",
        [
          "/**",
          " * Selects the specified {@link mxCell} using {@link setCells}.",
          " *",
          " * @param cell {@link mxCell} to be selected.",
          " */"
        ]
      ],
      "setCells": [
        "setCells(cells: Array<mxCell>): void;",
        [
          "/**",
          " * Selects the given array of {@link mxCell} and fires a {@link change} event.",
          " *",
          " * @param cells Array of {@link mxCell} to be selected.",
          " */"
        ]
      ],
      "getFirstSelectableCell": [
        "getFirstSelectableCell(cells: Array<mxCell>): mxCell;",
        [
          "/**",
          " * Returns the first selectable cell in the given array of cells.",
          " */"
        ]
      ],
      "addCell": [
        "addCell(cell: mxCell): void;",
        [
          "/**",
          " * Adds the given {@link mxCell} to the selection and fires a {@link select} event.",
          " *",
          " * @param cell {@link mxCell} to add to the selection.",
          " */"
        ]
      ],
      "addCells": [
        "addCells(cells: Array<mxCell>): void;",
        [
          "/**",
          " * Adds the given array of {@link mxCell} to the selection and fires a {@link select}",
          " * event.",
          " *",
          " * @param cells Array of {@link mxCell} to add to the selection.",
          " */"
        ]
      ],
      "removeCell": [
        "removeCell(cell: mxCell): void;",
        [
          "/**",
          " * Removes the specified {@link mxCell} from the selection and fires a {@link select}",
          " * event for the remaining cells.",
          " *",
          " * @param cell {@link mxCell} to remove from the selection.",
          " */"
        ]
      ],
      "removeCells": [
        "removeCells(cells: Array<mxCell>): void;",
        [
          "/**",
          " * Removes the specified {@link mxCell} from the selection and fires a {@link select}",
          " * event for the remaining cells.",
          " *",
          " * @param cell {@link mxCell} to remove from the selection.",
          " */"
        ]
      ],
      "changeSelection": [
        "changeSelection(added: Array<mxCell>, removed: Array<mxCell>): void;",
        [
          "/**",
          " * Adds/removes the specified arrays of {@link mxCell} to/from the selection.",
          " *",
          " * @param added Array of {@link mxCell} to add to the selection.",
          " * @param remove Array of {@link mxCell} to remove from the selection.",
          " */"
        ]
      ],
      "cellAdded": [
        "cellAdded(cell: mxCell): void;",
        [
          "/**",
          " * Inner callback to add the specified {@link mxCell} to the selection. No event",
          " * is fired in this implementation.",
          " *",
          " * Paramters:",
          " *",
          " * @param cell {@link mxCell} to add to the selection.",
          " */"
        ]
      ],
      "cellRemoved": [
        "cellRemoved(cell: mxCell): void;",
        [
          "/**",
          " * Inner callback to remove the specified {@link mxCell} from the selection. No",
          " * event is fired in this implementation.",
          " *",
          " * @param cell {@link mxCell} to remove from the selection.",
          " */"
        ]
      ]
    }
  ],
  "mxSelectionChange": [
    [
      "/**",
      " * @class mxSelectionChange",
      " * Action to change the current root in a view.",
      " */"
    ],
    {
      "constructor": [
        "constructor(selectionModel: mxGraphSelectionModel, added: Array<mxCell>, removed: Array<mxCell>);",
        [
          "/**",
          " * Creates an instance of mxSelectionChange.",
          " *",
          " * @param {mxGraphSelectionModel} selectionModel",
          " * @param {Array<mxCell>} added",
          " * @param {Array<mxCell>} removed",
          " */"
        ]
      ],
      "execute": [
        "execute(): void;",
        [
          "/**",
          " * Changes the current root of the view.",
          " */"
        ]
      ],
      "key": [
        "[key: string]: any;",
        null
      ]
    }
  ],
  "mxStylesheet": [
    [
      "/**",
      " * @class mxStylesheet",
      " *",
      " * Defines the appearance of the cells in a graph. See {@link putCellStyle} for an",
      " * example of creating a new cell style. It is recommended to use objects, not",
      " * arrays for holding cell styles. Existing styles can be cloned using",
      " * {@link mxUtils.clone} and turned into a string for debugging using",
      " * {@link mxUtils.toString}.",
      " *",
      " * ### Default Styles",
      " *",
      " * The stylesheet contains two built-in styles, which are used if no style is",
      " * defined for a cell:",
      " *",
      " * - defaultVertex Default style for vertices",
      " * - defaultEdge Default style for edges",
      " *",
      " * ### Example",
      " *",
      " * ```javascript",
      " * var vertexStyle = stylesheet.getDefaultVertexStyle();",
      " * vertexStyle.rounded = true;",
      " * var edgeStyle = stylesheet.getDefaultEdgeStyle();",
      " * edgeStyle.edge = mxEdgeStyle.EntityRelation;",
      " * ```",
      " *",
      " * Modifies the built-in default styles.",
      " *",
      " * To avoid the default style for a cell, add a leading semicolon",
      " * to the style definition, eg.",
      " *",
      " * ```javascript",
      " * ;shadow=1",
      " * ```",
      " *",
      " * ### Removing keys",
      " *",
      " * For removing a key in a cell style of the form [stylename;|key=value;] the",
      " * special value none can be used, eg. highlight;fillColor=none",
      " *",
      " * See also the helper methods in mxUtils to modify strings of this format,",
      " * namely {@link mxUtils.setStyle}, {@link mxUtils.indexOfStylename},",
      " * {@link mxUtils.addStylename}, {@link mxUtils.removeStylename},",
      " * {@link mxUtils.removeAllStylenames} and {@link mxUtils.setStyleFlag}.",
      " *",
      " * Constructor: mxStylesheet",
      " *",
      " * Constructs a new stylesheet and assigns default styles.",
      " */"
    ],
    {
      "constructor": [
        "constructor();",
        null
      ],
      "styles": [
        "styles: StyleMap;",
        [
          "/**",
          " * Maps from names to cell styles. Each cell style is a map of key,",
          " * value pairs.",
          " */"
        ]
      ],
      "createDefaultVertexStyle": [
        "createDefaultVertexStyle(): StyleMap;",
        [
          "/**",
          " * Creates and returns the default vertex style.",
          " */"
        ]
      ],
      "createDefaultEdgeStyle": [
        "createDefaultEdgeStyle(): StyleMap;",
        [
          "/**",
          " * Creates and returns the default edge style.",
          " */"
        ]
      ],
      "putDefaultVertexStyle": [
        "putDefaultVertexStyle(style: StyleMap): void;",
        [
          "/**",
          " * Sets the default style for vertices using defaultVertex as the",
          " * stylename.",
          " * @param style Key, value pairs that define the style.",
          " */"
        ]
      ],
      "putDefaultEdgeStyle": [
        "putDefaultEdgeStyle(style: StyleMap): void;",
        [
          "/**",
          " * Sets the default style for edges using defaultEdge as the stylename.",
          " */"
        ]
      ],
      "getDefaultVertexStyle": [
        "getDefaultVertexStyle(): StyleMap;",
        [
          "/**",
          " * Returns the default style for vertices.",
          " */"
        ]
      ],
      "getDefaultEdgeStyle": [
        "getDefaultEdgeStyle(): StyleMap;",
        [
          "/**",
          " * Sets the default style for edges.",
          " */"
        ]
      ],
      "putCellStyle": [
        "putCellStyle(name: string, style: StyleMap): void;",
        [
          "/**",
          " * Stores the given map of key, value pairs under the given name in",
          " * {@link styles}.",
          " *",
          " * Example:",
          " *",
          " * The following example adds a new style called 'rounded' into an",
          " * existing stylesheet:",
          " *",
          " * ```javascript",
          " * var style = new Object();",
          " * style.shape = mxConstants.SHAPE_RECTANGLE;",
          " * style.perimiter = mxPerimeter.RectanglePerimeter;",
          " * style.rounded = true;",
          " * graph.getStylesheet().putCellStyle('rounded', style);",
          " * ```",
          " *",
          " * In the above example, the new style is an object. The possible keys of",
          " * the object are all the constants in {@link mxConstants} that start with STYLE",
          " * and the values are either JavaScript objects, such as",
          " * {@link mxPerimeter.RightAngleRectanglePerimeter} (which is in fact a function)",
          " * or expressions, such as true. Note that not all keys will be",
          " * interpreted by all shapes (eg. the line shape ignores the fill color).",
          " * The final call to this method associates the style with a name in the",
          " * stylesheet. The style is used in a cell with the following code:",
          " *",
          " * ```javascript",
          " * model.setStyle(cell, 'rounded');",
          " * ```",
          " *",
          " * @param name Name for the style to be stored.",
          " * @param style Key, value pairs that define the style.",
          " */"
        ]
      ],
      "getCellStyle": [
        "getCellStyle(name: string, defaultStyle?: StyleMap): StyleMap;",
        [
          "/**",
          " * Returns the cell style for the specified stylename or the given",
          " * defaultStyle if no style can be found for the given stylename.",
          " *",
          " * @param name String of the form [(stylename|key=value);] that represents the style.",
          " * @param defaultStyle Default style to be returned if no style can be found.",
          " */"
        ]
      ]
    }
  ],
  "mxOutline": [
    [
      "/**",
      " * @class mxOutline",
      " *",
      " * Implements an outline (aka overview) for a graph. Set {@link updateOnPan} to true",
      " * to enable updates while the source graph is panning.",
      " *",
      " * ### Example",
      " *",
      " * @example",
      " * ```javascript",
      " * var outline = new mxOutline(graph, div);",
      " * ```",
      " *",
      " * If an outline is used in an {@link mxWindow} in IE8 standards mode, the following",
      " * code makes sure that the shadow filter is not inherited and that any",
      " * transparent elements in the graph do not show the page background, but the",
      " * background of the graph container.",
      " *",
      " * @example",
      " * ```javascript",
      " * if (document.documentMode == 8)",
      " * {",
      " *   container.style.filter = 'progid:DXImageTransform.Microsoft.alpha(opacity=100)';",
      " * }",
      " * ```",
      " *",
      " * To move the graph to the top, left corner the following code can be used.",
      " *",
      " * @example",
      " * ```javascript",
      " * var scale = graph.view.scale;",
      " * var bounds = graph.getGraphBounds();",
      " * graph.view.setTranslate(-bounds.x / scale, -bounds.y / scale);",
      " * ```",
      " *",
      " * To toggle the suspended mode, the following can be used.",
      " *",
      " * @example",
      " * ```javascript",
      " * outline.suspended = !outln.suspended;",
      " * if (!outline.suspended)",
      " * {",
      " *   outline.update(true);",
      " * }",
      " * ```",
      " */"
    ],
    {
      "constructor": [
        "constructor(source: mxGraph, container: HTMLElement);",
        [
          "/**",
          " * @constructor mxOutline",
          " *",
          " * Constructs a new outline for the specified graph inside the given",
          " * container.",
          " *",
          " * @param source {@link mxGraph} to create the outline for.",
          " * @param container DOM node that will contain the outline.",
          " */"
        ]
      ],
      "source": [
        "source: mxGraph;",
        [
          "/**",
          " * Reference to the source {@link mxGraph}.",
          " */"
        ]
      ],
      "outline": [
        "outline: mxGraph;",
        [
          "/**",
          " * Reference to the {@link mxGraph} that renders the outline.",
          " */"
        ]
      ],
      "graphRenderHint": [
        "graphRenderHint: string;",
        [
          "/**",
          " * Renderhint to be used for the outline graph.",
          " * @default faster",
          " */"
        ]
      ],
      "enabled": [
        "enabled: boolean;",
        [
          "/**",
          " * Specifies if events are handled.",
          " * @default true",
          " */"
        ]
      ],
      "showViewport": [
        "showViewport: boolean;",
        [
          "/**",
          " * Specifies a viewport rectangle should be shown.",
          " * @default true",
          " */"
        ]
      ],
      "border": [
        "border: number;",
        [
          "/**",
          " * Border to be added at the bottom and right.",
          " * @default 10",
          " */"
        ]
      ],
      "sizerSize": [
        "sizerSize: number;",
        [
          "/**",
          " * Specifies the size of the sizer handler.",
          " * @default 8",
          " */"
        ]
      ],
      "labelsVisible": [
        "labelsVisible: boolean;",
        [
          "/**",
          " * Specifies if labels should be visible in the outline.",
          " * @default false",
          " */"
        ]
      ],
      "updateOnPan": [
        "updateOnPan: boolean;",
        [
          "/**",
          " * Specifies if {@link update} should be called for {@link mxEvent.PAN} in the source",
          " * graph.",
          " * @default false",
          " */"
        ]
      ],
      "sizerImage": [
        "sizerImage: mxImage;",
        [
          "/**",
          " * Optional {@link mxImage} to be used for the sizer.",
          " * @default null",
          " */"
        ]
      ],
      "minScale": [
        "minScale: number;",
        [
          "/**",
          " * Minimum scale to be used.",
          " * @default 0.0001",
          " */"
        ]
      ],
      "suspended": [
        "suspended: boolean;",
        [
          "/**",
          " * Optional boolean flag to suspend updates. This flag will",
          " * also suspend repaints of the outline. To toggle this switch, use the",
          " * following code.",
          " *",
          " * @default false",
          " *",
          " * @example",
          " * ```javascript",
          " * nav.suspended = !nav.suspended;",
          " *",
          " * if (!nav.suspended)",
          " * {",
          " *   nav.update(true);",
          " * }",
          " * ```",
          " */"
        ]
      ],
      "forceVmlHandles": [
        "forceVmlHandles: number;",
        [
          "/**",
          " * Specifies if VML should be used to render the handles in this control. This",
          " * is true for IE8 standards mode and false for all other browsers and modes.",
          " * This is a workaround for rendering issues of HTML elements over elements",
          " * with filters in IE 8 standards mode.",
          " */"
        ]
      ],
      "createGraph": [
        "createGraph(container: HTMLElement): mxGraph;",
        [
          "/**",
          " * Creates the {@link mxGraph} used in the outline.",
          " */"
        ]
      ],
      "init": [
        "init(container: HTMLElement): void;",
        [
          "/**",
          " * Initializes the outline inside the given container.",
          " */"
        ]
      ],
      "isEnabled": [
        "isEnabled(): boolean;",
        [
          "/**",
          " * Returns true if events are handled. This implementation",
          " * returns {@link enabled}.",
          " */"
        ]
      ],
      "setEnabled": [
        "setEnabled(value: boolean): void;",
        [
          "/**",
          " * Enables or disables event handling. This implementation",
          " * updates {@link enabled}.",
          " *",
          " * @param value Boolean that specifies the new enabled state.",
          " */"
        ]
      ],
      "setZoomEnabled": [
        "setZoomEnabled(value: boolean): void;",
        [
          "/**",
          " * Enables or disables the zoom handling by showing or hiding the respective",
          " * handle.",
          " *",
          " * @param value Boolean that specifies the new enabled state.",
          " */"
        ]
      ],
      "refresh": [
        "refresh(): void;",
        [
          "/**",
          " * Invokes {@link update} and revalidate the outline. This method is deprecated.",
          " */"
        ]
      ],
      "createSizer": [
        "createSizer(): mxShape;",
        [
          "/**",
          " * Creates the shape used as the sizer.",
          " */"
        ]
      ],
      "getSourceContainerSize": [
        "getSourceContainerSize(): mxRectangle;",
        [
          "/**",
          " * Returns the size of the source container.",
          " */"
        ]
      ],
      "getOutlineOffset": [
        "getOutlineOffset(scale?: number): mxPoint;",
        [
          "/**",
          " * Returns the offset for drawing the outline graph.",
          " */"
        ]
      ],
      "getSourceGraphBounds": [
        "getSourceGraphBounds(): mxRectangle;",
        [
          "/**",
          " * Returns the offset for drawing the outline graph.",
          " */"
        ]
      ],
      "update": [
        "update(revalidate: boolean): void;",
        [
          "/**",
          " * Updates the outline.",
          " */"
        ]
      ],
      "mouseDown": [
        "mouseDown(sender: mxEventSource, me: mxMouseEvent): void;",
        [
          "/**",
          " * Handles the event by starting a translation or zoom.",
          " */"
        ]
      ],
      "mouseMove": [
        "mouseMove(sender: mxEventSource, me: mxMouseEvent): void;",
        [
          "/**",
          " * Handles the event by previewing the viewrect in {@link graph} and updating the",
          " * rectangle that represents the viewrect in the outline.",
          " */"
        ]
      ],
      "getTranslateForEvent": [
        "getTranslateForEvent(me: mxMouseEvent): mxPoint;",
        [
          "/**",
          " * Gets the translate for the given mouse event. Here is an example to limit",
          " * the outline to stay within positive coordinates:",
          " *",
          " * @example",
          " * ```javascript",
          " * outline.getTranslateForEvent(me)",
          " * {",
          " *   var pt = new mxPoint(me.getX() - this.startX, me.getY() - this.startY);",
          " *",
          " *   if (!this.zoom)",
          " *   {",
          " *     var tr = this.source.view.translate;",
          " *     pt.x = Math.max(tr.x * this.outline.view.scale, pt.x);",
          " *     pt.y = Math.max(tr.y * this.outline.view.scale, pt.y);",
          " *   }",
          " *",
          " *   return pt;",
          " * };",
          " * ```",
          " */"
        ]
      ],
      "mouseUp": [
        "mouseUp(sender: mxEventSource, me: mxMouseEvent): void;",
        [
          "/**",
          " * Handles the event by applying the translation or zoom to {@link graph}.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Destroy this outline and removes all listeners from {@link source}.",
          " */"
        ]
      ]
    }
  ],
  "mxTemporaryCellStates": [
    [
      "/**",
      " * @class mxTemporaryCellStates",
      " *",
      " * Creates a temporary set of cell states.",
      " */"
    ],
    {
      ");": [
        ");",
        null
      ],
      "view": [
        "view: number;",
        [
          "/**",
          " * Holds the width of the rectangle.",
          " * @default 0",
          " */"
        ]
      ],
      "oldStates": [
        "oldStates: number;",
        [
          "/**",
          " * Holds the height of the rectangle.",
          " * @default 0",
          " */"
        ]
      ],
      "oldBounds": [
        "oldBounds: number;",
        [
          "/**",
          " * Holds the height of the rectangle.",
          " * @default 0",
          " */"
        ]
      ],
      "oldScale": [
        "oldScale: number;",
        [
          "/**",
          " * Holds the height of the rectangle.",
          " * @default 0",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Holds the height of the rectangle.",
          " * @default 0",
          " */"
        ]
      ]
    }
  ],
  "mxLayoutManager": [
    [
      "/**",
      " * @class mxLayoutManager",
      " * @extends {mxEventSource}",
      " *",
      " * Implements a layout manager that runs a given layout after any changes to the graph:",
      " *",
      " * ### Example",
      " *",
      " * @example",
      " * ```javascript",
      " * var layoutMgr = new mxLayoutManager(graph);",
      " * layoutMgr.getLayout(cell, eventName)",
      " * {",
      " *   return layout;",
      " * };",
      " * ```",
      " *",
      " * See {@link getLayout} for a description of the possible eventNames.",
      " *",
      " * #### Event: mxEvent.LAYOUT_CELLS",
      " *",
      " * Fires between begin- and endUpdate after all cells have been layouted in",
      " * {@link layoutCells}. The `cells` property contains all cells that have",
      " * been passed to {@link layoutCells}.",
      " */"
    ],
    {
      "constructor": [
        "constructor(graph: mxGraph);",
        [
          "/**",
          " * Constructor: mxLayoutManager",
          " *",
          " * Constructs a new automatic layout for the given graph.",
          " *",
          " * Arguments:",
          " *",
          " * @param graph Reference to the enclosing graph.",
          " */"
        ]
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Reference to the enclosing {@link mxGraph}.",
          " */"
        ]
      ],
      "bubbling": [
        "bubbling: boolean;",
        [
          "/**",
          " * Specifies if the layout should bubble along",
          " * the cell hierarchy.",
          " * @default true",
          " */"
        ]
      ],
      "enabled": [
        "enabled: boolean;",
        [
          "/**",
          " * Specifies if event handling is enabled.",
          " * @default true",
          " */"
        ]
      ],
      "undoHandler": [
        "undoHandler: Function;",
        [
          "/**",
          " * Holds the function that handles the endUpdate event.",
          " */"
        ]
      ],
      "moveHandler": [
        "moveHandler: Function;",
        [
          "/**",
          " * Holds the function that handles the move event.",
          " */"
        ]
      ],
      "resizeHandler": [
        "resizeHandler: Function;",
        [
          "/**",
          " * Holds the function that handles the resize event.",
          " */"
        ]
      ],
      "isEnabled": [
        "isEnabled(): boolean;",
        [
          "/**",
          " * Returns true if events are handled. This implementation",
          " * returns {@link enabled}.",
          " */"
        ]
      ],
      "setEnabled": [
        "setEnabled(enabled: boolean): void;",
        [
          "/**",
          " * Enables or disables event handling. This implementation",
          " * updates {@link enabled}.",
          " *",
          " * @param enabled Boolean that specifies the new enabled state.",
          " */"
        ]
      ],
      "isBubbling": [
        "isBubbling(): boolean;",
        [
          "/**",
          " * Returns true if a layout should bubble, that is, if the parent layout",
          " * should be executed whenever a cell layout (layout of the children of",
          " * a cell) has been executed. This implementation returns {@link bubbling}.",
          " */"
        ]
      ],
      "setBubbling": [
        "setBubbling(value: boolean): void;",
        [
          "/**",
          " * Sets {@link bubbling}.",
          " */"
        ]
      ],
      "getGraph": [
        "getGraph(): mxGraph;",
        [
          "/**",
          " * Returns the graph that this layout operates on.",
          " */"
        ]
      ],
      "setGraph": [
        "setGraph(graph: mxGraph): void;",
        [
          "/**",
          " * Sets the graph that the layouts operate on.",
          " */"
        ]
      ],
      "getLayout": [
        "getLayout(cell: mxCell, eventName?: string): mxGraphLayout | null;",
        [
          "/**",
          " * Returns the layout for the given cell and eventName. Possible",
          " * event names are {@link mxEvent.MOVE_CELLS} and {@link mxEvent.RESIZE_CELLS}",
          " * for callbacks on when cells are moved or resized and",
          " * {@link mxEvent.BEGIN_UPDATE} and {@link mxEvent.END_UPDATE} for the capture",
          " * and bubble phase of the layout after any changes of the model.",
          " */"
        ]
      ],
      "beforeUndo": [
        "beforeUndo(undoableEdit: any): void;",
        [
          "/**",
          " * Called from {@link undoHandler}.",
          " *",
          " * @param cell Array of {@link mxCell} that have been moved.",
          " * @param evt Mouse event that represents the mousedown.",
          " *",
          " * TODO: what is undoableEdit type?",
          " */"
        ]
      ],
      "cellsMoved": [
        "cellsMoved(cells: Array<mxCell>, evt: MouseEvent): void;",
        [
          "/**",
          " * Called from {@link moveHandler}.",
          " *",
          " * @param cell Array of {@link mxCell} that have been moved.",
          " * @param evt Mouse event that represents the mousedown.",
          " */"
        ]
      ],
      "cellsResized": [
        "cellsResized(cells: Array<mxCell>, bounds: Array<mxRectangle>, prev: Array<any>): void;",
        [
          "/**",
          " * Called from {@link resizeHandler}.",
          " *",
          " * @param cell Array of {@link mxCell} that have been resized.",
          " * @param bounds {@link mxRectangle} taht represents the new bounds.",
          " */"
        ]
      ],
      "getAncestorLayout": [
        "getAncestorLayout(cell: mxCell, eventName: string): mxGraphLayout;",
        [
          "/**",
          " * Returns the cells to be layouted for the given sequence of changes.",
          " */"
        ]
      ],
      "getCellsForChanges": [
        "getCellsForChanges(changes: Array<any>): Array<mxCell>;",
        [
          "/**",
          " * Returns the cells for which a layout should be executed.",
          " */"
        ]
      ],
      "getCellsForChange": [
        "getCellsForChange(change: any): Array<mxCell>;",
        [
          "/**",
          " * Executes all layouts which have been scheduled during the",
          " * changes.",
          " * @param change  mxChildChange|mxTerminalChange|mxVisibleChange|...",
          " */"
        ]
      ],
      "addCellsWithLayout": [
        "addCellsWithLayout(cell: mxCell, result: Array<mxCell>): Array<mxCell>;",
        [
          "/**",
          " * Adds all ancestors of the given cell that have a layout.",
          " */"
        ]
      ],
      "addAncestorsWithLayout": [
        "addAncestorsWithLayout(cell: mxCell, result: Array<mxCell>): Array<mxCell>;",
        [
          "/**",
          " * Adds all ancestors of the given cell that have a layout.",
          " */"
        ]
      ],
      "addDescendantsWithLayout": [
        "addDescendantsWithLayout(cell: mxCell, result: Array<mxCell>): Array<mxCell>;",
        [
          "/**",
          " * Adds all descendants of the given cell that have a layout.",
          " */"
        ]
      ],
      "executeLayoutForCells": [
        "executeLayoutForCells(cells: Array<mxCell>): void;",
        [
          "/**",
          " * Executes the given layout on the given parent.",
          " */"
        ]
      ],
      "layoutCells": [
        "layoutCells(cells: Array<mxCell>, bubble: string): void;",
        [
          "/**",
          " * Executes all layouts which have been scheduled during the changes.",
          " */"
        ]
      ],
      "executeLayout": [
        "executeLayout(cell: mxCell, bubble: string): void;",
        [
          "/**",
          " * Executes the given layout on the given parent.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Removes all handlers from the {@link graph} and deletes the reference to it.",
          " */"
        ]
      ]
    }
  ],
  "mxCellStatePreview": [
    [
      "/**",
      " *",
      " * @class mxCellStatePreview",
      " *",
      " * Implements a live preview for moving cells.",
      " */"
    ],
    {
      "constructor": [
        "constructor(graph: mxGraph);",
        [
          "/**",
          " * Constructs a move preview for the given graph.",
          " *",
          " * @param {mxGraph} graph Reference to the enclosing <mxGraph>.",
          " * @constructor",
          " * @memberof mxCellStatePreview",
          " */"
        ]
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Reference to the enclosing <mxGraph>.",
          " */"
        ]
      ],
      "deltas": [
        "deltas: mxDictionary;",
        [
          "/**",
          " * Reference to the enclosing <mxGraph>.",
          " */"
        ]
      ],
      "count": [
        "count: number;",
        [
          "/**",
          " * Contains the number of entries in the map.",
          " */"
        ]
      ],
      "isEmpty": [
        "isEmpty(): boolean;",
        [
          "/**",
          " * Returns true if this contains no entries.",
          " */"
        ]
      ],
      "moveState": [
        "moveState(state: mxCellState, dx: number, dy: number, add: boolean, includeEdges: boolean): mxPoint;",
        [
          "/**",
          " *",
          " *",
          " * @param {mxCellState} state",
          " * @param {number} dx",
          " * @param {number} dy",
          " * @param {boolean} add",
          " * @param {boolean} includeEdges",
          " * @return {*}  {mxPoint}",
          " * @memberof mxCellStatePreview",
          " */"
        ]
      ],
      "show": [
        "show(visitor: Function): void;",
        [
          "/**",
          " *",
          " *",
          " * @param {Function} visitor",
          " * @memberof mxCellStatePreview",
          " */"
        ]
      ],
      "translateState": [
        "translateState(state: mxCellState, dx: number, dy: number): void;",
        [
          "/**",
          " *",
          " *",
          " * @param {mxCellState} state",
          " * @param {number} dx",
          " * @param {number} dy",
          " * @memberof mxCellStatePreview",
          " */"
        ]
      ],
      "revalidateState": [
        "revalidateState(state: mxCellState, dx: number, dy: number, visitor: Function): void;",
        [
          "/**",
          " *",
          " *",
          " * @param {mxCellState} state",
          " * @param {number} dx",
          " * @param {number} dy",
          " * @param {Function} visitor",
          " * @memberof mxCellStatePreview",
          " */"
        ]
      ],
      "addEdges": [
        "addEdges(state: mxCellState): void;",
        [
          "/**",
          " *",
          " *",
          " * @param {mxCellState} state",
          " * @memberof mxCellStatePreview",
          " */"
        ]
      ]
    }
  ],
  "mxCellEditor": [
    null,
    {
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Variable: graph",
          " *",
          " * Reference to the enclosing <mxGraph>.",
          " */"
        ]
      ],
      "textarea": [
        "textarea: Element;",
        [
          "/**",
          " * Variable: textarea",
          " *",
          " * Holds the DIV that is used for text editing. Note that this may be null before the first",
          " * edit. Instantiated in <init>.",
          " */"
        ]
      ],
      "editingCell": [
        "editingCell: mxCell;",
        [
          "/**",
          " * Variable: editingCell",
          " *",
          " * Reference to the <mxCell> that is currently being edited.",
          " */"
        ]
      ],
      "trigger": [
        "trigger: MouseEvent;",
        [
          "/**",
          " * Variable: trigger",
          " *",
          " * Reference to the event that was used to start editing.",
          " */"
        ]
      ],
      "modified": [
        "modified: boolean;",
        [
          "/**",
          " * Variable: modified",
          " *",
          " * Specifies if the label has been modified.",
          " */"
        ]
      ],
      "autoSize": [
        "autoSize: boolean;",
        [
          "/**",
          " * Variable: autoSize",
          " *",
          " * Specifies if the textarea should be resized while the text is being edited.",
          " * Default is true.",
          " */"
        ]
      ],
      "selectText": [
        "selectText: boolean;",
        [
          "/**",
          " * Variable: selectText",
          " *",
          " * Specifies if the text should be selected when editing starts. Default is",
          " * true.",
          " */"
        ]
      ],
      "emptyLabelText": [
        "emptyLabelText: '<br>' | '';",
        [
          "/**",
          " * Variable: emptyLabelText",
          " *",
          " * Text to be displayed for empty labels. Default is '' or '<br>' in Firefox as",
          " * a workaround for the missing cursor bug for empty content editable. This can",
          " * be set to eg. \"[Type Here]\" to easier visualize editing of empty labels. The",
          " * value is only displayed before the first keystroke and is never used as the",
          " * actual editing value.",
          " */"
        ]
      ],
      "escapeCancelsEditing": [
        "escapeCancelsEditing: boolean;",
        [
          "/**",
          " * Variable: escapeCancelsEditing",
          " *",
          " * If true, pressing the escape key will stop editing and not accept the new",
          " * value. Change this to false to accept the new value on escape, and cancel",
          " * editing on Shift+Escape instead. Default is true.",
          " */"
        ]
      ],
      "textNode": [
        "textNode: string;",
        [
          "/**",
          " * Variable: textNode",
          " *",
          " * Reference to the label DOM node that has been hidden.",
          " */"
        ]
      ],
      "zIndex": [
        "zIndex: number;",
        [
          "/**",
          " * Variable: zIndex",
          " *",
          " * Specifies the zIndex for the textarea. Default is 5.",
          " */"
        ]
      ],
      "minResize": [
        "minResize: mxRectangle;",
        [
          "/**",
          " * Variable: minResize",
          " *",
          " * Defines the minimum width and height to be used in <resize>. Default is 0x20px.",
          " */"
        ]
      ],
      "wordWrapPadding": [
        "wordWrapPadding: 2 | 1 | 0;",
        [
          "/**",
          " * Variable: wordWrapPadding",
          " *",
          " * Correction factor for word wrapping width. Default is 2 in quirks, 0 in IE",
          " * 11 and 1 in all other browsers and modes.",
          " */"
        ]
      ],
      "blurEnabled": [
        "blurEnabled: boolean;",
        [
          "/**",
          " * Variable: blurEnabled",
          " *",
          " * If <focusLost> should be called if <textarea> loses the focus. Default is false.",
          " */"
        ]
      ],
      "initialValue": [
        "initialValue: string;",
        [
          "/**",
          " * Variable: initialValue",
          " *",
          " * Holds the initial editing value to check if the current value was modified.",
          " */"
        ]
      ],
      "constructor": [
        "constructor(graph: mxGraph);",
        [
          "/**",
          " * Variable: initialValue",
          " *",
          " * Holds the initial editing value to check if the current value was modified.",
          " */"
        ]
      ],
      "init": [
        "init(): void;",
        [
          "/**",
          " * Function: init",
          " *",
          " * Creates the <textarea> and installs the event listeners. The key handler",
          " * updates the <modified> state.",
          " */"
        ]
      ],
      "applyValue": [
        "applyValue(state: mxCellState, value: string): void;",
        [
          "/**",
          " * Function: applyValue",
          " *",
          " * Called in <stopEditing> if cancel is false to invoke <mxGraph.labelChanged>.",
          " */"
        ]
      ],
      "getInitialValue": [
        "getInitialValue(state: mxCellState, trigger: Event): string;",
        [
          "/**",
          " * Function: getInitialValue",
          " *",
          " * Gets the initial editing value for the given cell.",
          " */"
        ]
      ],
      "getCurrentValue": [
        "getCurrentValue(state: mxCellState): string;",
        [
          "/**",
          " * Function: getCurrentValue",
          " *",
          " * Returns the current editing value.",
          " */"
        ]
      ],
      "isCancelEditingKeyEvent": [
        "isCancelEditingKeyEvent(evt: Event): boolean;",
        [
          "/**",
          " * Function: isCancelEditingKeyEvent",
          " *",
          " * Returns true if <escapeCancelsEditing> is true and shift, control and meta",
          " * are not pressed.",
          " */"
        ]
      ],
      "installListeners": [
        "installListeners(elt: Element): void;",
        [
          "/**",
          " * Function: installListeners",
          " *",
          " * Installs listeners for focus, change and standard key event handling.",
          " */"
        ]
      ],
      "isStopEditingEvent": [
        "isStopEditingEvent(evt: Event): boolean;",
        [
          "/**",
          " * Function: isStopEditingEvent",
          " *",
          " * Returns true if the given keydown event should stop cell editing. This",
          " * returns true if F2 is pressed of if <mxGraph.enterStopsCellEditing> is true",
          " * and enter is pressed without control or shift.",
          " */"
        ]
      ],
      "isEventSource": [
        "isEventSource(evt: Event): boolean;",
        [
          "/**",
          " * Function: isEventSource",
          " *",
          " * Returns true if this editor is the source for the given native event.",
          " */"
        ]
      ],
      "resize": [
        "resize(): void;",
        [
          "/**",
          " * Function: resize",
          " *",
          " * Returns <modified>.",
          " */"
        ]
      ],
      "focusLost": [
        "focusLost(): void;",
        [
          "/**",
          " * Function: focusLost",
          " *",
          " * Called if the textarea has lost focus.",
          " */"
        ]
      ],
      "getBackgroundColor": [
        "getBackgroundColor(state: mxCellState): string;",
        [
          "/**",
          " * Function: getBackgroundColor",
          " *",
          " * Returns the background color for the in-place editor. This implementation",
          " * always returns null.",
          " */"
        ]
      ],
      "isLegacyEditor": [
        "isLegacyEditor(): boolean;",
        [
          "/**",
          " * Function: isLegacyEditor",
          " *",
          " * Returns true if max-width is not supported or if the SVG root element in",
          " * in the graph does not have CSS position absolute. In these cases the text",
          " * editor must use CSS position absolute to avoid an offset but it will have",
          " * a less accurate line wrapping width during the text editing preview. This",
          " * implementation returns true for IE8- and quirks mode or if the CSS position",
          " * of the SVG element is not absolute.",
          " */"
        ]
      ],
      "startEditing": [
        "startEditing(cell: mxCell, trigger?: MouseEvent): void;",
        [
          "/**",
          " * Function: startEditing",
          " *",
          " * Starts the editor for the given cell.",
          " *",
          " * Parameters:",
          " *",
          " * cell - <mxCell> to start editing.",
          " * trigger - Optional mouse event that triggered the editor.",
          " */"
        ]
      ],
      "isSelectText": [
        "isSelectText(): boolean;",
        [
          "/**",
          " * Function: isSelectText",
          " *",
          " * Returns <selectText>.",
          " */"
        ]
      ],
      "clearSelection": [
        "clearSelection(): void;",
        [
          "/**",
          " * Function: clearSelection",
          " */"
        ]
      ],
      "stopEditing": [
        "stopEditing(cancel: boolean): void;",
        [
          "/**",
          " * Function: stopEditing",
          " *",
          " * Stops the editor and applies the value if cancel is false.",
          " */"
        ]
      ],
      "prepareTextarea": [
        "prepareTextarea(): void;",
        [
          "/**",
          " * Function: prepareTextarea",
          " *",
          " * Prepares the textarea for getting its value in <stopEditing>.",
          " * This implementation removes the extra trailing linefeed in Firefox.",
          " */"
        ]
      ],
      "isHideLabel": [
        "isHideLabel(state: mxCellState): boolean;",
        [
          "/**",
          " * Function: isHideLabel",
          " *",
          " * Returns true if the label should be hidden while the cell is being",
          " * edited.",
          " */"
        ]
      ],
      "getMinimumSize": [
        "getMinimumSize(state: mxCellState): mxRectangle;",
        [
          "/**",
          " * Function: getMinimumSize",
          " *",
          " * Returns the minimum width and height for editing the given state.",
          " */"
        ]
      ],
      "getEditorBounds": [
        "getEditorBounds(state: mxCellState): mxRectangle;",
        [
          "/**",
          " * Function: getEditorBounds",
          " *",
          " * Returns the <mxRectangle> that defines the bounds of the editor.",
          " */"
        ]
      ],
      "getEmptyLabelText": [
        "getEmptyLabelText(cell: mxCell): string;",
        [
          "/**",
          " * Function: getEmptyLabelText",
          " *",
          " * Returns the initial label value to be used of the label of the given",
          " * cell is empty. This label is displayed and cleared on the first keystroke.",
          " * This implementation returns <emptyLabelText>.",
          " *",
          " * Parameters:",
          " *",
          " * cell - <mxCell> for which a text for an empty editing box should be",
          " * returned.",
          " */"
        ]
      ],
      "getEditingCell": [
        "getEditingCell(): mxCell;",
        [
          "/**",
          " * Function: getEditingCell",
          " *",
          " * Returns the cell that is currently being edited or null if no cell is",
          " * being edited.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Function: destroy",
          " *",
          " * Destroys the editor and removes all associated resources.",
          " */"
        ]
      ]
    }
  ],
  "mxCellOverlay": [
    null,
    {
      ");": [
        ");",
        null
      ],
      "image": [
        "image: mxImage;",
        [
          "/**",
          " * Variable: image",
          " *",
          " * Holds the <mxImage> to be used as the icon.",
          " */"
        ]
      ],
      "tooltip?": [
        "tooltip?: string;",
        [
          "/**",
          " * Variable: tooltip",
          " *",
          " * Holds the optional string to be used as the tooltip.",
          " */"
        ]
      ],
      "align": [
        "align: string;",
        [
          "/**",
          " * Variable: align",
          " *",
          " * Holds the horizontal alignment for the overlay. Default is",
          " * <mxConstants.ALIGN_RIGHT>. For edges, the overlay always appears in the",
          " * center of the edge.",
          " */"
        ]
      ],
      "verticalAlign": [
        "verticalAlign: string;",
        [
          "/**",
          " * Variable: verticalAlign",
          " *",
          " * Holds the vertical alignment for the overlay. Default is",
          " * <mxConstants.ALIGN_BOTTOM>. For edges, the overlay always appears in the",
          " * center of the edge.",
          " */"
        ]
      ],
      "offset": [
        "offset: mxPoint;",
        [
          "/**",
          " * Variable: offset",
          " *",
          " * Holds the offset as an <mxPoint>. The offset will be scaled according to the",
          " * current scale.",
          " */"
        ]
      ],
      "cursor": [
        "cursor: string;",
        [
          "/**",
          " * Variable: cursor",
          " *",
          " * Holds the cursor for the overlay. Default is 'help'.",
          " */"
        ]
      ],
      "defaultOverlap": [
        "defaultOverlap: number;",
        [
          "/**",
          " * Variable: defaultOverlap",
          " *",
          " * Defines the overlapping for the overlay, that is, the proportional distance",
          " * from the origin to the point defined by the alignment. Default is 0.5.",
          " */"
        ]
      ],
      "getBounds": [
        "getBounds(state: mxCellState): mxRectangle;",
        [
          "/**",
          " * Function: getBounds",
          " *",
          " * Returns the bounds of the overlay for the given <mxCellState> as an",
          " * <mxRectangle>. This should be overridden when using multiple overlays",
          " * per cell so that the overlays do not overlap.",
          " *",
          " * The following example will place the overlay along an edge (where",
          " * x=[-1..1] from the start to the end of the edge and y is the",
          " * orthogonal offset in px).",
          " *",
          " * (code)",
          " * overlay.getBounds = function(state)",
          " * {",
          " *   var bounds = getBounds.apply(this, arguments);",
          " *",
          " *   if (state.view.graph.getModel().isEdge(state.cell))",
          " *   {",
          " *     var pt = state.view.getPoint(state, {x: 0, y: 0, relative: true});",
          " *",
          " *     bounds.x = pt.x - bounds.width / 2;",
          " *     bounds.y = pt.y - bounds.height / 2;",
          " *   }",
          " *",
          " *   return bounds;",
          " * };",
          " * (end)",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> that represents the current state of the",
          " * associated cell.",
          " */"
        ]
      ],
      "toString": [
        "toString(): string;",
        [
          "/**",
          " * Function: toString",
          " *",
          " * Returns the textual representation of the overlay to be used as the",
          " * tooltip. This implementation returns <tooltip>.",
          " */"
        ]
      ]
    }
  ],
  "mxGraphView": [
    [
      "/**",
      " * @class mxGraphView",
      " * @extends {mxEventSource}",
      " *",
      " * Extends {@link mxEventSource} to implement a view for a graph. This class is in",
      " * charge of computing the absolute coordinates for the relative child",
      " * geometries, the points for perimeters and edge styles and keeping them",
      " * cached in {@link mxCellStates} for faster retrieval. The states are updated",
      " * whenever the model or the view state (translate, scale) changes. The scale",
      " * and translate are honoured in the bounds.",
      " *",
      " * #### Event: mxEvent.UNDO",
      " *",
      " * Fires after the root was changed in {@link setCurrentRoot}. The `edit`",
      " * property contains the {@link mxUndoableEdit} which contains the",
      " * {@link mxCurrentRootChange}.",
      " *",
      " * #### Event: mxEvent.SCALE_AND_TRANSLATE",
      " *",
      " * Fires after the scale and translate have been changed in {@link scaleAndTranslate}.",
      " * The `scale`, `previousScale`, `translate`",
      " * and `previousTranslate` properties contain the new and previous",
      " * scale and translate, respectively.",
      " *",
      " * #### Event: mxEvent.SCALE",
      " *",
      " * Fires after the scale was changed in {@link setScale}. The `scale` and",
      " * `previousScale` properties contain the new and previous scale.",
      " *",
      " * #### Event: mxEvent.TRANSLATE",
      " *",
      " * Fires after the translate was changed in {@link setTranslate}. The",
      " * `translate` and `previousTranslate` properties contain",
      " * the new and previous value for translate.",
      " *",
      " * #### Event: mxEvent.DOWN and mxEvent.UP",
      " *",
      " * Fire if the current root is changed by executing an {@link mxCurrentRootChange}.",
      " * The event name depends on the location of the root in the cell hierarchy",
      " * with respect to the current root. The `root` and",
      " * `previous` properties contain the new and previous root,",
      " * respectively.",
      " */"
    ],
    {
      "constructor": [
        "constructor(graph: mxGraph);",
        null
      ],
      "canvas": [
        "canvas: SVGSVGElement;",
        null
      ],
      "EMPTY_POINT": [
        "EMPTY_POINT: mxPoint;",
        null
      ],
      "doneResource": [
        "doneResource: 'done' | '';",
        [
          "/**",
          " * Specifies the resource key for the status message after a long operation.",
          " * If the resource for this key does not exist then the value is used as",
          " * the status message. Default is 'done'.",
          " */"
        ]
      ],
      "updatingDocumentResource": [
        "updatingDocumentResource: 'updatingDocument' | '';",
        [
          "/**",
          " * Specifies the resource key for the status message while the document is",
          " * being updated. If the resource for this key does not exist then the",
          " * value is used as the status message. Default is 'updatingDocument'.",
          " */"
        ]
      ],
      "allowEval": [
        "allowEval: boolean;",
        [
          "/**",
          " * Specifies if string values in cell styles should be evaluated using",
          " * {@link mxUtils.eval}. This will only be used if the string values can't be mapped",
          " * to objects using {@link mxStyleRegistry}. Default is false. NOTE: Enabling this",
          " * switch carries a possible security risk.",
          " */"
        ]
      ],
      "captureDocumentGesture": [
        "captureDocumentGesture: boolean;",
        [
          "/**",
          " * Specifies if a gesture should be captured when it goes outside of the",
          " * graph container. Default is true.",
          " */"
        ]
      ],
      "optimizeVmlReflows": [
        "optimizeVmlReflows: boolean;",
        [
          "/**",
          " * Specifies if the {@link canvas} should be hidden while rendering in IE8 standards",
          " * mode and quirks mode. This will significantly improve rendering performance.",
          " * Default is true.",
          " */"
        ]
      ],
      "rendering": [
        "rendering: boolean;",
        [
          "/**",
          " * Specifies if shapes should be created, updated and destroyed using the",
          " * methods of {@link mxCellRenderer} in {@link graph}. Default is true.",
          " */"
        ]
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Reference to the enclosing {@link mxGraph}.",
          " */"
        ]
      ],
      "currentRoot": [
        "currentRoot: mxCell;",
        [
          "/**",
          " * {@link mxCell} that acts as the root of the displayed cell hierarchy.",
          " */"
        ]
      ],
      "graphBounds": [
        "graphBounds: mxRectangle;",
        [
          "/**",
          " * {@link mxRectangle} that caches the scales, translated bounds of the current view.",
          " */"
        ]
      ],
      "scale": [
        "scale: number;",
        [
          "/**",
          " * Specifies the scale. Default is 1 (100%).",
          " */"
        ]
      ],
      "translate": [
        "translate: mxPoint;",
        [
          "/**",
          " * {@link mxPoint} that specifies the current translation. Default is a new",
          " * empty {@link mxPoint}.",
          " */"
        ]
      ],
      "states": [
        "states: mxDictionary<mxCellState>;",
        [
          "/**",
          " * {@link mxDictionary} that maps from cell IDs to {@link mxCellStates}.",
          " */"
        ]
      ],
      "updateStyle": [
        "updateStyle: boolean;",
        [
          "/**",
          " * Specifies if the style should be updated in each validation step. If this",
          " * is false then the style is only updated if the state is created or if the",
          " * style of the cell was changed. Default is false.",
          " */"
        ]
      ],
      "lastNode": [
        "lastNode: Element;",
        [
          "/**",
          " * During validation, this contains the last DOM node that was processed.",
          " */"
        ]
      ],
      "lastHtmlNode": [
        "lastHtmlNode: HTMLElement;",
        [
          "/**",
          " * During validation, this contains the last HTML DOM node that was processed.",
          " */"
        ]
      ],
      "lastForegroundNode": [
        "lastForegroundNode: Element;",
        [
          "/**",
          " * During validation, this contains the last edge's DOM node that was processed.",
          " */"
        ]
      ],
      "lastForegroundHtmlNode": [
        "lastForegroundHtmlNode: HTMLElement;",
        [
          "/**",
          " * During validation, this contains the last edge HTML DOM node that was processed.",
          " */"
        ]
      ],
      "getGraphBounds": [
        "getGraphBounds(): mxRectangle;",
        [
          "/**",
          " * Returns {@link graphBounds}.",
          " */"
        ]
      ],
      "setGraphBounds": [
        "setGraphBounds(value: mxRectangle): void;",
        [
          "/**",
          " * Sets {@link graphBounds}.",
          " */"
        ]
      ],
      "getBounds": [
        "getBounds(cells: mxCell[]): mxRectangle;",
        [
          "/**",
          " * Returns the union of all {@link mxCellStates} for the given array of {@link mxCell}.",
          " *",
          " * @param cells Array of {@link mxCell} whose bounds should be returned.",
          " */"
        ]
      ],
      "setCurrentRoot": [
        "setCurrentRoot(root: mxCell): mxCell;",
        [
          "/**",
          " * Sets and returns the current root and fires an {@link undo} event before",
          " * calling {@link mxGraph.sizeDidChange}.",
          " *",
          " * @param root {@link mxCell} that specifies the root of the displayed cell hierarchy.",
          " */"
        ]
      ],
      "scaleAndTranslate": [
        "scaleAndTranslate(scale: number, dx: number, dy: number): void;",
        [
          "/**",
          " * Sets the scale and translation and fires a {@link scale} and {@link translate} event",
          " * before calling {@link revalidate} followed by {@link mxGraph.sizeDidChange}.",
          " *",
          " * @param scale Decimal value that specifies the new scale (1 is 100%).",
          " * @param dx X-coordinate of the translation.",
          " * @param dy Y-coordinate of the translation.",
          " */"
        ]
      ],
      "getScale": [
        "getScale(): number;",
        [
          "/**",
          " * Returns the {@link scale}.",
          " */"
        ]
      ],
      "setScale": [
        "setScale(value: number): void;",
        [
          "/**",
          " * Sets the scale and fires a {@link scale} event before calling {@link revalidate} followed",
          " * by {@link mxGraph.sizeDidChange}.",
          " *",
          " * @param value Decimal value that specifies the new scale (1 is 100%).",
          " */"
        ]
      ],
      "getTranslate": [
        "getTranslate(): mxPoint;",
        [
          "/**",
          " * Returns the {@link translate}.",
          " */"
        ]
      ],
      "setTranslate": [
        "setTranslate(dx: number, dy: number): void;",
        [
          "/**",
          " * Sets the translation and fires a {@link translate} event before calling",
          " * {@link revalidate} followed by {@link mxGraph.sizeDidChange}. The translation is the",
          " * negative of the origin.",
          " *",
          " * @param dx X-coordinate of the translation.",
          " * @param dy Y-coordinate of the translation.",
          " */"
        ]
      ],
      "viewStateChanged": [
        "viewStateChanged(): void;",
        [
          "/**",
          " * Invoked after {@link scale} and/or {@link translate} has changed.",
          " */"
        ]
      ],
      "refresh": [
        "refresh(): void;",
        [
          "/**",
          " * Clears the view if {@link currentRoot} is not null and revalidates.",
          " */"
        ]
      ],
      "revalidate": [
        "revalidate(): void;",
        [
          "/**",
          " * Revalidates the complete view with all cell states.",
          " */"
        ]
      ],
      "clear": [
        "clear(cell?: mxCell, force?: boolean, recurse?: boolean): void;",
        [
          "/**",
          " * Removes the state of the given cell and all descendants if the given",
          " * cell is not the current root.",
          " *",
          " * @param cell Optional {@link mxCell} for which the state should be removed. Default",
          " * is the root of the model.",
          " * @param force Boolean indicating if the current root should be ignored for",
          " * recursion.",
          " */"
        ]
      ],
      "invalidate": [
        "invalidate(cell: mxCell, recurse: boolean, includeEdges: boolean): void;",
        [
          "/**",
          " * Invalidates the state of the given cell, all its descendants and",
          " * connected edges.",
          " *",
          " * @param cell Optional {@link mxCell} to be invalidated. Default is the root of the",
          " * model.",
          " */"
        ]
      ],
      "validate": [
        "validate(cell?: mxCell): void;",
        [
          "/**",
          " * Calls {@link validateCell} and {@link validateCellState} and updates the {@link graphBounds}",
          " * using {@link getBoundingBox}. Finally the background is validated using",
          " * {@link validateBackground}.",
          " *",
          " * @param cell Optional {@link mxCell} to be used as the root of the validation.",
          " * Default is {@link currentRoot} or the root of the model.",
          " */"
        ]
      ],
      "getEmptyBounds": [
        "getEmptyBounds(): mxRectangle;",
        [
          "/**",
          " * Returns the bounds for an empty graph. This returns a rectangle at",
          " * {@link translate} with the size of 0 x 0.",
          " */"
        ]
      ],
      "getBoundingBox": [
        "getBoundingBox(state: mxCellState, recurse: boolean): mxRectangle;",
        [
          "/**",
          " * Returns the bounding box of the shape and the label for the given",
          " * {@link mxCellState} and its children if recurse is true.",
          " *",
          " * @param state {@link mxCellState} whose bounding box should be returned.",
          " * @param recurse Optional boolean indicating if the children should be included.",
          " * Default is true.",
          " */"
        ]
      ],
      "createBackgroundPageShape": [
        "createBackgroundPageShape(bounds: mxRectangle): mxRectangleShape;",
        [
          "/**",
          " * Creates and returns the shape used as the background page.",
          " *",
          " * @param bounds {@link mxRectangle} that represents the bounds of the shape.",
          " */"
        ]
      ],
      "validateBackground": [
        "validateBackground(): void;",
        [
          "/**",
          " * Calls {@link validateBackgroundImage} and {@link validateBackgroundPage}.",
          " */"
        ]
      ],
      "validateBackgroundImage": [
        "validateBackgroundImage(): void;",
        [
          "/**",
          " * Validates the background image.",
          " */"
        ]
      ],
      "validateBackgroundPage": [
        "validateBackgroundPage(): void;",
        [
          "/**",
          " * Validates the background page.",
          " */"
        ]
      ],
      "getBackgroundPageBounds": [
        "getBackgroundPageBounds(): mxRectangle;",
        [
          "/**",
          " * Returns the bounds for the background page.",
          " */"
        ]
      ],
      "redrawBackgroundImage": [
        "redrawBackgroundImage(backgroundImage: mxImageShape, bg: mxImage): void;",
        [
          "/**",
          " * Updates the bounds and redraws the background image.",
          " *",
          " * Example:",
          " *",
          " * If the background image should not be scaled, this can be replaced with",
          " * the following.",
          " *",
          " * @example",
          " * ```javascript",
          " * redrawBackground(backgroundImage, bg)",
          " * {",
          " *   backgroundImage.bounds.x = this.translate.x;",
          " *   backgroundImage.bounds.y = this.translate.y;",
          " *   backgroundImage.bounds.width = bg.width;",
          " *   backgroundImage.bounds.height = bg.height;",
          " *",
          " *   backgroundImage.redraw();",
          " * };",
          " * ```",
          " *",
          " * @param backgroundImage {@link mxImageShape} that represents the background image.",
          " * @param bg {@link mxImage} that specifies the image and its dimensions.",
          " */"
        ]
      ],
      "validateCell": [
        "validateCell(cell: mxCell, visible?: boolean): void;",
        [
          "/**",
          " * Recursively creates the cell state for the given cell if visible is true and",
          " * the given cell is visible. If the cell is not visible but the state exists",
          " * then it is removed using {@link removeState}.",
          " *",
          " * @param cell {@link mxCell} whose {@link mxCellState} should be created.",
          " * @param visible Optional boolean indicating if the cell should be visible. Default",
          " * is true.",
          " */"
        ]
      ],
      "validateCellState": [
        "validateCellState(cell: mxCell, recurse?: boolean): void;",
        [
          "/**",
          " * Validates and repaints the {@link mxCellState} for the given {@link mxCell}.",
          " *",
          " * @param cell {@link mxCell} whose {@link mxCellState} should be validated.",
          " * @param recurse Optional boolean indicating if the children of the cell should be",
          " * validated. Default is true.",
          " */"
        ]
      ],
      "updateCellState": [
        "updateCellState(state: mxCellState): void;",
        [
          "/**",
          " * Updates the given {@link mxCellState}.",
          " *",
          " * @param state {@link mxCellState} to be updated.",
          " */"
        ]
      ],
      "isCellCollapsed": [
        "isCellCollapsed(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the children of the given cell should not be visible in the",
          " * view. This implementation uses {@link mxGraph.isCellVisible} but it can be",
          " * overidden to use a separate condition.",
          " */"
        ]
      ],
      "updateVertexState": [
        "updateVertexState(state: mxCellState, geo: mxGeometry): void;",
        [
          "/**",
          " * Validates the given cell state.",
          " */"
        ]
      ],
      "updateEdgeState": [
        "updateEdgeState(state: mxCellState, geo: mxGeometry): void;",
        [
          "/**",
          " * Validates the given cell state.",
          " */"
        ]
      ],
      "updateVertexLabelOffset": [
        "updateVertexLabelOffset(state: mxCellState): void;",
        [
          "/**",
          " * Updates the absoluteOffset of the given vertex cell state. This takes",
          " * into account the label position styles.",
          " *",
          " * @param state {@link mxCellState} whose absolute offset should be updated.",
          " */"
        ]
      ],
      "resetValidationState": [
        "resetValidationState(): void;",
        [
          "/**",
          " * Resets the current validation state.",
          " */"
        ]
      ],
      "stateValidated": [
        "stateValidated(state: mxCellState): void;",
        [
          "/**",
          " * Invoked when a state has been processed in {@link validatePoints}. This is used",
          " * to update the order of the DOM nodes of the shape.",
          " *",
          " * @param state {@link mxCellState} that represents the cell state.",
          " */"
        ]
      ],
      "updateFixedTerminalPoints": [
        "updateFixedTerminalPoints(edge: mxCellState, source: mxCellState, target: mxCellState): void;",
        [
          "/**",
          " * Sets the initial absolute terminal points in the given state before the edge",
          " * style is computed.",
          " *",
          " * @param edge {@link mxCellState} whose initial terminal points should be updated.",
          " * @param source {@link mxCellState} which represents the source terminal.",
          " * @param target {@link mxCellState} which represents the target terminal.",
          " */"
        ]
      ],
      ")": [
        "): void;",
        [
          "/**",
          " * Returns the fixed source or target terminal point for the given edge.",
          " *",
          " * @param edge {@link mxCellState} whose terminal point should be returned.",
          " * @param terminal {@link mxCellState} which represents the actual terminal.",
          " * @param source Boolean that specifies if the terminal is the source.",
          " * @param constraint {@link mxConnectionConstraint} that specifies the connection.",
          " */"
        ]
      ],
      "updateBoundsFromStencil": [
        "updateBoundsFromStencil(state: mxCellState): mxRectangle;",
        [
          "/**",
          " * Updates the bounds of the given cell state to reflect the bounds of the stencil",
          " * if it has a fixed aspect and returns the previous bounds as an {@link mxRectangle} if",
          " * the bounds have been modified or null otherwise.",
          " *",
          " * @param edge {@link mxCellState} whose bounds should be updated.",
          " */"
        ]
      ],
      "updatePoints": [
        "updatePoints(edge: mxCellState, points: mxPoint[], source: mxCellState, target: mxCellState): void;",
        [
          "/**",
          " * Updates the absolute points in the given state using the specified array",
          " * of {@link mxPoints} as the relative points.",
          " *",
          " * @param edge {@link mxCellState} whose absolute points should be updated.",
          " * @param points Array of {@link mxPoints} that constitute the relative points.",
          " * @param source {@link mxCellState} that represents the source terminal.",
          " * @param target {@link mxCellState} that represents the target terminal.",
          " */"
        ]
      ],
      "transformControlPoint": [
        "transformControlPoint(state: mxCellState, pt: mxPoint): mxPoint;",
        [
          "/**",
          " * Transforms the given control point to an absolute point.",
          " */"
        ]
      ],
      "isLoopStyleEnabled": [
        "isLoopStyleEnabled(edge: mxCellState, points: mxPoint[], source: mxCellState, target: mxCellState): boolean;",
        [
          "/**",
          " * Returns true if the given edge should be routed with {@link mxGraph.defaultLoopStyle}",
          " * or the {@link mxConstants.STYLE_LOOP} defined for the given edge. This implementation",
          " * returns true if the given edge is a loop and does not",
          " */"
        ]
      ],
      "getEdgeStyle": [
        "getEdgeStyle(edge: mxCellState, points: mxPoint[], source: mxCellState, target: mxCellState): any;",
        [
          "/**",
          " * Returns the edge style function to be used to render the given edge state.",
          " */"
        ]
      ],
      "updateFloatingTerminalPoints": [
        "updateFloatingTerminalPoints(state: mxCellState, source: mxCellState, target: mxCellState): void;",
        [
          "/**",
          " * Updates the terminal points in the given state after the edge style was",
          " * computed for the edge.",
          " *",
          " * @param state {@link mxCellState} whose terminal points should be updated.",
          " * @param source {@link mxCellState} that represents the source terminal.",
          " * @param target {@link mxCellState} that represents the target terminal.",
          " */"
        ]
      ],
      "updateFloatingTerminalPoint": [
        "updateFloatingTerminalPoint(edge: mxCellState, start: mxCellState, end: mxCellState, source: boolean): void;",
        [
          "/**",
          " * Updates the absolute terminal point in the given state for the given",
          " * start and end state, where start is the source if source is true.",
          " *",
          " * @param edge {@link mxCellState} whose terminal point should be updated.",
          " * @param start {@link mxCellState} for the terminal on \"this\" side of the edge.",
          " * @param end {@link mxCellState} for the terminal on the other side of the edge.",
          " * @param source Boolean indicating if start is the source terminal state.",
          " */"
        ]
      ],
      "getFloatingTerminalPoint": [
        "getFloatingTerminalPoint(edge: mxCellState, start: mxCellState, end: mxCellState, source: boolean): mxPoint;",
        [
          "/**",
          " * Returns the floating terminal point for the given edge, start and end",
          " * state, where start is the source if source is true.",
          " *",
          " * @param edge {@link mxCellState} whose terminal point should be returned.",
          " * @param start {@link mxCellState} for the terminal on \"this\" side of the edge.",
          " * @param end {@link mxCellState} for the terminal on the other side of the edge.",
          " * @param source Boolean indicating if start is the source terminal state.",
          " */"
        ]
      ],
      "getTerminalPort": [
        "getTerminalPort(state: mxCellState, terminal: mxCellState, source: boolean): mxCellState;",
        [
          "/**",
          " * Returns an {@link mxCellState} that represents the source or target terminal or",
          " * port for the given edge.",
          " *",
          " * @param state {@link mxCellState} that represents the state of the edge.",
          " * @param terminal {@link mxCellState} that represents the terminal.",
          " * @param source Boolean indicating if the given terminal is the source terminal.",
          " */"
        ]
      ],
      "getPerimeterPoint": [
        "getPerimeterPoint(terminal: mxCellState, next: mxPoint, orthogonal: boolean, border: number): mxPoint;",
        [
          "/**",
          " * Returns an {@link mxPoint} that defines the location of the intersection point between",
          " * the perimeter and the line between the center of the shape and the given point.",
          " *",
          " * @param terminal {@link mxCellState} for the source or target terminal.",
          " * @param next {@link mxPoint} that lies outside of the given terminal.",
          " * @param orthogonal Boolean that specifies if the orthogonal projection onto",
          " * the perimeter should be returned. If this is false then the intersection",
          " * of the perimeter and the line between the next and the center point is",
          " * returned.",
          " * @param border Optional border between the perimeter and the shape.",
          " */"
        ]
      ],
      "getRoutingCenterX": [
        "getRoutingCenterX(state: mxCellState): number;",
        [
          "/**",
          " * Returns the x-coordinate of the center point for automatic routing.",
          " */"
        ]
      ],
      "getRoutingCenterY": [
        "getRoutingCenterY(state: mxCellState): number;",
        [
          "/**",
          " * Returns the y-coordinate of the center point for automatic routing.",
          " */"
        ]
      ],
      "getPerimeterBounds": [
        "getPerimeterBounds(terminal: mxCellState, border?: number): mxRectangle;",
        [
          "/**",
          " * Returns the perimeter bounds for the given terminal, edge pair as an",
          " * {@link mxRectangle}.",
          " *",
          " * If you have a model where each terminal has a relative child that should",
          " * act as the graphical endpoint for a connection from/to the terminal, then",
          " * this method can be replaced as follows:",
          " *",
          " * @example",
          " * ```javascript",
          " * var oldGetPerimeterBounds = getPerimeterBounds;",
          " * getPerimeterBounds(terminal, edge, isSource)",
          " * {",
          " *   var model = this.graph.getModel();",
          " *   var childCount = model.getChildCount(terminal.cell);",
          " *",
          " *   if (childCount > 0)",
          " *   {",
          " *     var child = model.getChildAt(terminal.cell, 0);",
          " *     var geo = model.getGeometry(child);",
          " *",
          " *     if (geo != null &&",
          " *         geo.relative)",
          " *     {",
          " *       var state = this.getState(child);",
          " *",
          " *       if (state != null)",
          " *       {",
          " *         terminal = state;",
          " *       }",
          " *     }",
          " *   }",
          " *",
          " *   return oldGetPerimeterBounds.apply(this, arguments);",
          " * };",
          " * ```",
          " *",
          " * @param {mxCellState} terminal mxCellState that represents the terminal.",
          " * @param {number} border Number that adds a border between the shape and the perimeter.",
          " */"
        ]
      ],
      "getPerimeterFunction": [
        "getPerimeterFunction(state: mxCellState): any;",
        [
          "/**",
          " * Returns the perimeter function for the given state.",
          " */"
        ]
      ],
      "getNextPoint": [
        "getNextPoint(edge: mxCellState, opposite: mxCellState, source: boolean): mxPoint;",
        [
          "/**",
          " * Returns the nearest point in the list of absolute points or the center",
          " * of the opposite terminal.",
          " *",
          " * @param edge {@link mxCellState} that represents the edge.",
          " * @param opposite {@link mxCellState} that represents the opposite terminal.",
          " * @param source Boolean indicating if the next point for the source or target",
          " * should be returned.",
          " */"
        ]
      ],
      "getVisibleTerminal": [
        "getVisibleTerminal(edge: mxCell, source: boolean): mxCell;",
        [
          "/**",
          " * Returns the nearest ancestor terminal that is visible. The edge appears",
          " * to be connected to this terminal on the display. The result of this method",
          " * is cached in {@link mxCellState.getVisibleTerminalState}.",
          " *",
          " * @param edge {@link mxCell} whose visible terminal should be returned.",
          " * @param source Boolean that specifies if the source or target terminal",
          " * should be returned.",
          " */"
        ]
      ],
      "updateEdgeBounds": [
        "updateEdgeBounds(state: mxCellState): void;",
        [
          "/**",
          " * Updates the given state using the bounding box of t",
          " * he absolute points.",
          " * Also updates {@link mxCellState.terminalDistance}, {@link mxCellState.length} and",
          " * {@link mxCellState.segments}.",
          " *",
          " * @param state {@link mxCellState} whose bounds should be updated.",
          " */"
        ]
      ],
      "getPoint": [
        "getPoint(state: mxCellState, geometry: mxGeometry): mxPoint;",
        [
          "/**",
          " * Returns the absolute point on the edge for the given relative",
          " * {@link mxGeometry} as an {@link mxPoint}. The edge is represented by the given",
          " * {@link mxCellState}.",
          " *",
          " * @param state {@link mxCellState} that represents the state of the parent edge.",
          " * @param geometry {@link mxGeometry} that represents the relative location.",
          " */"
        ]
      ],
      "getRelativePoint": [
        "getRelativePoint(edgeState: mxCellState, x: number, y: number): mxPoint;",
        [
          "/**",
          " * Gets the relative point that describes the given, absolute label",
          " * position for the given edge state.",
          " *",
          " * @param state {@link mxCellState} that represents the state of the parent edge.",
          " * @param x Specifies the x-coordinate of the absolute label location.",
          " * @param y Specifies the y-coordinate of the absolute label location.",
          " */"
        ]
      ],
      "updateEdgeLabelOffset": [
        "updateEdgeLabelOffset(state: mxCellState): void;",
        [
          "/**",
          " * Updates {@link mxCellState.absoluteOffset} for the given state. The absolute",
          " * offset is normally used for the position of the edge label. Is is",
          " * calculated from the geometry as an absolute offset from the center",
          " * between the two endpoints if the geometry is absolute, or as the",
          " * relative distance between the center along the line and the absolute",
          " * orthogonal distance if the geometry is relative.",
          " *",
          " * @param state {@link mxCellState} whose absolute offset should be updated.",
          " */"
        ]
      ],
      "getState": [
        "getState(cell: mxCell, create?: boolean): mxCellState;",
        [
          "/**",
          " * Returns the {@link mxCellState} for the given cell. If create is true, then",
          " * the state is created if it does not yet exist.",
          " *",
          " * @param cell {@link mxCell} for which the {@link mxCellState} should be returned.",
          " * @param create Optional boolean indicating if a new state should be created",
          " * if it does not yet exist. Default is false.",
          " */"
        ]
      ],
      "isRendering": [
        "isRendering(): boolean;",
        [
          "/**",
          " * Returns {@link rendering}.",
          " */"
        ]
      ],
      "setRendering": [
        "setRendering(value: boolean): void;",
        [
          "/**",
          " * Sets {@link rendering}.",
          " */"
        ]
      ],
      "isAllowEval": [
        "isAllowEval(): boolean;",
        [
          "/**",
          " * Returns {@link allowEval}.",
          " */"
        ]
      ],
      "setAllowEval": [
        "setAllowEval(value: boolean): void;",
        [
          "/**",
          " * Sets {@link allowEval}.",
          " */"
        ]
      ],
      "getStates": [
        "getStates(): mxDictionary<mxCellState>;",
        [
          "/**",
          " * Returns {@link states}.",
          " */"
        ]
      ],
      "setStates": [
        "setStates(value: mxDictionary<mxCellState>): void;",
        [
          "/**",
          " * Sets {@link states}.",
          " */"
        ]
      ],
      "getCellStates": [
        "getCellStates(cells: mxCell[]): mxCellState[];",
        [
          "/**",
          " * Returns the {@link mxCellStates} for the given array of {@link mxCell}. The array",
          " * contains all states that are not null, that is, the returned array may",
          " * have less elements than the given array. If no argument is given, then",
          " * this returns {@link states}.",
          " */"
        ]
      ],
      "removeState": [
        "removeState(cell: mxCell): mxCellState;",
        [
          "/**",
          " * Removes and returns the {@link mxCellState} for the given cell.",
          " *",
          " * @param cell {@link mxCell} for which the {@link mxCellState} should be removed.",
          " */"
        ]
      ],
      "createState": [
        "createState(cell: mxCell): mxCellState;",
        [
          "/**",
          " * Creates and returns an {@link mxCellState} for the given cell and initializes",
          " * it using {@link mxCellRenderer.initialize}.",
          " *",
          " * @param cell {@link mxCell} for which a new {@link mxCellState} should be created.",
          " */"
        ]
      ],
      "getCanvas": [
        "getCanvas(): SVGElement;",
        [
          "/**",
          " * Returns the DOM node that contains the background-, draw- and",
          " * overlay- and decoratorpanes.",
          " */"
        ]
      ],
      "getBackgroundPane": [
        "getBackgroundPane(): Element;",
        [
          "/**",
          " * Returns the DOM node that represents the background layer.",
          " */"
        ]
      ],
      "getDrawPane": [
        "getDrawPane(): Element;",
        [
          "/**",
          " * Returns the DOM node that represents the main drawing layer.",
          " */"
        ]
      ],
      "getOverlayPane": [
        "getOverlayPane(): Element;",
        [
          "/**",
          " * Returns the DOM node that represents the layer above the drawing layer.",
          " */"
        ]
      ],
      "getDecoratorPane": [
        "getDecoratorPane(): Element;",
        [
          "/**",
          " * Returns the DOM node that represents the topmost drawing layer.",
          " */"
        ]
      ],
      "isContainerEvent": [
        "isContainerEvent(evt: Event): boolean;",
        [
          "/**",
          " * Returns true if the event origin is one of the drawing panes or",
          " * containers of the view.",
          " */"
        ]
      ],
      "isScrollEvent": [
        "isScrollEvent(evt: Event): boolean;",
        [
          "/**",
          " * Returns true if the event origin is one of the scrollbars of the",
          " * container in IE. Such events are ignored.",
          " */"
        ]
      ],
      "init": [
        "init(): void;",
        [
          "/**",
          " * Initializes the graph event dispatch loop for the specified container",
          " * and invokes {@link create} to create the required DOM nodes for the display.",
          " */"
        ]
      ],
      "installListeners": [
        "installListeners(): void;",
        [
          "/**",
          " * Installs the required listeners in the container.",
          " */"
        ]
      ],
      "createHtml": [
        "createHtml(): void;",
        [
          "/**",
          " * Creates the DOM nodes for the HTML display.",
          " */"
        ]
      ],
      "updateHtmlCanvasSize": [
        "updateHtmlCanvasSize(width: number, height: number): void;",
        [
          "/**",
          " * Updates the size of the HTML canvas.",
          " */"
        ]
      ],
      "createHtmlPane": [
        "createHtmlPane(width: number, height: number): Element;",
        [
          "/**",
          " * Creates and returns a drawing pane in HTML (DIV).",
          " */"
        ]
      ],
      "createVml": [
        "createVml(): Element;",
        [
          "/**",
          " * Creates the DOM nodes for the VML display.",
          " */"
        ]
      ],
      "createVmlPane": [
        "createVmlPane(width: number, height: number): Element;",
        [
          "/**",
          " * Creates a drawing pane in VML (group).",
          " */"
        ]
      ],
      "createSvg": [
        "createSvg(): Element;",
        [
          "/**",
          " * Creates and returns the DOM nodes for the SVG display.",
          " */"
        ]
      ],
      "updateContainerStyle": [
        "updateContainerStyle(container: Element): void;",
        [
          "/**",
          " * Updates the style of the container after installing the SVG DOM elements.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Destroys the view and all its resources.",
          " */"
        ]
      ]
    }
  ],
  "mxCurrentRootChange": [
    [
      "/**",
      " * Class: mxCurrentRootChange",
      " *",
      " * Action to change the current root in a view.",
      " */"
    ],
    {
      "constructor": [
        "constructor(view: mxGraphView, root: mxCell);",
        [
          "/**",
          " * @constructor mxCurrentRootChange",
          " *",
          " * Constructs a change of the current root in the given view.",
          " */"
        ]
      ],
      "execute": [
        "execute(): void;",
        [
          "/**",
          " * Changes the current root of the view.",
          " */"
        ]
      ]
    }
  ],
  "mxGraph": [
    [
      "/**",
      " * Extends {@link mxEventSource} to implement a graph component for",
      " * the browser. This is the main class of the package. To activate",
      " * panning and connections use {@link setPanning} and {@link setConnectable}.",
      " * For rubberband selection you must create a new instance of",
      " * {@link mxRubberband}. The following listeners are added to",
      " * {@link mouseListeners} by default:",
      " *",
      " * - tooltipHandler: {@link mxTooltipHandler} that displays tooltips",
      " * - panningHandler: {@link mxPanningHandler} for panning and popup menus",
      " * - connectionHandler: {@link mxConnectionHandler} for creating connections",
      " * - graphHandler: {@link mxGraphHandler} for moving and cloning cells",
      " *",
      " * These listeners will be called in the above order if they are enabled.",
      " * @class mxGraph",
      " * @extends {mxEventSource}",
      " */"
    ],
    {
      "constructor": [
        "constructor(container: HTMLElement, model?: mxGraphModel, renderHint?: string, stylesheet?: mxStylesheet);",
        [
          "/**",
          " * @constructor",
          " *",
          " * Constructs a new mxGraph in the specified container. Model is an optional",
          " * mxGraphModel. If no model is provided, a new mxGraphModel instance is",
          " * used as the model. The container must have a valid owner document prior",
          " * to calling this function in Internet Explorer. RenderHint is a string to",
          " * affect the display performance and rendering in IE, but not in SVG-based",
          " * browsers. The parameter is mapped to {@link dialect}, which may",
          " * be one of {@link mxConstants.DIALECT_SVG} for SVG-based browsers,",
          " * {@link mxConstants.DIALECT_STRICTHTML} for fastest display mode,",
          " * {@link mxConstants.DIALECT_PREFERHTML} for faster display mode,",
          " * {@link mxConstants.DIALECT_MIXEDHTML} for fast and {@link mxConstants.DIALECT_VML}",
          " * for exact display mode (slowest). The dialects are defined in mxConstants.",
          " * The default values are DIALECT_SVG for SVG-based browsers and",
          " * DIALECT_MIXED for IE.",
          " *",
          " * The possible values for the renderingHint parameter are explained below:",
          " *",
          " * - fast - The parameter is based on the fact that the display performance is",
          " * highly improved in IE if the VML is not contained within a VML group",
          " * element. The lack of a group element only slightly affects the display while",
          " * panning, but improves the performance by almost a factor of 2, while keeping",
          " * the display sufficiently accurate. This also allows to render certain shapes as HTML",
          " * if the display accuracy is not affected, which is implemented by",
          " * {@link mxShape.isMixedModeHtml}. This is the default setting and is mapped to",
          " * DIALECT_MIXEDHTML.",
          " * - faster - Same as fast, but more expensive shapes are avoided. This is",
          " * controlled by {@link mxShape.preferModeHtml}. The default implementation will",
          " * avoid gradients and rounded rectangles, but more significant shapes, such",
          " * as rhombus, ellipse, actor and cylinder will be rendered accurately. This",
          " * setting is mapped to DIALECT_PREFERHTML.",
          " * - fastest - Almost anything will be rendered in Html. This allows for",
          " * rectangles, labels and images. This setting is mapped to",
          " * DIALECT_STRICTHTML.",
          " * - exact - If accurate panning is required and if the diagram is small (up",
          " * to 100 cells), then this value should be used. In this mode, a group is",
          " * created that contains the VML. This allows for accurate panning and is",
          " * mapped to DIALECT_VML.",
          " *",
          " * ### Examples",
          " *",
          " * To create a graph inside a DOM node with an id of graph:",
          " *",
          " * ```javascript",
          " * var container = document.getElementById('graph');",
          " * var graph = new mxGraph(container);",
          " * ```",
          " *",
          " * ### Parameters",
          " *",
          " * @param container Optional DOM node that acts as a container for the graph.",
          " * If this is null then the container can be initialized later using",
          " * {@link init}.",
          " * @param model Optional {@link mxGraphModel} that constitutes the graph data.",
          " * @param renderHint Optional string that specifies the display accuracy and",
          " * performance. Default is mxConstants.DIALECT_MIXEDHTML (for IE).",
          " * @param stylesheet Optional {@link mxStylesheet} to be used in the graph.",
          " */"
        ]
      ],
      "container": [
        "container: HTMLElement;",
        [
          "/**",
          " * @constructor",
          " *",
          " * Constructs a new mxGraph in the specified container. Model is an optional",
          " * mxGraphModel. If no model is provided, a new mxGraphModel instance is",
          " * used as the model. The container must have a valid owner document prior",
          " * to calling this function in Internet Explorer. RenderHint is a string to",
          " * affect the display performance and rendering in IE, but not in SVG-based",
          " * browsers. The parameter is mapped to {@link dialect}, which may",
          " * be one of {@link mxConstants.DIALECT_SVG} for SVG-based browsers,",
          " * {@link mxConstants.DIALECT_STRICTHTML} for fastest display mode,",
          " * {@link mxConstants.DIALECT_PREFERHTML} for faster display mode,",
          " * {@link mxConstants.DIALECT_MIXEDHTML} for fast and {@link mxConstants.DIALECT_VML}",
          " * for exact display mode (slowest). The dialects are defined in mxConstants.",
          " * The default values are DIALECT_SVG for SVG-based browsers and",
          " * DIALECT_MIXED for IE.",
          " *",
          " * The possible values for the renderingHint parameter are explained below:",
          " *",
          " * - fast - The parameter is based on the fact that the display performance is",
          " * highly improved in IE if the VML is not contained within a VML group",
          " * element. The lack of a group element only slightly affects the display while",
          " * panning, but improves the performance by almost a factor of 2, while keeping",
          " * the display sufficiently accurate. This also allows to render certain shapes as HTML",
          " * if the display accuracy is not affected, which is implemented by",
          " * {@link mxShape.isMixedModeHtml}. This is the default setting and is mapped to",
          " * DIALECT_MIXEDHTML.",
          " * - faster - Same as fast, but more expensive shapes are avoided. This is",
          " * controlled by {@link mxShape.preferModeHtml}. The default implementation will",
          " * avoid gradients and rounded rectangles, but more significant shapes, such",
          " * as rhombus, ellipse, actor and cylinder will be rendered accurately. This",
          " * setting is mapped to DIALECT_PREFERHTML.",
          " * - fastest - Almost anything will be rendered in Html. This allows for",
          " * rectangles, labels and images. This setting is mapped to",
          " * DIALECT_STRICTHTML.",
          " * - exact - If accurate panning is required and if the diagram is small (up",
          " * to 100 cells), then this value should be used. In this mode, a group is",
          " * created that contains the VML. This allows for accurate panning and is",
          " * mapped to DIALECT_VML.",
          " *",
          " * ### Examples",
          " *",
          " * To create a graph inside a DOM node with an id of graph:",
          " *",
          " * ```javascript",
          " * var container = document.getElementById('graph');",
          " * var graph = new mxGraph(container);",
          " * ```",
          " *",
          " * ### Parameters",
          " *",
          " * @param container Optional DOM node that acts as a container for the graph.",
          " * If this is null then the container can be initialized later using",
          " * {@link init}.",
          " * @param model Optional {@link mxGraphModel} that constitutes the graph data.",
          " * @param renderHint Optional string that specifies the display accuracy and",
          " * performance. Default is mxConstants.DIALECT_MIXEDHTML (for IE).",
          " * @param stylesheet Optional {@link mxStylesheet} to be used in the graph.",
          " */"
        ]
      ],
      "mouseListeners": [
        "mouseListeners: any[];",
        [
          "/**",
          " * Holds the mouse event listeners. See {@link fireMouseEvent}.",
          " */"
        ]
      ],
      "isMouseDown": [
        "isMouseDown: boolean;",
        [
          "/**",
          " * Holds the state of the mouse button.",
          " */"
        ]
      ],
      "model": [
        "model: mxGraphModel;",
        [
          "/**",
          " * Holds the {@link mxGraphModel} that contains the cells to be displayed.",
          " */"
        ]
      ],
      "view": [
        "view: mxGraphView;",
        [
          "/**",
          " * Holds the {@link mxGraphView} that caches the {@link mxCellState}s for the cells.",
          " */"
        ]
      ],
      "stylesheet": [
        "stylesheet: mxStylesheet;",
        [
          "/**",
          " * Holds the {@link mxStylesheet} that defines the appearance of the cells.",
          " *",
          " * Use the following code to read a stylesheet into an existing graph.",
          " *",
          " * @example",
          " * ```javascript",
          " * var req = mxUtils.load('stylesheet.xml');",
          " * var root = req.getDocumentElement();",
          " * var dec = new mxCodec(root.ownerDocument);",
          " * dec.decode(root, graph.stylesheet);",
          " * ```",
          " */"
        ]
      ],
      "selectionModel": [
        "selectionModel: mxGraphSelectionModel;",
        [
          "/**",
          " * Holds the {@link mxGraphSelectionModel} that models the current selection.",
          " */"
        ]
      ],
      "cellEditor": [
        "cellEditor: mxCellEditor;",
        [
          "/**",
          " * Holds the {@link mxCellEditor} that is used as the in-place editing.",
          " */"
        ]
      ],
      "cellRenderer": [
        "cellRenderer: mxCellRenderer;",
        [
          "/**",
          " * Holds the {@link mxCellRenderer} for rendering the cells in the graph.",
          " */"
        ]
      ],
      "multiplicities": [
        "multiplicities: mxMultiplicity[];",
        [
          "/**",
          " * An array of {@link mxMultiplicity} describing the allowed",
          " * connections in a graph.",
          " */"
        ]
      ],
      "renderHint": [
        "renderHint: any;",
        [
          "/**",
          " * RenderHint as it was passed to the constructor.",
          " */"
        ]
      ],
      "dialect": [
        "dialect: mxDialectConstants;",
        [
          "/**",
          " * Dialect to be used for drawing the graph. Possible values are all",
          " * constants in {@link mxConstants} with a DIALECT-prefix.",
          " */"
        ]
      ],
      "gridSize": [
        "gridSize: number;",
        [
          "/**",
          " * Specifies the grid size.",
          " * @default 10",
          " */"
        ]
      ],
      "gridEnabled": [
        "gridEnabled: boolean;",
        [
          "/**",
          " * Specifies if the grid is enabled. This is used in {@link snap}.",
          " * @default true",
          " */"
        ]
      ],
      "portsEnabled": [
        "portsEnabled: boolean;",
        [
          "/**",
          " * Specifies if ports are enabled. This is used in {@link cellConnected} to update",
          " * the respective style.",
          " * @default true",
          " */"
        ]
      ],
      "nativeDblClickEnabled": [
        "nativeDblClickEnabled: boolean;",
        [
          "/**",
          " * Specifies if native double click events should be detected.",
          " * @default true",
          " */"
        ]
      ],
      "doubleTapEnabled": [
        "doubleTapEnabled: boolean;",
        [
          "/**",
          " * Specifies if double taps on touch-based devices should be handled as a",
          " * double click.",
          " * @default true",
          " */"
        ]
      ],
      "doubleTapTimeout": [
        "doubleTapTimeout: number;",
        [
          "/**",
          " * Specifies the timeout in milliseconds for double taps and non-native double clicks.",
          " * @default 500",
          " */"
        ]
      ],
      "doubleTapTolerance": [
        "doubleTapTolerance: number;",
        [
          "/**",
          " * Specifies the tolerance in pixels for double taps and double clicks in quirks mode.",
          " * @default 25",
          " */"
        ]
      ],
      "lastTouchY": [
        "lastTouchY: number;",
        [
          "/**",
          " * Holds the x-coordinate of the last touch event for double tap detection.",
          " */"
        ]
      ],
      "lastTouchTime": [
        "lastTouchTime: number;",
        [
          "/**",
          " * Holds the time of the last touch event for double click detection.",
          " */"
        ]
      ],
      "tapAndHoldEnabled": [
        "tapAndHoldEnabled: boolean;",
        [
          "/**",
          " * Specifies if tap and hold should be used for starting connections on touch-based",
          " * devices.",
          " * @default true",
          " */"
        ]
      ],
      "tapAndHoldDelay": [
        "tapAndHoldDelay: number;",
        [
          "/**",
          " * Specifies the time in milliseconds for a tap and hold.",
          " * @default 500",
          " */"
        ]
      ],
      "tapAndHoldInProgress": [
        "tapAndHoldInProgress: boolean;",
        [
          "/**",
          " * `True` if the timer for tap and hold events is running.",
          " */"
        ]
      ],
      "tapAndHoldValid": [
        "tapAndHoldValid: boolean;",
        [
          "/**",
          " * `True` as long as the timer is running and the touch events",
          " * stay within the given {@link tapAndHoldTolerance}.",
          " */"
        ]
      ],
      "initialTouchX": [
        "initialTouchX: number;",
        [
          "/**",
          " * Holds the x-coordinate of the initial touch event for tap and hold.",
          " */"
        ]
      ],
      "initialTouchY": [
        "initialTouchY: number;",
        [
          "/**",
          " * Holds the y-coordinate of the initial touch event for tap and hold.",
          " */"
        ]
      ],
      "tolerance": [
        "tolerance: number;",
        [
          "/**",
          " * Tolerance in pixels for a move to be handled as a single click.",
          " * @default 4",
          " */"
        ]
      ],
      "defaultOverlap": [
        "defaultOverlap: number;",
        [
          "/**",
          " * Value returned by {@link getOverlap} if {@link isAllowOverlapParent} returns",
          " * `true` for the given cell. {@link getOverlap} is used in {@link constrainChild} if",
          " * {@link isConstrainChild} returns `true`. The value specifies the",
          " * portion of the child which is allowed to overlap the parent.",
          " */"
        ]
      ],
      "defaultParent": [
        "defaultParent: mxCell;",
        [
          "/**",
          " * Specifies the default parent to be used to insert new cells.",
          " * This is used in {@link getDefaultParent}.",
          " * @default null",
          " */"
        ]
      ],
      "alternateEdgeStyle": [
        "alternateEdgeStyle: string;",
        [
          "/**",
          " * Specifies the alternate edge style to be used if the main control point",
          " * on an edge is being double clicked.",
          " * @default null",
          " */"
        ]
      ],
      "backgroundImage": [
        "backgroundImage: mxImage;",
        [
          "/**",
          " * Specifies the {@link mxImage} to be returned by {@link getBackgroundImage}.",
          " * @default null",
          " *",
          " * @example",
          " * ```javascript",
          " * var img = new mxImage('http://www.example.com/maps/examplemap.jpg', 1024, 768);",
          " * graph.setBackgroundImage(img);",
          " * graph.view.validate();",
          " * ```",
          " */"
        ]
      ],
      "pageVisible": [
        "pageVisible: boolean;",
        [
          "/**",
          " * Specifies if the background page should be visible.",
          " * Not yet implemented.",
          " * @default false",
          " */"
        ]
      ],
      "pageBreaksVisible": [
        "pageBreaksVisible: boolean;",
        [
          "/**",
          " * Specifies if a dashed line should be drawn between multiple pages.",
          " * If you change this value while a graph is being displayed then you",
          " * should call {@link sizeDidChange} to force an update of the display.",
          " * @default false",
          " */"
        ]
      ],
      "pageBreakColor": [
        "pageBreakColor: string;",
        [
          "/**",
          " * Specifies the color for page breaks.",
          " * @default gray",
          " */"
        ]
      ],
      "pageBreakDashed": [
        "pageBreakDashed: boolean;",
        [
          "/**",
          " * Specifies the page breaks should be dashed.",
          " * @default true",
          " */"
        ]
      ],
      "minPageBreakDist": [
        "minPageBreakDist: number;",
        [
          "/**",
          " * Specifies the minimum distance in pixels for page breaks to be visible.",
          " * @default 20",
          " */"
        ]
      ],
      "preferPageSize": [
        "preferPageSize: boolean;",
        [
          "/**",
          " * Specifies if the graph size should be rounded to the next page number in",
          " * {@link sizeDidChange}. This is only used if the graph container has scrollbars.",
          " * @default false",
          " */"
        ]
      ],
      "pageFormat": [
        "pageFormat: mxRectangle;",
        [
          "/**",
          " * Specifies the page format for the background page.",
          " * This is used as the default in {@link mxPrintPreview} and for painting the background page",
          " * if {@link pageVisible} is `true` and the page breaks if {@link pageBreaksVisible} is `true`.",
          " * @default {@link mxConstants.PAGE_FORMAT_A4_PORTRAIT}",
          " */"
        ]
      ],
      "pageScale": [
        "pageScale: number;",
        [
          "/**",
          " * Specifies the scale of the background page.",
          " * Not yet implemented.",
          " * @default 1.5",
          " */"
        ]
      ],
      "enabled": [
        "enabled: boolean;",
        [
          "/**",
          " * Specifies the return value for {@link isEnabled}.",
          " * @default true",
          " */"
        ]
      ],
      "escapeEnabled": [
        "escapeEnabled: boolean;",
        [
          "/**",
          " * Specifies if {@link mxKeyHandler} should invoke {@link escape} when the escape key",
          " * is pressed.",
          " * @default true",
          " */"
        ]
      ],
      "invokesStopCellEditing": [
        "invokesStopCellEditing: boolean;",
        [
          "/**",
          " * If `true`, when editing is to be stopped by way of selection changing,",
          " * data in diagram changing or other means stopCellEditing is invoked, and",
          " * changes are saved. This is implemented in a focus handler in",
          " * {@link mxCellEditor}.",
          " * @default true",
          " */"
        ]
      ],
      "enterStopsCellEditing": [
        "enterStopsCellEditing: boolean;",
        [
          "/**",
          " * If `true`, pressing the enter key without pressing control or shift will stop",
          " * editing and accept the new value. This is used in {@link mxCellEditor} to stop",
          " * cell editing. Note: You can always use F2 and escape to stop editing.",
          " * @default false",
          " */"
        ]
      ],
      "useScrollbarsForPanning": [
        "useScrollbarsForPanning: boolean;",
        [
          "/**",
          " * Specifies if scrollbars should be used for panning in {@link panGraph} if",
          " * any scrollbars are available. If scrollbars are enabled in CSS, but no",
          " * scrollbars appear because the graph is smaller than the container size,",
          " * then no panning occurs if this is `true`.",
          " * @default true",
          " */"
        ]
      ],
      "exportEnabled": [
        "exportEnabled: boolean;",
        [
          "/**",
          " * Specifies the return value for {@link canExportCell}.",
          " * @default true",
          " */"
        ]
      ],
      "importEnabled": [
        "importEnabled: boolean;",
        [
          "/**",
          " * Specifies the return value for {@link canImportCell}.",
          " * @default true",
          " */"
        ]
      ],
      "cellsLocked": [
        "cellsLocked: boolean;",
        [
          "/**",
          " * Specifies the return value for {@link isCellLocked}.",
          " * @default false",
          " */"
        ]
      ],
      "cellsCloneable": [
        "cellsCloneable: boolean;",
        [
          "/**",
          " * Specifies the return value for {@link isCellCloneable}.",
          " * @default true",
          " */"
        ]
      ],
      "foldingEnabled": [
        "foldingEnabled: boolean;",
        [
          "/**",
          " * Specifies if folding (collapse and expand via an image icon in the graph",
          " * should be enabled).",
          " * @default true",
          " */"
        ]
      ],
      "cellsEditable": [
        "cellsEditable: boolean;",
        [
          "/**",
          " * Specifies the return value for {@link isCellEditable}.",
          " * @default true",
          " */"
        ]
      ],
      "cellsDeletable": [
        "cellsDeletable: boolean;",
        [
          "/**",
          " * Specifies the return value for {@link isCellDeletable}.",
          " * @default true",
          " */"
        ]
      ],
      "cellsMovable": [
        "cellsMovable: boolean;",
        [
          "/**",
          " * Specifies the return value for {@link isCellMovable}.",
          " * @default true",
          " */"
        ]
      ],
      "edgeLabelsMovable": [
        "edgeLabelsMovable: boolean;",
        [
          "/**",
          " * Specifies the return value for edges in {@link isLabelMovable}.",
          " * @default true",
          " */"
        ]
      ],
      "vertexLabelsMovable": [
        "vertexLabelsMovable: boolean;",
        [
          "/**",
          " * Specifies the return value for vertices in {@link isLabelMovable}.",
          " * @default false",
          " */"
        ]
      ],
      "dropEnabled": [
        "dropEnabled: boolean;",
        [
          "/**",
          " * Specifies the return value for {@link isDropEnabled}.",
          " * @default false",
          " */"
        ]
      ],
      "splitEnabled": [
        "splitEnabled: boolean;",
        [
          "/**",
          " * Specifies if dropping onto edges should be enabled. This is ignored if",
          " * {@link dropEnabled} is `false`. If enabled, it will call {@link splitEdge} to carry",
          " * out the drop operation.",
          " * @default true",
          " */"
        ]
      ],
      "cellsResizable": [
        "cellsResizable: boolean;",
        [
          "/**",
          " * Specifies the return value for {@link isCellsResizable}.",
          " * @default true",
          " */"
        ]
      ],
      "cellsBendable": [
        "cellsBendable: boolean;",
        [
          "/**",
          " * Specifies the return value for {@link isCellsBendable}.",
          " * @default true",
          " */"
        ]
      ],
      "cellsSelectable": [
        "cellsSelectable: boolean;",
        [
          "/**",
          " * Specifies the return value for {@link isCellsSelectable}.",
          " * @default true",
          " */"
        ]
      ],
      "cellsDisconnectable": [
        "cellsDisconnectable: boolean;",
        [
          "/**",
          " * Specifies the return value for {@link isCellsDisconnectable}.",
          " * @default true",
          " */"
        ]
      ],
      "autoSizeCells": [
        "autoSizeCells: boolean;",
        [
          "/**",
          " * Specifies if the graph should automatically update the cell size after an",
          " * edit. This is used in {@link isAutoSizeCell}.",
          " * @default false",
          " */"
        ]
      ],
      "autoSizeCellsOnAdd": [
        "autoSizeCellsOnAdd: boolean;",
        [
          "/**",
          " * Specifies if autoSize style should be applied when cells are added.",
          " * @default false",
          " */"
        ]
      ],
      "autoScroll": [
        "autoScroll: boolean;",
        [
          "/**",
          " * Specifies if the graph should automatically scroll if the mouse goes near",
          " * the container edge while dragging. This is only taken into account if the",
          " * container has scrollbars.",
          " *",
          " * If you need this to work without scrollbars then set {@link ignoreScrollbars} to",
          " * true. Please consult the {@link ignoreScrollbars} for details. In general, with",
          " * no scrollbars, the use of {@link allowAutoPanning} is recommended.",
          " * @default true",
          " */"
        ]
      ],
      "ignoreScrollbars": [
        "ignoreScrollbars: boolean;",
        [
          "/**",
          " * Specifies if the graph should automatically scroll regardless of the",
          " * scrollbars. This will scroll the container using positive values for",
          " * scroll positions (ie usually only rightwards and downwards). To avoid",
          " * possible conflicts with panning, set {@link translateToScrollPosition} to `true`.",
          " */"
        ]
      ],
      "translateToScrollPosition": [
        "translateToScrollPosition: boolean;",
        [
          "/**",
          " * Specifies if the graph should automatically convert the current scroll",
          " * position to a translate in the graph view when a mouseUp event is received.",
          " * This can be used to avoid conflicts when using {@link autoScroll} and",
          " * {@link ignoreScrollbars} with no scrollbars in the container.",
          " */"
        ]
      ],
      "timerAutoScroll": [
        "timerAutoScroll: boolean;",
        [
          "/**",
          " * Specifies if autoscrolling should be carried out via mxPanningManager even",
          " * if the container has scrollbars. This disables {@link scrollPointToVisible} and",
          " * uses {@link mxPanningManager} instead. If this is true then {@link autoExtend} is",
          " * disabled. It should only be used with a scroll buffer or when scollbars",
          " * are visible and scrollable in all directions.",
          " * @default false",
          " */"
        ]
      ],
      "allowAutoPanning": [
        "allowAutoPanning: boolean;",
        [
          "/**",
          " * Specifies if panning via {@link panGraph} should be allowed to implement autoscroll",
          " * if no scrollbars are available in {@link scrollPointToVisible}. To enable panning",
          " * inside the container, near the edge, set {@link mxPanningManager.border} to a",
          " * positive value.",
          " * @default false",
          " */"
        ]
      ],
      "autoExtend": [
        "autoExtend: boolean;",
        [
          "/**",
          " * Specifies if the size of the graph should be automatically extended if the",
          " * mouse goes near the container edge while dragging. This is only taken into",
          " * account if the container has scrollbars. See {@link autoScroll}.",
          " * @default true",
          " */"
        ]
      ],
      "maximumGraphBounds": [
        "maximumGraphBounds: mxRectangle;",
        [
          "/**",
          " * {@link mxRectangle} that specifies the area in which all cells in the diagram",
          " * should be placed. Uses in {@link getMaximumGraphBounds}. Use a width or height of",
          " * `0` if you only want to give a upper, left corner.",
          " */"
        ]
      ],
      "minimumGraphSize": [
        "minimumGraphSize: mxRectangle;",
        [
          "/**",
          " * {@link mxRectangle} that specifies the minimum size of the graph. This is ignored",
          " * if the graph container has no scrollbars.",
          " * @default null",
          " */"
        ]
      ],
      "minimumContainerSize": [
        "minimumContainerSize: mxRectangle;",
        [
          "/**",
          " * {@link mxRectangle} that specifies the minimum size of the {@link container} if",
          " * {@link resizeContainer} is `true`.",
          " */"
        ]
      ],
      "maximumContainerSize": [
        "maximumContainerSize: mxRectangle;",
        [
          "/**",
          " * {@link mxRectangle} that specifies the maximum size of the container if",
          " * {@link resizeContainer} is `true`.",
          " */"
        ]
      ],
      "resizeContainer": [
        "resizeContainer: boolean;",
        [
          "/**",
          " * Specifies if the container should be resized to the graph size when",
          " * the graph size has changed.",
          " * @default false",
          " */"
        ]
      ],
      "border": [
        "border: number;",
        [
          "/**",
          " * Border to be added to the bottom and right side when the container is",
          " * being resized after the graph has been changed.",
          " * @default 0",
          " */"
        ]
      ],
      "keepEdgesInForeground": [
        "keepEdgesInForeground: boolean;",
        [
          "/**",
          " * Specifies if edges should appear in the foreground regardless of their order",
          " * in the model. If {@link keepEdgesInForeground} and {@link keepEdgesInBackground} are",
          " * both `true` then the normal order is applied.",
          " * @default false",
          " */"
        ]
      ],
      "keepEdgesInBackground": [
        "keepEdgesInBackground: boolean;",
        [
          "/**",
          " * Specifies if edges should appear in the background regardless of their order",
          " * in the model. If {@link keepEdgesInForeground} and {@link keepEdgesInBackground} are",
          " * both `true` then the normal order is applied.",
          " * @default false",
          " */"
        ]
      ],
      "allowNegativeCoordinates": [
        "allowNegativeCoordinates: boolean;",
        [
          "/**",
          " * Specifies if negative coordinates for vertices are allowed.",
          " * @default true",
          " */"
        ]
      ],
      "constrainChildren": [
        "constrainChildren: boolean;",
        [
          "/**",
          " * Specifies if a child should be constrained inside the parent bounds after a",
          " * move or resize of the child.",
          " * @default true",
          " */"
        ]
      ],
      "constrainRelativeChildren": [
        "constrainRelativeChildren: boolean;",
        [
          "/**",
          " * Specifies if child cells with relative geometries should be constrained",
          " * inside the parent bounds, if {@link constrainChildren} is `true`, and/or the",
          " * {@link maximumGraphBounds}.",
          " * @default false",
          " */"
        ]
      ],
      "extendParents": [
        "extendParents: boolean;",
        [
          "/**",
          " * Specifies if a parent should contain the child bounds after a resize of",
          " * the child. This has precedence over {@link constrainChildren}.",
          " * @default true",
          " */"
        ]
      ],
      "extendParentsOnAdd": [
        "extendParentsOnAdd: boolean;",
        [
          "/**",
          " * Specifies if parents should be extended according to the {@link extendParents}",
          " * switch if cells are added.",
          " * @default true",
          " */"
        ]
      ],
      "extendParentsOnMove": [
        "extendParentsOnMove: boolean;",
        [
          "/**",
          " * Specifies if parents should be extended according to the {@link extendParents}",
          " * switch if cells are added.",
          " * @default false (for backwards compatibility)",
          " */"
        ]
      ],
      "recursiveResize": [
        "recursiveResize: boolean;",
        [
          "/**",
          " * Specifies the return value for {@link isRecursiveResize}.",
          " * @default false (for backwards compatibility)",
          " */"
        ]
      ],
      "collapseToPreferredSize": [
        "collapseToPreferredSize: boolean;",
        [
          "/**",
          " * Specifies if the cell size should be changed to the preferred size when",
          " * a cell is first collapsed.",
          " * @default true",
          " */"
        ]
      ],
      "zoomFactor": [
        "zoomFactor: number;",
        [
          "/**",
          " * Specifies the factor used for {@link zoomIn} and {@link zoomOut}.",
          " * @default 1.2 (120%)",
          " */"
        ]
      ],
      "keepSelectionVisibleOnZoom": [
        "keepSelectionVisibleOnZoom: boolean;",
        [
          "/**",
          " * Specifies if the viewport should automatically contain the selection cells after a zoom operation.",
          " * @default false",
          " */"
        ]
      ],
      "centerZoom": [
        "centerZoom: boolean;",
        [
          "/**",
          " * Specifies if the zoom operations should go into the center of the actual",
          " * diagram rather than going from top, left.",
          " * @default true",
          " */"
        ]
      ],
      "resetViewOnRootChange": [
        "resetViewOnRootChange: boolean;",
        [
          "/**",
          " * Specifies if the scale and translate should be reset if the root changes in",
          " * the model.",
          " * @default true",
          " */"
        ]
      ],
      "resetEdgesOnResize": [
        "resetEdgesOnResize: boolean;",
        [
          "/**",
          " * Specifies if edge control points should be reset after the resize of a",
          " * connected cell.",
          " * @default false",
          " */"
        ]
      ],
      "resetEdgesOnMove": [
        "resetEdgesOnMove: boolean;",
        [
          "/**",
          " * Specifies if edge control points should be reset after the move of a",
          " * connected cell.",
          " * @default false",
          " */"
        ]
      ],
      "resetEdgesOnConnect": [
        "resetEdgesOnConnect: boolean;",
        [
          "/**",
          " * Specifies if edge control points should be reset after the the edge has been",
          " * reconnected.",
          " * @default true",
          " */"
        ]
      ],
      "allowLoops": [
        "allowLoops: boolean;",
        [
          "/**",
          " * Specifies if loops (aka self-references) are allowed.",
          " * @default false",
          " */"
        ]
      ],
      "defaultLoopStyle": [
        "defaultLoopStyle: any;",
        [
          "/**",
          " * {@link mxEdgeStyle} to be used for loops. This is a fallback for loops if the",
          " * {@link mxConstants.STYLE_LOOP} is undefined.",
          " * @default {@link mxEdgeStyle.Loop}",
          " */"
        ]
      ],
      "multigraph": [
        "multigraph: boolean;",
        [
          "/**",
          " * Specifies if multiple edges in the same direction between the same pair of",
          " * vertices are allowed.",
          " * @default true",
          " */"
        ]
      ],
      "connectableEdges": [
        "connectableEdges: boolean;",
        [
          "/**",
          " * Specifies if edges are connectable. This overrides the connectable field in edges.",
          " * @default false",
          " */"
        ]
      ],
      "allowDanglingEdges": [
        "allowDanglingEdges: boolean;",
        [
          "/**",
          " * Specifies if edges with disconnected terminals are allowed in the graph.",
          " * @default true",
          " */"
        ]
      ],
      "cloneInvalidEdges": [
        "cloneInvalidEdges: boolean;",
        [
          "/**",
          " * Specifies if edges that are cloned should be validated and only inserted",
          " * if they are valid.",
          " * @default true",
          " */"
        ]
      ],
      "disconnectOnMove": [
        "disconnectOnMove: boolean;",
        [
          "/**",
          " * Specifies if edges should be disconnected from their terminals when they",
          " * are moved.",
          " * @default true",
          " */"
        ]
      ],
      "labelsVisible": [
        "labelsVisible: boolean;",
        [
          "/**",
          " * Specifies if labels should be visible. This is used in {@link getLabel}. Default",
          " * is true.",
          " */"
        ]
      ],
      "htmlLabels": [
        "htmlLabels: boolean;",
        [
          "/**",
          " * Specifies the return value for {@link isHtmlLabel}.",
          " * @default false",
          " */"
        ]
      ],
      "swimlaneSelectionEnabled": [
        "swimlaneSelectionEnabled: boolean;",
        [
          "/**",
          " * Specifies if swimlanes should be selectable via the content if the",
          " * mouse is released.",
          " * @default true",
          " */"
        ]
      ],
      "swimlaneNesting": [
        "swimlaneNesting: boolean;",
        [
          "/**",
          " * Specifies if nesting of swimlanes is allowed.",
          " * @default true",
          " */"
        ]
      ],
      "swimlaneIndicatorColorAttribute": [
        "swimlaneIndicatorColorAttribute: string;",
        [
          "/**",
          " * The attribute used to find the color for the indicator if the indicator",
          " * color is set to 'swimlane'.",
          " * @default {@link 'fillColor'}",
          " */"
        ]
      ],
      "imageBundles": [
        "imageBundles: mxImageBundle[];",
        [
          "/**",
          " * Holds the list of image bundles.",
          " */"
        ]
      ],
      "minFitScale": [
        "minFitScale: number;",
        [
          "/**",
          " * Specifies the minimum scale to be applied in {@link fit}. Set this to `null` to allow any value.",
          " * @default 0.1",
          " */"
        ]
      ],
      "maxFitScale": [
        "maxFitScale: number;",
        [
          "/**",
          " * Specifies the maximum scale to be applied in {@link fit}. Set this to `null` to allow any value.",
          " * @default 8",
          " */"
        ]
      ],
      "panDx": [
        "panDx: number;",
        [
          "/**",
          " * Current horizontal panning value.",
          " * @default 0",
          " */"
        ]
      ],
      "panDy": [
        "panDy: number;",
        [
          "/**",
          " * Current vertical panning value.",
          " * @default 0",
          " */"
        ]
      ],
      "collapsedImage": [
        "collapsedImage: mxImage;",
        [
          "/**",
          " * Specifies the {@link mxImage} to indicate a collapsed state.",
          " * Default value is mxClient.imageBasePath + '/collapsed.gif'",
          " */"
        ]
      ],
      "expandedImage": [
        "expandedImage: mxImage;",
        [
          "/**",
          " * Specifies the {@link mxImage} to indicate a expanded state.",
          " * Default value is mxClient.imageBasePath + '/expanded.gif'",
          " */"
        ]
      ],
      "warningImage": [
        "warningImage: mxImage;",
        [
          "/**",
          " * Specifies the {@link mxImage} for the image to be used to display a warning",
          " * overlay. See {@link setCellWarning}. Default value is mxClient.imageBasePath +",
          " * '/warning'.  The extension for the image depends on the platform. It is",
          " * '.png' on the Mac and '.gif' on all other platforms.",
          " */"
        ]
      ],
      "alreadyConnectedResource": [
        "alreadyConnectedResource: string;",
        [
          "/**",
          " * Specifies the resource key for the error message to be displayed in",
          " * non-multigraphs when two vertices are already connected. If the resource",
          " * for this key does not exist then the value is used as the error message.",
          " * @default 'alreadyConnected'",
          " */"
        ]
      ],
      "containsValidationErrorsResource": [
        "containsValidationErrorsResource: string;",
        [
          "/**",
          " * Specifies the resource key for the warning message to be displayed when",
          " * a collapsed cell contains validation errors. If the resource for this",
          " * key does not exist then the value is used as the warning message.",
          " * @default 'containsValidationErrors'",
          " */"
        ]
      ],
      "collapseExpandResource": [
        "collapseExpandResource: string;",
        [
          "/**",
          " * Specifies the resource key for the tooltip on the collapse/expand icon.",
          " * If the resource for this key does not exist then the value is used as",
          " * the tooltip.",
          " * @default 'collapse-expand'",
          " */"
        ]
      ],
      "tooltipHandler": [
        "tooltipHandler: mxTooltipHandler;",
        [
          "/**",
          " * Specifies the resource key for the tooltip on the collapse/expand icon.",
          " * If the resource for this key does not exist then the value is used as",
          " * the tooltip.",
          " * @default 'collapse-expand'",
          " */"
        ]
      ],
      "selectionCellsHandler": [
        "selectionCellsHandler: mxSelectionCellsHandler;",
        [
          "/**",
          " * Specifies the resource key for the tooltip on the collapse/expand icon.",
          " * If the resource for this key does not exist then the value is used as",
          " * the tooltip.",
          " * @default 'collapse-expand'",
          " */"
        ]
      ],
      "connectionHandler": [
        "connectionHandler: mxConnectionHandler;",
        [
          "/**",
          " * Specifies the resource key for the tooltip on the collapse/expand icon.",
          " * If the resource for this key does not exist then the value is used as",
          " * the tooltip.",
          " * @default 'collapse-expand'",
          " */"
        ]
      ],
      "graphHandler": [
        "graphHandler: mxGraphHandler;",
        [
          "/**",
          " * Specifies the resource key for the tooltip on the collapse/expand icon.",
          " * If the resource for this key does not exist then the value is used as",
          " * the tooltip.",
          " * @default 'collapse-expand'",
          " */"
        ]
      ],
      "panningHandler": [
        "panningHandler: mxPanningHandler;",
        [
          "/**",
          " * Specifies the resource key for the tooltip on the collapse/expand icon.",
          " * If the resource for this key does not exist then the value is used as",
          " * the tooltip.",
          " * @default 'collapse-expand'",
          " */"
        ]
      ],
      "popupMenuHandler": [
        "popupMenuHandler: mxPopupMenuHandler;",
        [
          "/**",
          " * Specifies the resource key for the tooltip on the collapse/expand icon.",
          " * If the resource for this key does not exist then the value is used as",
          " * the tooltip.",
          " * @default 'collapse-expand'",
          " */"
        ]
      ],
      "init": [
        "init(container: HTMLElement): void;",
        [
          "/**",
          " * Initializes the {@link container} and creates the respective datastructures.",
          " *",
          " * @param container DOM node that will contain the graph display.",
          " */"
        ]
      ],
      "createHandlers": [
        "createHandlers(): void;",
        [
          "/**",
          " * Creates the tooltip-, panning-, connection- and graph-handler (in this",
          " * order). This is called in the constructor before {@link init} is called.",
          " */"
        ]
      ],
      "createTooltipHandler": [
        "createTooltipHandler(): mxTooltipHandler;",
        [
          "/**",
          " * Creates and returns a new {@link mxTooltipHandler} to be used in this graph.",
          " */"
        ]
      ],
      "createSelectionCellsHandler": [
        "createSelectionCellsHandler: mxSelectionCellsHandler;",
        [
          "/**",
          " * Creates and returns a new {@link mxTooltipHandler} to be used in this graph.",
          " */"
        ]
      ],
      "createConnectionHandler": [
        "createConnectionHandler(): mxConnectionHandler;",
        [
          "/**",
          " * Creates and returns a new {@link mxConnectionHandler} to be used in this graph.",
          " */"
        ]
      ],
      "createGraphHandler": [
        "createGraphHandler(): mxGraphHandler;",
        [
          "/**",
          " * Creates and returns a new {@link mxGraphHandler} to be used in this graph.",
          " */"
        ]
      ],
      "createPanningHandler": [
        "createPanningHandler(): mxPanningHandler;",
        [
          "/**",
          " * Creates and returns a new {@link mxPanningHandler} to be used in this graph.",
          " */"
        ]
      ],
      "createPopupMenuHandler": [
        "createPopupMenuHandler(): mxPopupMenuHandler;",
        [
          "/**",
          " * Creates and returns a new {@link mxPopupMenuHandler} to be used in this graph.",
          " */"
        ]
      ],
      "createSelectionModel": [
        "createSelectionModel(): mxGraphSelectionModel;",
        [
          "/**",
          " * Creates a new {@link mxGraphSelectionModel} to be used in this graph.",
          " */"
        ]
      ],
      "createStylesheet": [
        "createStylesheet(): mxStylesheet;",
        [
          "/**",
          " * Creates a new {@link mxGraphSelectionModel} to be used in this graph.",
          " */"
        ]
      ],
      "createGraphView": [
        "createGraphView(): mxGraphView;",
        [
          "/**",
          " * Creates a new {@link mxGraphView} to be used in this graph.",
          " */"
        ]
      ],
      "createCellRenderer": [
        "createCellRenderer(): mxCellRenderer;",
        [
          "/**",
          " * Creates a new {@link mxCellRenderer} to be used in this graph.",
          " */"
        ]
      ],
      "createCellEditor": [
        "createCellEditor(): mxCellEditor;",
        [
          "/**",
          " * Creates a new {@link mxCellEditor} to be used in this graph.",
          " */"
        ]
      ],
      "getModel": [
        "getModel(): mxGraphModel;",
        [
          "/**",
          " * Returns the {@link mxGraphModel} that contains the cells.",
          " */"
        ]
      ],
      "getView": [
        "getView(): mxGraphView;",
        [
          "/**",
          " * Returns the {@link mxGraphView} that contains the {@link mxCellStates}.",
          " */"
        ]
      ],
      "getStylesheet": [
        "getStylesheet(): mxStylesheet;",
        [
          "/**",
          " * Returns the {@link mxStylesheet} that defines the style.",
          " */"
        ]
      ],
      "setStylesheet": [
        "setStylesheet(stylesheet: mxStylesheet): void;",
        [
          "/**",
          " * Sets the {@link mxStylesheet} that defines the style.",
          " */"
        ]
      ],
      "getSelectionModel": [
        "getSelectionModel(): mxGraphSelectionModel;",
        [
          "/**",
          " * Returns the {@link mxGraphSelectionModel} that contains the selection.",
          " */"
        ]
      ],
      "setSelectionModel": [
        "setSelectionModel(selectionModel: mxGraphSelectionModel): void;",
        [
          "/**",
          " * Sets the {@link mxSelectionModel} that contains the selection.",
          " */"
        ]
      ],
      ")": [
        "): void;",
        [
          "/**",
          " * Traverses the (directed) graph invoking the given function for each",
          " * visited vertex and edge. The function is invoked with the current vertex",
          " * and the incoming edge as a parameter. This implementation makes sure",
          " * each vertex is only visited once. The function may return false if the",
          " * traversal should stop at the given vertex.",
          " *",
          " * @example",
          " *",
          " * ```javascript",
          " * mxLog.show();",
          " * var cell = graph.getSelectionCell();",
          " * graph.traverse(cell, false, function(vertex, edge)",
          " * {",
          " *   mxLog.debug(graph.getLabel(vertex));",
          " * });",
          " * ```",
          " *",
          " * @param vertex {@link mxCell} that represents the vertex where the traversal starts.",
          " * @param directed Optional boolean indicating if edges should only be traversed",
          " * from source to target. Default is `true`.",
          " * @param func Visitor function that takes the current vertex and the incoming",
          " * edge as arguments. The traversal stops if the function returns false.",
          " * @param edge Optional {@link mxCell} that represents the incoming edge. This is",
          " * null for the first step of the traversal.",
          " * @param visited Optional {@link mxDictionary} from cells to true for the visited cells.",
          " * @param inverse Optional boolean to traverse in inverse direction. Default is `false`.",
          " * This is ignored if directed is false.",
          " */"
        ]
      ],
      "graphModelChanged": [
        "graphModelChanged(changes: any[]): void;",
        [
          "/**",
          " * Called when the graph model changes. Invokes {@link processChange} on each",
          " * item of the given array to update the view accordingly.",
          " *",
          " * @param changes Array that contains the individual changes.",
          " */"
        ]
      ],
      "updateSelection": [
        "updateSelection(): void;",
        [
          "/**",
          " * Removes selection cells that are not in the model from the selection.",
          " */"
        ]
      ],
      "processChange": [
        "processChange(change: any): void;",
        [
          "/**",
          " * Processes the given change and invalidates the respective cached data",
          " * in {@link view}. This fires a {@link root} event if the root has changed in the",
          " * model.",
          " *",
          " * @param {(mxRootChange|mxChildChange|mxTerminalChange|mxGeometryChange|mxValueChange|mxStyleChange)} change - Object that represents the change on the model.",
          " */"
        ]
      ],
      "removeStateForCell": [
        "removeStateForCell(cell: mxCell): void;",
        [
          "/**",
          " * Removes all cached information for the given cell and its descendants.",
          " * This is called when a cell was removed from the model.",
          " *",
          " * Paramters:",
          " *",
          " * @param cell {@link mxCell} that was removed from the model.",
          " */"
        ]
      ],
      "addCellOverlay": [
        "addCellOverlay(cell: mxCell, overlay: mxCellOverlay): mxCellOverlay;",
        [
          "/**",
          " * Adds an {@link mxCellOverlay} for the specified cell. This method fires an",
          " * {@link addoverlay} event and returns the new {@link mxCellOverlay}.",
          " *",
          " * @param cell {@link mxCell} to add the overlay for.",
          " * @param overlay {@link mxCellOverlay} to be added for the cell.",
          " */"
        ]
      ],
      "getCellOverlays": [
        "getCellOverlays(cell: mxCell): mxCellOverlay[];",
        [
          "/**",
          " * Returns the array of {@link mxCellOverlays} for the given cell or null, if",
          " * no overlays are defined.",
          " *",
          " * @param cell {@link mxCell} whose overlays should be returned.",
          " */"
        ]
      ],
      "removeCellOverlay": [
        "removeCellOverlay(cell: mxCell, overlay: mxCellOverlay): mxCellOverlay;",
        [
          "/**",
          " * Removes and returns the given {@link mxCellOverlay} from the given cell. This",
          " * method fires a {@link removeoverlay} event. If no overlay is given, then all",
          " * overlays are removed using {@link removeOverlays}.",
          " *",
          " * @param cell {@link mxCell} whose overlay should be removed.",
          " * @param overlay Optional {@link mxCellOverlay} to be removed.",
          " */"
        ]
      ],
      "removeCellOverlays": [
        "removeCellOverlays(cell: mxCell): mxCellOverlay[];",
        [
          "/**",
          " * Removes all {@link mxCellOverlays} from the given cell. This method",
          " * fires a {@link removeoverlay} event for each {@link mxCellOverlay} and returns",
          " * the array of {@link mxCellOverlays} that was removed from the cell.",
          " *",
          " * @param cell {@link mxCell} whose overlays should be removed",
          " */"
        ]
      ],
      "clearCellOverlays": [
        "clearCellOverlays(cell: mxCell): void;",
        [
          "/**",
          " * Removes all {@link mxCellOverlays} in the graph for the given cell and all its",
          " * descendants. If no cell is specified then all overlays are removed from",
          " * the graph. This implementation uses {@link removeCellOverlays} to remove the",
          " * overlays from the individual cells.",
          " *",
          " * @param cell Optional {@link mxCell} that represents the root of the subtree to",
          " * remove the overlays from. Default is the root in the model.",
          " */"
        ]
      ],
      "setCellWarning": [
        "setCellWarning(cell: mxCell, warning: string, img?: mxImage, isSelect?: boolean): mxCellOverlay;",
        [
          "/**",
          " * Creates an overlay for the given cell using the warning and image or",
          " * {@link warningImage} and returns the new {@link mxCellOverlay}. The warning is",
          " * displayed as a tooltip in a red font and may contain HTML markup. If",
          " * the warning is null or a zero length string, then all overlays are",
          " * removed from the cell.",
          " *",
          " * @example",
          " * ```javascript",
          " * graph.setCellWarning(cell, '{@link b}Warning:</b>: Hello, World!');",
          " * ```",
          " *",
          " * @param cell {@link mxCell} whose warning should be set.",
          " * @param warning String that represents the warning to be displayed.",
          " * @param img Optional {@link mxImage} to be used for the overlay. Default is",
          " * {@link warningImage}.",
          " * @param isSelect Optional boolean indicating if a click on the overlay",
          " * should select the corresponding cell. Default is `false`.",
          " */"
        ]
      ],
      "startEditing": [
        "startEditing(evt?: MouseEvent): void;",
        [
          "/**",
          " * Calls {@link startEditingAtCell} using the given cell or the first selection",
          " * cell.",
          " *",
          " * @param evt Optional mouse event that triggered the editing.",
          " */"
        ]
      ],
      "startEditingAtCell": [
        "startEditingAtCell(cell?: mxCell, evt?: MouseEvent): void;",
        [
          "/**",
          " * Fires a {@link startEditing} event and invokes {@link mxCellEditor.startEditing}",
          " * on {@link editor}. After editing was started, a {@link editingStarted} event is",
          " * fired.",
          " *",
          " * @param cell {@link mxCell} to start the in-place editor for.",
          " * @param evt Optional mouse event that triggered the editing.",
          " */"
        ]
      ],
      "getEditingValue": [
        "getEditingValue(cell: mxCell, evt: MouseEvent): string;",
        [
          "/**",
          " * Returns the initial value for in-place editing. This implementation",
          " * returns {@link convertValueToString} for the given cell. If this function is",
          " * overridden, then {@link mxGraphModel.valueForCellChanged} should take care",
          " * of correctly storing the actual new value inside the user object.",
          " *",
          " * @param cell {@link mxCell} for which the initial editing value should be returned.",
          " * @param evt Optional mouse event that triggered the editor.",
          " */"
        ]
      ],
      "stopEditing": [
        "stopEditing(cancel: boolean): void;",
        [
          "/**",
          " * Stops the current editing  and fires a {@link editingStopped} event.",
          " *",
          " * @param cancel Boolean that specifies if the current editing value",
          " * should be stored.",
          " */"
        ]
      ],
      "labelChanged": [
        "labelChanged(cell: mxCell, value: any, evt?: MouseEvent): mxCell;",
        [
          "/**",
          " * Sets the label of the specified cell to the given value using",
          " * {@link cellLabelChanged} and fires {@link mxEvent.LABEL_CHANGED} while the",
          " * transaction is in progress. Returns the cell whose label was changed.",
          " *",
          " * @param cell {@link mxCell} whose label should be changed.",
          " * @param value New label to be assigned.",
          " * @param evt Optional event that triggered the change.",
          " */"
        ]
      ],
      "cellLabelChanged": [
        "cellLabelChanged(cell: mxCell, value: any, autoSize?: boolean): void;",
        [
          "/**",
          " * Sets the new label for a cell. If autoSize is true then",
          " * {@link cellSizeUpdated} will be called.",
          " *",
          " * In the following example, the function is extended to map changes to",
          " * attributes in an XML node, as shown in {@link convertValueToString}.",
          " * Alternatively, the handling of this can be implemented as shown in",
          " * {@link mxGraphModel.valueForCellChanged} without the need to clone the",
          " * user object.",
          " *",
          " * ```javascript",
          " * var graphCellLabelChanged = graph.cellLabelChanged;",
          " * graph.cellLabelChanged = function(cell, newValue, autoSize)",
          " * {",
          " * \t// Cloned for correct undo/redo",
          " * \tvar elt = cell.value.cloneNode(true);",
          " *  elt.setAttribute('label', newValue);",
          " *",
          " *  newValue = elt;",
          " *  graphCellLabelChanged.apply(this, arguments);",
          " * };",
          " * ```",
          " *",
          " * @param cell {@link mxCell} whose label should be changed.",
          " * @param value New label to be assigned.",
          " * @param autoSize Boolean that specifies if {@link cellSizeUpdated} should be called.",
          " */"
        ]
      ],
      "escape": [
        "escape(evt?: MouseEvent): void;",
        [
          "/**",
          " * Processes an escape keystroke.",
          " *",
          " * @param evt Mouseevent that represents the keystroke.",
          " */"
        ]
      ],
      "click": [
        "click(me: mxMouseEvent): void;",
        [
          "/**",
          " * Processes a singleclick on an optional cell and fires a {@link click} event.",
          " * The click event is fired initially. If the graph is enabled and the",
          " * event has not been consumed, then the cell is selected using",
          " * {@link selectCellForEvent} or the selection is cleared using",
          " * {@link clearSelection}. The events consumed state is set to true if the",
          " * corresponding {@link mxMouseEvent} has been consumed.",
          " *",
          " * To handle a click event, use the following code.",
          " *",
          " * ```javascript",
          " * graph.addListener(mxEvent.CLICK, function(sender, evt)",
          " * {",
          " *   var e = evt.getProperty('event'); // mouse event",
          " *   var cell = evt.getProperty('cell'); // cell may be null",
          " *",
          " *   if (cell != null)",
          " *   {",
          " *     // Do something useful with cell and consume the event",
          " *     evt.consume();",
          " *   }",
          " * });",
          " * ```",
          " *",
          " * @param me {@link mxMouseEvent} that represents the single click.",
          " */"
        ]
      ],
      "isSiblingSelected": [
        "isSiblingSelected(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if any sibling of the given cell is selected.",
          " */"
        ]
      ],
      "dblClick": [
        "dblClick(evt: MouseEvent, cell?: mxCell): void;",
        [
          "/**",
          " * Processes a doubleclick on an optional cell and fires a {@link dblclick}",
          " * event. The event is fired initially. If the graph is enabled and the",
          " * event has not been consumed, then {@link edit} is called with the given",
          " * cell. The event is ignored if no cell was specified.",
          " *",
          " * Example for overriding this method.",
          " *",
          " * ```javascript",
          " * graph.dblClick = function(evt, cell)",
          " * {",
          " *   var mxe = new mxEventObject(mxEvent.DOUBLE_CLICK, 'event', evt, 'cell', cell);",
          " *   this.fireEvent(mxe);",
          " *",
          " *   if (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed())",
          " *   {",
          " * \t   mxUtils.alert('Hello, World!');",
          " *     mxe.consume();",
          " *   }",
          " * }",
          " * ```",
          " *",
          " * Example listener for this event.",
          " *",
          " * ```javascript",
          " * graph.addListener(mxEvent.DOUBLE_CLICK, function(sender, evt)",
          " * {",
          " *   var cell = evt.getProperty('cell');",
          " *   // do something with the cell and consume the",
          " *   // event to prevent in-place editing from start",
          " * });",
          " * ```",
          " *",
          " * @param evt Mouseevent that represents the doubleclick.",
          " * @param cell Optional {@link mxCell} under the mousepointer.",
          " */"
        ]
      ],
      "tapAndHold": [
        "tapAndHold(me: mxMouseEvent): void;",
        [
          "/**",
          " * Handles the {@link mxMouseEvent} by highlighting the {@link mxCellState}.",
          " *",
          " * @param me {@link mxMouseEvent} that represents the touch event.",
          " * @param state Optional {@link mxCellState} that is associated with the event.",
          " */"
        ]
      ],
      "scrollPointToVisible": [
        "scrollPointToVisible(x: number, y: number, extend?: boolean, border?: number): void;",
        [
          "/**",
          " * Scrolls the graph to the given point, extending the graph container if",
          " * specified.",
          " */"
        ]
      ],
      "createPanningManager": [
        "createPanningManager(): mxPanningManager;",
        [
          "/**",
          " * Creates and returns an {@link mxPanningManager}.",
          " */"
        ]
      ],
      "getBorderSizes": [
        "getBorderSizes(): mxRectangle;",
        [
          "/**",
          " * Returns the size of the border and padding on all four sides of the",
          " * container. The left, top, right and bottom borders are stored in the x, y,",
          " * width and height of the returned {@link mxRectangle}, respectively.",
          " */"
        ]
      ],
      "getPreferredPageSize": [
        "getPreferredPageSize(bounds: mxRectangle, width: number, height: number): mxRectangle;",
        [
          "/**",
          " * Returns the preferred size of the background page if {@link preferPageSize} is true.",
          " */"
        ]
      ],
      "sizeDidChange": [
        "sizeDidChange(): void;",
        [
          "/**",
          " * Called when the size of the graph has changed. This implementation fires",
          " * a {@link size} event after updating the clipping region of the SVG element in",
          " * SVG-bases browsers.",
          " */"
        ]
      ],
      "doResizeContainer": [
        "doResizeContainer(width: number, height: number): void;",
        [
          "/**",
          " * Resizes the container for the given graph width and height.",
          " */"
        ]
      ],
      "updatePageBreaks": [
        "updatePageBreaks(visible: boolean, width: number, height: number): void;",
        [
          "/**",
          " * Invokes from {@link sizeDidChange} to redraw the page breaks.",
          " *",
          " * @param visible Boolean that specifies if page breaks should be shown.",
          " * @param width Specifies the width of the container in pixels.",
          " * @param height Specifies the height of the container in pixels.",
          " */"
        ]
      ],
      "getCurrentCellStyle": [
        "getCurrentCellStyle(cell: mxCell, ignoreState?: boolean): StyleMap;",
        [
          "/**",
          " * Returns the style for the given cell from the cell state, if one exists,",
          " * or using {@link getCellStyle}.",
          " *",
          " * @param cell {@link mxCell} whose style should be returned as an array.",
          " * @param ignoreState Optional boolean that specifies if the cell state should be ignored.",
          " */"
        ]
      ],
      "getCellStyle": [
        "getCellStyle(cell: mxCell): StyleMap;",
        [
          "/**",
          " * Returns an array of key, value pairs representing the cell style for the",
          " * given cell. If no string is defined in the model that specifies the",
          " * style, then the default style for the cell is returned or an empty object,",
          " * if no style can be found. Note: You should try and get the cell state",
          " * for the given cell and use the cached style in the state before using",
          " * this method.",
          " *",
          " * @param cell {@link mxCell} whose style should be returned as an array.",
          " */"
        ]
      ],
      "postProcessCellStyle": [
        "postProcessCellStyle(style: StyleMap): StyleMap;",
        [
          "/**",
          " * Tries to resolve the value for the image style in the image bundles and",
          " * turns short data URIs as defined in mxImageBundle to data URIs as",
          " * defined in RFC 2397 of the IETF.",
          " */"
        ]
      ],
      "setCellStyle": [
        "setCellStyle(style: string, cells?: mxCell[]): void;",
        [
          "/**",
          " * Sets the style of the specified cells. If no cells are given, then the",
          " * selection cells are changed.",
          " *",
          " * @param style String representing the new style of the cells.",
          " * @param cells Optional array of {@link mxCell} to set the style for. Default is the",
          " * selection cells.",
          " */"
        ]
      ],
      "toggleCellStyle": [
        "toggleCellStyle(key: string, defaultValue?: boolean, cell?: mxCell): any;",
        [
          "/**",
          " * Toggles the boolean value for the given key in the style of the given cell",
          " * and returns the new value as 0 or 1. If no cell is specified then the",
          " * selection cell is used.",
          " *",
          " * Parameter:",
          " *",
          " * @param key String representing the key for the boolean value to be toggled.",
          " * @param defaultValue Optional boolean default value if no value is defined.",
          " * Default is `false`.",
          " * @param cell Optional {@link mxCell} whose style should be modified. Default is",
          " * the selection cell.",
          " */"
        ]
      ],
      "toggleCellStyles": [
        "toggleCellStyles(key: string, defaultValue?: boolean, cells?: mxCell[]): any;",
        [
          "/**",
          " * Toggles the boolean value for the given key in the style of the given cells",
          " * and returns the new value as 0 or 1. If no cells are specified, then the",
          " * selection cells are used. For example, this can be used to toggle",
          " * {@link 'rounded'} or any other style with a boolean value.",
          " *",
          " * Parameter:",
          " *",
          " * @param key String representing the key for the boolean value to be toggled.",
          " * @param defaultValue Optional boolean default value if no value is defined.",
          " * Default is `false`.",
          " * @param cells Optional array of {@link mxCell} whose styles should be modified.",
          " * Default is the selection cells.",
          " */"
        ]
      ],
      "setCellStyles": [
        "setCellStyles(key: string, value: any, cells?: mxCell[]): void;",
        [
          "/**",
          " * Sets the key to value in the styles of the given cells. This will modify",
          " * the existing cell styles in-place and override any existing assignment",
          " * for the given key. If no cells are specified, then the selection cells",
          " * are changed. If no value is specified, then the respective key is",
          " * removed from the styles.",
          " *",
          " * @param key String representing the key to be assigned.",
          " * @param value String representing the new value for the key.",
          " * @param cells Optional array of {@link mxCell} to change the style for. Default is",
          " * the selection cells.",
          " */"
        ]
      ],
      "toggleCellStyleFlags": [
        "toggleCellStyleFlags(key: string, flag: number, cells?: mxCell[]): void;",
        [
          "/**",
          " * Toggles the given bit for the given key in the styles of the specified",
          " * cells.",
          " *",
          " * @param key String representing the key to toggle the flag in.",
          " * @param flag Integer that represents the bit to be toggled.",
          " * @param cells Optional array of {@link mxCell} to change the style for. Default is",
          " * the selection cells.",
          " */"
        ]
      ],
      "setCellStyleFlags": [
        "setCellStyleFlags(key: string, flag: number, value: boolean, cells?: mxCell[]): void;",
        [
          "/**",
          " * Sets or toggles the given bit for the given key in the styles of the",
          " * specified cells.",
          " *",
          " * @param key String representing the key to toggle the flag in.",
          " * @param flag Integer that represents the bit to be toggled.",
          " * @param value Boolean value to be used or null if the value should be toggled.",
          " * @param cells Optional array of {@link mxCell} to change the style for. Default is",
          " * the selection cells.",
          " */"
        ]
      ],
      "alignCells": [
        "alignCells(align: string, cells: mxCell[], param?: any): mxCell[];",
        [
          "/**",
          " * Aligns the given cells vertically or horizontally according to the given",
          " * alignment using the optional parameter as the coordinate.",
          " *",
          " * @param align Specifies the alignment. Possible values are all constants in",
          " * mxConstants with an ALIGN prefix.",
          " * @param cells Array of {@link mxCell} to be aligned.",
          " * @param param Optional coordinate for the alignment.",
          " */"
        ]
      ],
      "flipEdge": [
        "flipEdge(edge: mxCell): mxCell;",
        [
          "/**",
          " * Toggles the style of the given edge between null (or empty) and",
          " * {@link alternateEdgeStyle}. This method fires {@link mxEvent.FLIP_EDGE} while the",
          " * transaction is in progress. Returns the edge that was flipped.",
          " *",
          " * Here is an example that overrides this implementation to invert the",
          " * value of {@link 'elbow'} without removing any existing styles.",
          " *",
          " * ```javascript",
          " * graph.flipEdge = function(edge)",
          " * {",
          " *   if (edge != null)",
          " *   {",
          " *     var style = this.getCurrentCellStyle(edge);",
          " *     var elbow = mxUtils.getValue(style, 'elbow',",
          " *         mxConstants.ELBOW_HORIZONTAL);",
          " *     var value = (elbow == mxConstants.ELBOW_HORIZONTAL) ?",
          " *         mxConstants.ELBOW_VERTICAL : mxConstants.ELBOW_HORIZONTAL;",
          " *     this.setCellStyles('elbow', value, [edge]);",
          " *   }",
          " * };",
          " * ```",
          " *",
          " * @param edge {@link mxCell} whose style should be changed.",
          " */"
        ]
      ],
      "addImageBundle": [
        "addImageBundle(bundle: mxImageBundle): void;",
        [
          "/**",
          " * Adds the specified {@link mxImageBundle}.",
          " */"
        ]
      ],
      "removeImageBundle": [
        "removeImageBundle(bundle: mxImageBundle): void;",
        [
          "/**",
          " * Removes the specified {@link mxImageBundle}.",
          " */"
        ]
      ],
      "getImageFromBundles": [
        "getImageFromBundles(key: string): string;",
        [
          "/**",
          " * Searches all {@link imageBundles} for the specified key and returns the value",
          " * for the first match or null if the key is not found.",
          " */"
        ]
      ],
      "orderCells": [
        "orderCells(back: boolean, cells?: mxCell[]): mxCell[];",
        [
          "/**",
          " * Moves the given cells to the front or back. The change is carried out",
          " * using {@link cellsOrdered}. This method fires {@link mxEvent.ORDER_CELLS} while the",
          " * transaction is in progress.",
          " *",
          " * @param back Boolean that specifies if the cells should be moved to back.",
          " * @param cells Array of {@link mxCell} to move to the background. If null is",
          " * specified then the selection cells are used.",
          " */"
        ]
      ],
      "cellsOrdered": [
        "cellsOrdered(cells: mxCell[], back?: boolean): void;",
        [
          "/**",
          " * Moves the given cells to the front or back. This method fires",
          " * {@link mxEvent.CELLS_ORDERED} while the transaction is in progress.",
          " *",
          " * @param cells Array of {@link mxCell} whose order should be changed.",
          " * @param back Boolean that specifies if the cells should be moved to back.",
          " */"
        ]
      ],
      "groupCells": [
        "groupCells(group: mxCell | null, border?: number, cells?: mxCell[]): mxCell;",
        [
          "/**",
          " * Adds the cells into the given group. The change is carried out using",
          " * {@link cellsAdded}, {@link cellsMoved} and {@link cellsResized}. This method fires",
          " * {@link mxEvent.GROUP_CELLS} while the transaction is in progress. Returns the",
          " * new group. A group is only created if there is at least one entry in the",
          " * given array of cells.",
          " *",
          " * @param group {@link mxCell} that represents the target group. If `null` is specified",
          " * then a new group is created using {@link createGroupCell}.",
          " * @param border Optional integer that specifies the border between the child",
          " * area and the group bounds. Default is `0`.",
          " * @param cells Optional array of {@link mxCell} to be grouped. If `null` is specified",
          " * then the selection cells are used.",
          " */"
        ]
      ],
      "getCellsForGroup": [
        "getCellsForGroup(cells: mxCell[]): mxCell[];",
        [
          "/**",
          " * Returns the cells with the same parent as the first cell",
          " * in the given array.",
          " */"
        ]
      ],
      "getBoundsForGroup": [
        "getBoundsForGroup(group: mxCell, children: mxCell[], border?: number): mxRectangle;",
        [
          "/**",
          " * Returns the bounds to be used for the given group and children.",
          " */"
        ]
      ],
      "createGroupCell": [
        "createGroupCell(cells: mxCell[]): mxCell;",
        [
          "/**",
          " * Hook for creating the group cell to hold the given array of {@link mxCell} if",
          " * no group cell was given to the {@link group} function.",
          " *",
          " * The following code can be used to set the style of new group cells.",
          " *",
          " * ```javascript",
          " * var graphCreateGroupCell = graph.createGroupCell;",
          " * graph.createGroupCell = function(cells)",
          " * {",
          " *   var group = graphCreateGroupCell.apply(this, arguments);",
          " *   group.setStyle('group');",
          " *",
          " *   return group;",
          " * };",
          " */"
        ]
      ],
      "ungroupCells": [
        "ungroupCells(cells: mxCell[]): mxCell[];",
        [
          "/**",
          " * Ungroups the given cells by moving the children the children to their",
          " * parents parent and removing the empty groups. Returns the children that",
          " * have been removed from the groups.",
          " *",
          " * @param cells Array of cells to be ungrouped. If null is specified then the",
          " * selection cells are used.",
          " */"
        ]
      ],
      "removeCellsAfterUngroup": [
        "removeCellsAfterUngroup(cells: mxCell[]): void;",
        [
          "/**",
          " * Hook to remove the groups after {@link ungroupCells}.",
          " *",
          " * @param cells Array of {@link mxCell} that were ungrouped.",
          " */"
        ]
      ],
      "removeCellsFromParent": [
        "removeCellsFromParent(cells: mxCell[]): mxCell[];",
        [
          "/**",
          " * Removes the specified cells from their parents and adds them to the",
          " * default parent. Returns the cells that were removed from their parents.",
          " *",
          " * @param cells Array of {@link mxCell} to be removed from their parents.",
          " */"
        ]
      ],
      "getBoundingBox": [
        "getBoundingBox(cells: mxCell[]): mxRectangle;",
        [
          "/**",
          " * Returns the bounding box for the given array of {@link mxCell}. The bounding box for",
          " * each cell and its descendants is computed using {@link mxGraphView.getBoundingBox}.",
          " *",
          " * @param cells Array of {@link mxCell} whose bounding box should be returned.",
          " */"
        ]
      ],
      "cloneCell": [
        "cloneCell(cell: mxCell, allowInvalidEdges?: boolean, mapping?: any, keepPosition?: boolean): mxCell[];",
        [
          "/**",
          " * Returns the clone for the given cell. Uses {@link cloneCells}.",
          " *",
          " * @param cell {@link mxCell} to be cloned.",
          " * @param allowInvalidEdges Optional boolean that specifies if invalid edges",
          " * should be cloned. Default is `true`.",
          " * @param mapping Optional mapping for existing clones.",
          " * @param keepPosition Optional boolean indicating if the position of the cells should",
          " * be updated to reflect the lost parent cell. Default is `false`.",
          " */"
        ]
      ],
      "cloneCells": [
        "cloneCells(cells: mxCell[], allowInvalidEdges?: boolean, mapping?: any, keepPosition?: boolean): mxCell[];",
        [
          "/**",
          " * Returns the clones for the given cells. The clones are created recursively",
          " * using {@link mxGraphModel.cloneCells}. If the terminal of an edge is not in the",
          " * given array, then the respective end is assigned a terminal point and the",
          " * terminal is removed.",
          " *",
          " * @param cells Array of {@link mxCell} to be cloned.",
          " * @param allowInvalidEdges Optional boolean that specifies if invalid edges",
          " * should be cloned. Default is `true`.",
          " * @param mapping Optional mapping for existing clones.",
          " * @param keepPosition Optional boolean indicating if the position of the cells should",
          " * be updated to reflect the lost parent cell. Default is `false`.",
          " */"
        ]
      ],
      "insertEdge": [
        "insertEdge(parent: mxCell, id: string | null, value: any, source: mxCell, target: mxCell, style?: string): mxCell;",
        [
          "/**",
          " * Adds a new edge into the given parent {@link mxCell} using value as the user",
          " * object and the given source and target as the terminals of the new edge.",
          " * The id and style are used for the respective properties of the new",
          " * {@link mxCell}, which is returned.",
          " *",
          " * @param parent {@link mxCell} that specifies the parent of the new edge.",
          " * @param id Optional string that defines the Id of the new edge.",
          " * @param value JavaScript object to be used as the user object.",
          " * @param source {@link mxCell} that defines the source of the edge.",
          " * @param target {@link mxCell} that defines the target of the edge.",
          " * @param style Optional string that defines the cell style.",
          " */"
        ]
      ],
      "createEdge": [
        "createEdge(parent: mxCell, id: string | null, value: any, source: mxCell, target: mxCell, style?: string): mxCell;",
        [
          "/**",
          " * Hook method that creates the new edge for {@link insertEdge}. This",
          " * implementation does not set the source and target of the edge, these",
          " * are set when the edge is added to the model.",
          " *",
          " */"
        ]
      ],
      "addEdge": [
        "addEdge(edge: mxCell, parent?: mxCell, source?: mxCell, target?: mxCell, index?: number): mxCell;",
        [
          "/**",
          " * Adds the edge to the parent and connects it to the given source and",
          " * target terminals. This is a shortcut method. Returns the edge that was",
          " * added.",
          " *",
          " * @param edge {@link mxCell} to be inserted into the given parent.",
          " * @param parent {@link mxCell} that represents the new parent. If no parent is",
          " * given then the default parent is used.",
          " * @param source Optional {@link mxCell} that represents the source terminal.",
          " * @param target Optional {@link mxCell} that represents the target terminal.",
          " * @param index Optional index to insert the cells at. Default is 'to append'.",
          " */"
        ]
      ],
      "addCell": [
        "addCell(cell: mxCell, parent?: mxCell, index?: number, source?: mxCell, target?: mxCell): mxCell;",
        [
          "/**",
          " * Adds the cell to the parent and connects it to the given source and",
          " * target terminals. This is a shortcut method. Returns the cell that was",
          " * added.",
          " *",
          " * @param cell {@link mxCell} to be inserted into the given parent.",
          " * @param parent {@link mxCell} that represents the new parent. If no parent is",
          " * given then the default parent is used.",
          " * @param index Optional index to insert the cells at. Default is 'to append'.",
          " * @param source Optional {@link mxCell} that represents the source terminal.",
          " * @param target Optional {@link mxCell} that represents the target terminal.",
          " */"
        ]
      ],
      "autoSizeCell": [
        "autoSizeCell(cell: mxCell, recurse?: boolean): void;",
        [
          "/**",
          " * Resizes the specified cell to just fit around the its label and/or children",
          " *",
          " * @param cell {@link mxCell} to be resized.",
          " * @param recurse Optional boolean which specifies if all descendants should be",
          " * autosized. Default is `true`.",
          " */"
        ]
      ],
      "removeCells": [
        "removeCells(cells: mxCell[], includeEdges?: boolean): mxCell[];",
        [
          "/**",
          " * Removes the given cells from the graph including all connected edges if",
          " * includeEdges is true. The change is carried out using {@link cellsRemoved}.",
          " * This method fires {@link mxEvent.REMOVE_CELLS} while the transaction is in",
          " * progress. The removed cells are returned as an array.",
          " *",
          " * @param cells Array of {@link mxCell} to remove. If null is specified then the",
          " * selection cells which are deletable are used.",
          " * @param includeEdges Optional boolean which specifies if all connected edges",
          " * should be removed as well. Default is `true`.",
          " */"
        ]
      ],
      "cellsRemoved": [
        "cellsRemoved(cells: mxCell[]): void;",
        [
          "/**",
          " * Removes the given cells from the model. This method fires",
          " * {@link mxEvent.CELLS_REMOVED} while the transaction is in progress.",
          " *",
          " * @param cells Array of {@link mxCell} to remove.",
          " */"
        ]
      ],
      "toggleCells": [
        "toggleCells(show: boolean, cells: mxCell[], includeEdges: boolean): mxCell[];",
        [
          "/**",
          " * Sets the visible state of the specified cells and all connected edges",
          " * if includeEdges is true. The change is carried out using {@link cellsToggled}.",
          " * This method fires {@link mxEvent.TOGGLE_CELLS} while the transaction is in",
          " * progress. Returns the cells whose visible state was changed.",
          " *",
          " * @param show Boolean that specifies the visible state to be assigned.",
          " * @param cells Array of {@link mxCell} whose visible state should be changed. If",
          " * null is specified then the selection cells are used.",
          " * @param includeEdges Optional boolean indicating if the visible state of all",
          " * connected edges should be changed as well. Default is `true`.",
          " */"
        ]
      ],
      "cellsToggled": [
        "cellsToggled(cells: mxCell[], show: boolean): void;",
        [
          "/**",
          " * Sets the visible state of the specified cells.",
          " *",
          " * @param cells Array of {@link mxCell} whose visible state should be changed.",
          " * @param show Boolean that specifies the visible state to be assigned.",
          " */"
        ]
      ],
      "foldCells": [
        "foldCells(collapse: boolean, recurse: boolean, cells: mxCell[], checkFoldable?: boolean, evt?: Event): mxCell[];",
        [
          "/**",
          " * Sets the collapsed state of the specified cells and all descendants",
          " * if recurse is true. The change is carried out using {@link cellsFolded}.",
          " * This method fires {@link mxEvent.FOLD_CELLS} while the transaction is in",
          " * progress. Returns the cells whose collapsed state was changed.",
          " *",
          " * @param collapse Boolean indicating the collapsed state to be assigned.",
          " * @param recurse Optional boolean indicating if the collapsed state of all",
          " * descendants should be set. Default is `false`.",
          " * @param cells Array of {@link mxCell} whose collapsed state should be set. If",
          " * null is specified then the foldable selection cells are used.",
          " * @param checkFoldable Optional boolean indicating of isCellFoldable should be",
          " * checked. Default is `false`.",
          " * @param evt Optional native event that triggered the invocation.",
          " */"
        ]
      ],
      "cellsFolded": [
        "cellsFolded(cells: mxCell[], collapse: boolean, recurse: boolean, checkFoldable?: boolean): void;",
        [
          "/**",
          " * Sets the collapsed state of the specified cells. This method fires",
          " * {@link mxEvent.CELLS_FOLDED} while the transaction is in progress. Returns the",
          " * cells whose collapsed state was changed.",
          " *",
          " * @param cells Array of {@link mxCell} whose collapsed state should be set.",
          " * @param collapse Boolean indicating the collapsed state to be assigned.",
          " * @param recurse Boolean indicating if the collapsed state of all descendants",
          " * should be set.",
          " * @param checkFoldable Optional boolean indicating of isCellFoldable should be",
          " * checked. Default is `false`.",
          " */"
        ]
      ],
      "swapBounds": [
        "swapBounds(cell: mxCell, willCollapse: boolean): void;",
        [
          "/**",
          " * Swaps the alternate and the actual bounds in the geometry of the given",
          " * cell invoking {@link updateAlternateBounds} before carrying out the swap.",
          " *",
          " * @param cell {@link mxCell} for which the bounds should be swapped.",
          " * @param willCollapse Boolean indicating if the cell is going to be collapsed.",
          " */"
        ]
      ],
      "updateAlternateBounds": [
        "updateAlternateBounds(cell: mxCell, geo: mxGeometry, willCollapse: boolean): void;",
        [
          "/**",
          " * Updates or sets the alternate bounds in the given geometry for the given",
          " * cell depending on whether the cell is going to be collapsed. If no",
          " * alternate bounds are defined in the geometry and",
          " * {@link collapseToPreferredSize} is true, then the preferred size is used for",
          " * the alternate bounds. The top, left corner is always kept at the same",
          " * location.",
          " *",
          " * @param cell {@link mxCell} for which the geometry is being udpated.",
          " * @param g {@link mxGeometry} for which the alternate bounds should be updated.",
          " * @param willCollapse Boolean indicating if the cell is going to be collapsed.",
          " */"
        ]
      ],
      "addAllEdges": [
        "addAllEdges(cells: mxCell[]): mxCell[];",
        [
          "/**",
          " * Returns an array with the given cells and all edges that are connected",
          " * to a cell or one of its descendants.",
          " */"
        ]
      ],
      "getAllEdges": [
        "getAllEdges(cells: mxCell[]): mxCell[];",
        [
          "/**",
          " * Returns all edges connected to the given cells or its descendants.",
          " */"
        ]
      ],
      "updateCellSize": [
        "updateCellSize(cell: mxCell, ignoreChildren?: boolean): mxCell;",
        [
          "/**",
          " * Updates the size of the given cell in the model using {@link cellSizeUpdated}.",
          " * This method fires {@link mxEvent.UPDATE_CELL_SIZE} while the transaction is in",
          " * progress. Returns the cell whose size was updated.",
          " *",
          " * @param cell {@link mxCell} whose size should be updated.",
          " */"
        ]
      ],
      "cellSizeUpdated": [
        "cellSizeUpdated(cell: mxCell, ignoreChildren: boolean): void;",
        [
          "/**",
          " * Updates the size of the given cell in the model using",
          " * {@link getPreferredSizeForCell} to get the new size.",
          " *",
          " * @param cell {@link mxCell} for which the size should be changed.",
          " */"
        ]
      ],
      "getPreferredSizeForCell": [
        "getPreferredSizeForCell(cell: mxCell, textWidth?: number): mxRectangle;",
        [
          "/**",
          " * Returns the preferred width and height of the given {@link mxCell} as an",
          " * {@link mxRectangle}. To implement a minimum width, add a new style eg.",
          " * minWidth in the vertex and override this method as follows.",
          " *",
          " * ```javascript",
          " * var graphGetPreferredSizeForCell = graph.getPreferredSizeForCell;",
          " * graph.getPreferredSizeForCell = function(cell)",
          " * {",
          " *   var result = graphGetPreferredSizeForCell.apply(this, arguments);",
          " *   var style = this.getCellStyle(cell);",
          " *",
          " *   if (style.minWidth > 0)",
          " *   {",
          " *     result.width = Math.max(style.minWidth, result.width);",
          " *   }",
          " *",
          " *   return result;",
          " * };",
          " * ```",
          " *",
          " * @param cell {@link mxCell} for which the preferred size should be returned.",
          " * @param textWidth Optional maximum text width for word wrapping.",
          " */"
        ]
      ],
      "resizeCell": [
        "resizeCell(cell: mxCell, bounds: mxRectangle, recurse?: boolean): mxCell[];",
        [
          "/**",
          " * Sets the bounds of the given cell using {@link resizeCells}. Returns the",
          " * cell which was passed to the function.",
          " *",
          " * @param cell {@link mxCell} whose bounds should be changed.",
          " * @param bounds {@link mxRectangle} that represents the new bounds.",
          " */"
        ]
      ],
      "resizeCells": [
        "resizeCells(cells: mxCell[], bounds: mxRectangle[], recurse: boolean): mxCell[];",
        [
          "/**",
          " * Sets the bounds of the given cells and fires a {@link mxEvent.RESIZE_CELLS}",
          " * event while the transaction is in progress. Returns the cells which",
          " * have been passed to the function.",
          " *",
          " * @param cells Array of {@link mxCell} whose bounds should be changed.",
          " * @param bounds Array of {@link mxRectangles} that represent the new bounds.",
          " */"
        ]
      ],
      "cellsResized": [
        "cellsResized(cells: mxCell[], bounds: mxRectangle[], recurse?: boolean): mxGeometry[];",
        [
          "/**",
          " * Sets the bounds of the given cells and fires a {@link mxEvent.CELLS_RESIZED}",
          " * event. If {@link extendParents} is true, then the parent is extended if a",
          " * child size is changed so that it overlaps with the parent.",
          " *",
          " * The following example shows how to control group resizes to make sure",
          " * that all child cells stay within the group.",
          " *",
          " * ```javascript",
          " * graph.addListener(mxEvent.CELLS_RESIZED, function(sender, evt)",
          " * {",
          " *   var cells = evt.getProperty('cells');",
          " *",
          " *   if (cells != null)",
          " *   {",
          " *     for (var i = 0; i < cells.length; i++)",
          " *     {",
          " *       if (graph.getModel().getChildCount(cells[i]) > 0)",
          " *       {",
          " *         var geo = graph.getCellGeometry(cells[i]);",
          " *",
          " *         if (geo != null)",
          " *         {",
          " *           var children = graph.getChildCells(cells[i], true, true);",
          " *           var bounds = graph.getBoundingBoxFromGeometry(children, true);",
          " *",
          " *           geo = geo.clone();",
          " *           geo.width = Math.max(geo.width, bounds.width);",
          " *           geo.height = Math.max(geo.height, bounds.height);",
          " *",
          " *           graph.getModel().setGeometry(cells[i], geo);",
          " *         }",
          " *       }",
          " *     }",
          " *   }",
          " * });",
          " * ```",
          " *",
          " * @param cells Array of {@link mxCell} whose bounds should be changed.",
          " * @param bounds Array of {@link mxRectangles} that represent the new bounds.",
          " * @param recurse Optional boolean that specifies if the children should be resized.",
          " */"
        ]
      ],
      "cellResized": [
        "cellResized(cell: mxCell, bounds: mxRectangle, ignoreRelative?: boolean, recurse?: boolean): mxGeometry;",
        [
          "/**",
          " * Resizes the parents recursively so that they contain the complete area",
          " * of the resized child cell.",
          " *",
          " * @param cell {@link mxCell} whose bounds should be changed.",
          " * @param bounds {@link mxRectangles} that represent the new bounds.",
          " * @param ignoreRelative Boolean that indicates if relative cells should be ignored.",
          " * @param recurse Optional boolean that specifies if the children should be resized.",
          " */"
        ]
      ],
      "resizeChildCells": [
        "resizeChildCells(cell: mxCell, newGeo: mxGeometry): void;",
        [
          "/**",
          " * Resizes the child cells of the given cell for the given new geometry with",
          " * respect to the current geometry of the cell.",
          " *",
          " * @param cell {@link mxCell} that has been resized.",
          " * @param newGeo {@link mxGeometry} that represents the new bounds.",
          " */"
        ]
      ],
      "constrainChildCells": [
        "constrainChildCells(cell: mxCell): void;",
        [
          "/**",
          " * Constrains the children of the given cell using {@link constrainChild}.",
          " *",
          " * @param cell {@link mxCell} that has been resized.",
          " */"
        ]
      ],
      "scaleCell": [
        "scaleCell(cell: mxCell, dx: number, dy: number, recurse?: boolean): void;",
        [
          "/**",
          " * Scales the points, position and size of the given cell according to the",
          " * given vertical and horizontal scaling factors.",
          " *",
          " * @param cell {@link mxCell} whose geometry should be scaled.",
          " * @param dx Horizontal scaling factor.",
          " * @param dy Vertical scaling factor.",
          " * @param recurse Boolean indicating if the child cells should be scaled.",
          " */"
        ]
      ],
      "extendParent": [
        "extendParent(cell: mxCell): void;",
        [
          "/**",
          " * Resizes the parents recursively so that they contain the complete area",
          " * of the resized child cell.",
          " *",
          " * @param cell {@link mxCell} that has been resized.",
          " */"
        ]
      ],
      "importCells": [
        "importCells(cells: mxCell[], dx: number, dy: number, target: mxCell, evt?: Event, mapping?: any): mxCell[];",
        [
          "/**",
          " * Clones and inserts the given cells into the graph using the move",
          " * method and returns the inserted cells. This shortcut is used if",
          " * cells are inserted via datatransfer.",
          " *",
          " * @param cells Array of {@link mxCell} to be imported.",
          " * @param dx Integer that specifies the x-coordinate of the vector. Default is `0`.",
          " * @param dy Integer that specifies the y-coordinate of the vector. Default is `0`.",
          " * @param target {@link mxCell} that represents the new parent of the cells.",
          " * @param evt Mouseevent that triggered the invocation.",
          " * @param mapping Optional mapping for existing clones.",
          " */"
        ]
      ],
      "translateCell": [
        "translateCell(cell: mxCell, dx: number, dy: number): void;",
        [
          "/**",
          " * Translates the geometry of the given cell and stores the new,",
          " * translated geometry in the model as an atomic change.",
          " */"
        ]
      ],
      "getCellContainmentArea": [
        "getCellContainmentArea(cell: mxCell): mxRectangle;",
        [
          "/**",
          " * Returns the {@link mxRectangle} inside which a cell is to be kept.",
          " *",
          " * @param cell {@link mxCell} for which the area should be returned.",
          " */"
        ]
      ],
      "getMaximumGraphBounds": [
        "getMaximumGraphBounds(): mxRectangle;",
        [
          "/**",
          " * Returns the bounds inside which the diagram should be kept as an",
          " * {@link mxRectangle}.",
          " */"
        ]
      ],
      "constrainChild": [
        "constrainChild(cell: mxCell, sizeFirst?: boolean): void;",
        [
          "/**",
          " * Keeps the given cell inside the bounds returned by",
          " * {@link getCellContainmentArea} for its parent, according to the rules defined by",
          " * {@link getOverlap} and {@link isConstrainChild}. This modifies the cell's geometry",
          " * in-place and does not clone it.",
          " *",
          " * @param cell {@link mxCell} which should be constrained.",
          " * @param sizeFirst Specifies if the size should be changed first. Default is `true`.",
          " */"
        ]
      ],
      "resetEdges": [
        "resetEdges(cells: mxCell[]): void;",
        [
          "/**",
          " * Resets the control points of the edges that are connected to the given",
          " * cells if not both ends of the edge are in the given cells array.",
          " *",
          " * @param cells Array of {@link mxCell} for which the connected edges should be",
          " * reset.",
          " */"
        ]
      ],
      "resetEdge": [
        "resetEdge(edge: mxCell): mxCell;",
        [
          "/**",
          " * Resets the control points of the given edge.",
          " *",
          " * @param edge {@link mxCell} whose points should be reset.",
          " */"
        ]
      ],
      "getOutlineConstraint": [
        "getOutlineConstraint(point: mxPoint, terminalState: mxCellState, me: mxMouseEvent): mxConnectionConstraint;",
        [
          "/**",
          " * Returns the constraint used to connect to the outline of the given state.",
          " */"
        ]
      ],
      "getAllConnectionConstraints": [
        "getAllConnectionConstraints(terminal: mxCellState, source?: boolean): mxConnectionConstraint[];",
        [
          "/**",
          " * Returns an array of all {@link mxConnectionConstraints} for the given terminal. If",
          " * the shape of the given terminal is a {@link mxStencilShape} then the constraints",
          " * of the corresponding {@link mxStencil} are returned.",
          " *",
          " * @param terminal {@link mxCellState} that represents the terminal.",
          " * @param source Boolean that specifies if the terminal is the source or target.",
          " */"
        ]
      ],
      "getConnectionConstraint": [
        "getConnectionConstraint(edge: mxCellState, terminal: mxCellState, source?: boolean): mxConnectionConstraint;",
        [
          "/**",
          " * Returns an {@link mxConnectionConstraint} that describes the given connection",
          " * point. This result can then be passed to {@link getConnectionPoint}.",
          " *",
          " * @param edge {@link mxCellState} that represents the edge.",
          " * @param terminal {@link mxCellState} that represents the terminal.",
          " * @param source Boolean indicating if the terminal is the source or target.",
          " */"
        ]
      ],
      "setConnectionConstraint": [
        "setConnectionConstraint(edge: mxCell, terminal: mxCell, source: boolean, constraint?: mxConnectionConstraint): void;",
        [
          "/**",
          " * Sets the {@link mxConnectionConstraint} that describes the given connection point.",
          " * If no constraint is given then nothing is changed. To remove an existing",
          " * constraint from the given edge, use an empty constraint instead.",
          " *",
          " * @param edge {@link mxCell} that represents the edge.",
          " * @param terminal {@link mxCell} that represents the terminal.",
          " * @param source Boolean indicating if the terminal is the source or target.",
          " * @param constraint Optional {@link mxConnectionConstraint} to be used for this",
          " * connection.",
          " */"
        ]
      ],
      "getConnectionPoint": [
        "getConnectionPoint(vertex: mxCellState, constraint: mxConnectionConstraint, round?: boolean): mxPoint;",
        [
          "/**",
          " * Returns the nearest point in the list of absolute points or the center",
          " * of the opposite terminal.",
          " *",
          " * @param vertex {@link mxCellState} that represents the vertex.",
          " * @param constraint {@link mxConnectionConstraint} that represents the connection point",
          " * constraint as returned by {@link getConnectionConstraint}.",
          " */"
        ]
      ],
      "connectCell": [
        "connectCell(edge: mxCell, terminal: mxCell, source: boolean, constraint?: mxConnectionConstraint): mxCell;",
        [
          "/**",
          " * Connects the specified end of the given edge to the given terminal",
          " * using {@link cellConnected} and fires {@link mxEvent.CONNECT_CELL} while the",
          " * transaction is in progress. Returns the updated edge.",
          " *",
          " * @param edge {@link mxCell} whose terminal should be updated.",
          " * @param terminal {@link mxCell} that represents the new terminal to be used.",
          " * @param source Boolean indicating if the new terminal is the source or target.",
          " * @param constraint Optional {@link mxConnectionConstraint} to be used for this",
          " * connection.",
          " */"
        ]
      ],
      "cellConnected": [
        "cellConnected(edge: mxCell, terminal: mxCell, source: boolean, constraint: mxConnectionConstraint): void;",
        [
          "/**",
          " * Sets the new terminal for the given edge and resets the edge points if",
          " * {@link resetEdgesOnConnect} is true. This method fires",
          " * {@link mxEvent.CELL_CONNECTED} while the transaction is in progress.",
          " *",
          " * @param edge {@link mxCell} whose terminal should be updated.",
          " * @param terminal {@link mxCell} that represents the new terminal to be used.",
          " * @param source Boolean indicating if the new terminal is the source or target.",
          " * @param constraint {@link mxConnectionConstraint} to be used for this connection.",
          " */"
        ]
      ],
      "disconnectGraph": [
        "disconnectGraph(cells: mxCell[]): void;",
        [
          "/**",
          " * Disconnects the given edges from the terminals which are not in the",
          " * given array.",
          " *",
          " * @param cells Array of {@link mxCell} to be disconnected.",
          " */"
        ]
      ],
      "getCurrentRoot": [
        "getCurrentRoot(): mxCell;",
        [
          "/**",
          " * Returns the current root of the displayed cell hierarchy. This is a",
          " * shortcut to {@link mxGraphView.currentRoot} in {@link view}.",
          " */"
        ]
      ],
      "getTranslateForRoot": [
        "getTranslateForRoot(cell: mxCell): mxPoint;",
        [
          "/**",
          " * Returns the translation to be used if the given cell is the root cell as",
          " * an {@link mxPoint}. This implementation returns null.",
          " *",
          " * To keep the children at their absolute position while stepping into groups,",
          " * this function can be overridden as follows.",
          " *",
          " * @example",
          " * ```javascript",
          " * var offset = new mxPoint(0, 0);",
          " *",
          " * while (cell != null)",
          " * {",
          " *   var geo = this.model.getGeometry(cell);",
          " *",
          " *   if (geo != null)",
          " *   {",
          " *     offset.x -= geo.x;",
          " *     offset.y -= geo.y;",
          " *   }",
          " *",
          " *   cell = this.model.getParent(cell);",
          " * }",
          " *",
          " * return offset;",
          " * ```",
          " *",
          " * @param cell {@link mxCell} that represents the root.",
          " */"
        ]
      ],
      "isPort": [
        "isPort(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is a \"port\", that is, when connecting to",
          " * it, the cell returned by getTerminalForPort should be used as the",
          " * terminal and the port should be referenced by the ID in either the",
          " * mxConstants.STYLE_SOURCE_PORT or the or the",
          " * mxConstants.STYLE_TARGET_PORT. Note that a port should not be movable.",
          " * This implementation always returns false.",
          " *",
          " * A typical implementation is the following:",
          " *",
          " * ```javascript",
          " * graph.isPort = function(cell)",
          " * {",
          " *   var geo = this.getCellGeometry(cell);",
          " *",
          " *   return (geo != null) ? geo.relative : false;",
          " * };",
          " * ```",
          " *",
          " * @param cell {@link mxCell} that represents the port.",
          " */"
        ]
      ],
      "getTerminalForPort": [
        "getTerminalForPort(cell: mxCell, source: boolean): mxCell;",
        [
          "/**",
          " * Returns the terminal to be used for a given port. This implementation",
          " * always returns the parent cell.",
          " *",
          " * @param cell {@link mxCell} that represents the port.",
          " * @param source If the cell is the source or target port.",
          " */"
        ]
      ],
      "getChildOffsetForCell": [
        "getChildOffsetForCell(cell: mxCell): number;",
        [
          "/**",
          " * Returns the offset to be used for the cells inside the given cell. The",
          " * root and layer cells may be identified using {@link mxGraphModel.isRoot} and",
          " * {@link mxGraphModel.isLayer}. For all other current roots, the",
          " * {@link mxGraphView.currentRoot} field points to the respective cell, so that",
          " * the following holds: cell == this.view.currentRoot. This implementation",
          " * returns null.",
          " *",
          " * @param cell {@link mxCell} whose offset should be returned.",
          " */"
        ]
      ],
      "enterGroup": [
        "enterGroup(cell: mxCell): void;",
        [
          "/**",
          " * Uses the given cell as the root of the displayed cell hierarchy. If no",
          " * cell is specified then the selection cell is used. The cell is only used",
          " * if {@link isValidRoot} returns true.",
          " *",
          " * @param cell Optional {@link mxCell} to be used as the new root. Default is the",
          " * selection cell.",
          " */"
        ]
      ],
      "exitGroup": [
        "exitGroup(): void;",
        [
          "/**",
          " * Changes the current root to the next valid root in the displayed cell",
          " * hierarchy.",
          " */"
        ]
      ],
      "home": [
        "home(): void;",
        [
          "/**",
          " * Uses the root of the model as the root of the displayed cell hierarchy",
          " * and selects the previous root.",
          " */"
        ]
      ],
      "isValidRoot": [
        "isValidRoot(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is a valid root for the cell display",
          " * hierarchy. This implementation returns true for all non-null values.",
          " *",
          " * @param cell {@link mxCell} which should be checked as a possible root.",
          " */"
        ]
      ],
      "getGraphBounds": [
        "getGraphBounds(): mxRectangle;",
        [
          "/**",
          " * Returns the bounds of the visible graph. Shortcut to",
          " * {@link mxGraphView.getGraphBounds}. See also: {@link getBoundingBoxFromGeometry}.",
          " */"
        ]
      ],
      "getCellBounds": [
        "getCellBounds(cell: mxCell, includeEdges?: boolean, includeDescendants?: boolean): mxRectangle;",
        [
          "/**",
          " * Returns the scaled, translated bounds for the given cell. See",
          " * {@link mxGraphView.getBounds} for arrays.",
          " *",
          " * @param cell {@link mxCell} whose bounds should be returned.",
          " * @param includeEdges Optional boolean that specifies if the bounds of",
          " * the connected edges should be included. Default is `false`.",
          " * @param includeDescendants Optional boolean that specifies if the bounds",
          " * of all descendants should be included. Default is `false`.",
          " */"
        ]
      ],
      "getBoundingBoxFromGeometry": [
        "getBoundingBoxFromGeometry(cells: mxCell[], includeEdges?: boolean): mxRectangle;",
        [
          "/**",
          " * Returns the bounding box for the geometries of the vertices in the",
          " * given array of cells. This can be used to find the graph bounds during",
          " * a layout operation (ie. before the last endUpdate) as follows:",
          " *",
          " * ```javascript",
          " * var cells = graph.getChildCells(graph.getDefaultParent(), true, true);",
          " * var bounds = graph.getBoundingBoxFromGeometry(cells, true);",
          " * ```",
          " *",
          " * This can then be used to move cells to the origin:",
          " *",
          " * ```javascript",
          " * if (bounds.x < 0 || bounds.y < 0)",
          " * {",
          " *   graph.moveCells(cells, -Math.min(bounds.x, 0), -Math.min(bounds.y, 0))",
          " * }",
          " * ```",
          " *",
          " * Or to translate the graph view:",
          " *",
          " * ```javascript",
          " * if (bounds.x < 0 || bounds.y < 0)",
          " * {",
          " *   graph.view.setTranslate(-Math.min(bounds.x, 0), -Math.min(bounds.y, 0));",
          " * }",
          " * ```",
          " *",
          " * @param cells Array of {@link mxCell} whose bounds should be returned.",
          " * @param includeEdges Specifies if edge bounds should be included by computing",
          " * the bounding box for all points in geometry. Default is `false`.",
          " */"
        ]
      ],
      "refresh": [
        "refresh(cell?: mxCell): void;",
        [
          "/**",
          " * Clears all cell states or the states for the hierarchy starting at the",
          " * given cell and validates the graph. This fires a refresh event as the",
          " * last step.",
          " *",
          " * @param cell Optional {@link mxCell} for which the cell states should be cleared.",
          " */"
        ]
      ],
      "snap": [
        "snap(value: number): number;",
        [
          "/**",
          " * Snaps the given numeric value to the grid if {@link gridEnabled} is true.",
          " *",
          " * @param value Numeric value to be snapped to the grid.",
          " */"
        ]
      ],
      "panGraph": [
        "panGraph(dx: number, dy: number): void;",
        [
          "/**",
          " * Shifts the graph display by the given amount. This is used to preview",
          " * panning operations, use {@link mxGraphView.setTranslate} to set a persistent",
          " * translation of the view. Fires {@link mxEvent.PAN}.",
          " *",
          " * @param dx Amount to shift the graph along the x-axis.",
          " * @param dy Amount to shift the graph along the y-axis.",
          " */"
        ]
      ],
      "zoomIn": [
        "zoomIn(): void;",
        [
          "/**",
          " * Zooms into the graph by {@link zoomFactor}.",
          " */"
        ]
      ],
      "zoomOut": [
        "zoomOut(): void;",
        [
          "/**",
          " * Zooms out of the graph by {@link zoomFactor}.",
          " */"
        ]
      ],
      "zoomActual": [
        "zoomActual(): void;",
        [
          "/**",
          " * Resets the zoom and panning in the view.",
          " */"
        ]
      ],
      "zoomTo": [
        "zoomTo(scale: number, center?: boolean): void;",
        [
          "/**",
          " * Zooms the graph to the given scale with an optional boolean center",
          " * argument, which is passd to {@link zoom}.",
          " */"
        ]
      ],
      "center": [
        "center(horizontal?: boolean, vertical?: boolean, cx?: number, cy?: number): void;",
        [
          "/**",
          " * Centers the graph in the container.",
          " *",
          " * @param horizontal Optional boolean that specifies if the graph should be centered",
          " * horizontally. Default is `true`.",
          " * @param vertical Optional boolean that specifies if the graph should be centered",
          " * vertically. Default is `true`.",
          " * @param cx Optional float that specifies the horizontal center. Default is `0.5`.",
          " * @param cy Optional float that specifies the vertical center. Default is `0.5`.",
          " */"
        ]
      ],
      "zoom": [
        "zoom(factor: number, center: boolean): void;",
        [
          "/**",
          " * Zooms the graph using the given factor. Center is an optional boolean",
          " * argument that keeps the graph scrolled to the center. If the center argument",
          " * is omitted, then {@link centerZoom} will be used as its value.",
          " */"
        ]
      ],
      "zoomToRect": [
        "zoomToRect(rect: mxRectangle): void;",
        [
          "/**",
          " * Zooms the graph to the specified rectangle. If the rectangle does not have same aspect",
          " * ratio as the display container, it is increased in the smaller relative dimension only",
          " * until the aspect match. The original rectangle is centralised within this expanded one.",
          " *",
          " * Note that the input rectangular must be un-scaled and un-translated.",
          " *",
          " * @param rect The un-scaled and un-translated rectangluar region that should be just visible",
          " * after the operation",
          " */"
        ]
      ],
      "scrollCellToVisible": [
        "scrollCellToVisible(cell: mxCell, center?: boolean): void;",
        [
          "/**",
          " * Pans the graph so that it shows the given cell. Optionally the cell may",
          " * be centered in the container.",
          " *",
          " * To center a given graph if the {@link container} has no scrollbars, use the following code.",
          " *",
          " * [code]",
          " * var bounds = graph.getGraphBounds();",
          " * graph.view.setTranslate(-bounds.x - (bounds.width - container.clientWidth) / 2,",
          " * \t\t\t\t\t\t   -bounds.y - (bounds.height - container.clientHeight) / 2);",
          " * [/code]",
          " *",
          " * @param cell {@link mxCell} to be made visible.",
          " * @param center Optional boolean flag. Default is `false`.",
          " */"
        ]
      ],
      "scrollRectToVisible": [
        "scrollRectToVisible(rect: mxRectangle): boolean;",
        [
          "/**",
          " * Pans the graph so that it shows the given rectangle.",
          " *",
          " * @param rect {@link mxRectangle} to be made visible.",
          " */"
        ]
      ],
      "getCellGeometry": [
        "getCellGeometry(cell: mxCell): mxGeometry;",
        [
          "/**",
          " * Returns the {@link mxGeometry} for the given cell. This implementation uses",
          " * {@link mxGraphModel.getGeometry}. Subclasses can override this to implement",
          " * specific geometries for cells in only one graph, that is, it can return",
          " * geometries that depend on the current state of the view.",
          " *",
          " * @param cell {@link mxCell} whose geometry should be returned.",
          " */"
        ]
      ],
      "isCellVisible": [
        "isCellVisible(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is visible in this graph. This",
          " * implementation uses {@link mxGraphModel.isVisible}. Subclassers can override",
          " * this to implement specific visibility for cells in only one graph, that",
          " * is, without affecting the visible state of the cell.",
          " *",
          " * When using dynamic filter expressions for cell visibility, then the",
          " * graph should be revalidated after the filter expression has changed.",
          " *",
          " * @param cell {@link mxCell} whose visible state should be returned.",
          " */"
        ]
      ],
      "isCellCollapsed": [
        "isCellCollapsed(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is collapsed in this graph. This",
          " * implementation uses {@link mxGraphModel.isCollapsed}. Subclassers can override",
          " * this to implement specific collapsed states for cells in only one graph,",
          " * that is, without affecting the collapsed state of the cell.",
          " *",
          " * When using dynamic filter expressions for the collapsed state, then the",
          " * graph should be revalidated after the filter expression has changed.",
          " *",
          " * @param cell {@link mxCell} whose collapsed state should be returned.",
          " */"
        ]
      ],
      "isCellConnectable": [
        "isCellConnectable(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is connectable in this graph. This",
          " * implementation uses {@link mxGraphModel.isConnectable}. Subclassers can override",
          " * this to implement specific connectable states for cells in only one graph,",
          " * that is, without affecting the connectable state of the cell in the model.",
          " *",
          " * @param cell {@link mxCell} whose connectable state should be returned.",
          " */"
        ]
      ],
      "isOrthogonal": [
        "isOrthogonal(edge: mxCellState): boolean;",
        [
          "/**",
          " * Returns true if perimeter points should be computed such that the",
          " * resulting edge has only horizontal or vertical segments.",
          " *",
          " * @param edge {@link mxCellState} that represents the edge.",
          " */"
        ]
      ],
      "isLoop": [
        "isLoop(state: mxCellState): boolean;",
        [
          "/**",
          " * Returns true if the given cell state is a loop.",
          " *",
          " * @param state {@link mxCellState} that represents a potential loop.",
          " */"
        ]
      ],
      "isCloneEvent": [
        "isCloneEvent(evt: MouseEvent): boolean;",
        [
          "/**",
          " * Returns true if the given event is a clone event. This implementation",
          " * returns true if control is pressed.",
          " */"
        ]
      ],
      "isTransparentClickEvent": [
        "isTransparentClickEvent(evt: MouseEvent): boolean;",
        [
          "/**",
          " * Hook for implementing click-through behaviour on selected cells. If this",
          " * returns true the cell behind the selected cell will be selected. This",
          " * implementation returns false;",
          " */"
        ]
      ],
      "isToggleEvent": [
        "isToggleEvent(evt: MouseEvent): boolean;",
        [
          "/**",
          " * Returns true if the given event is a toggle event. This implementation",
          " * returns true if the meta key (Cmd) is pressed on Macs or if control is",
          " * pressed on any other platform.",
          " */"
        ]
      ],
      "isGridEnabledEvent": [
        "isGridEnabledEvent(evt: MouseEvent): boolean;",
        [
          "/**",
          " * Returns true if the given mouse event should be aligned to the grid.",
          " */"
        ]
      ],
      "isConstrainedEvent": [
        "isConstrainedEvent(evt: MouseEvent): boolean;",
        [
          "/**",
          " * Returns true if the given mouse event should be aligned to the grid.",
          " */"
        ]
      ],
      "isIgnoreTerminalEvent": [
        "isIgnoreTerminalEvent(evt: MouseEvent): boolean;",
        [
          "/**",
          " * Returns true if the given mouse event should not allow any connections to be",
          " * made. This implementation returns false.",
          " */"
        ]
      ],
      "validationAlert": [
        "validationAlert(message: string): void;",
        [
          "/**",
          " * Displays the given validation error in a dialog. This implementation uses",
          " * mxUtils.alert.",
          " */"
        ]
      ],
      "isEdgeValid": [
        "isEdgeValid(edge: mxCell, source: mxCell, target: mxCell): boolean;",
        [
          "/**",
          " * Checks if the return value of {@link getEdgeValidationError} for the given",
          " * arguments is null.",
          " *",
          " * @param edge {@link mxCell} that represents the edge to validate.",
          " * @param source {@link mxCell} that represents the source terminal.",
          " * @param target {@link mxCell} that represents the target terminal.",
          " */"
        ]
      ],
      "getEdgeValidationError": [
        "getEdgeValidationError(edge: mxCell, source: mxCell, target: mxCell): string;",
        [
          "/**",
          " * Returns the validation error message to be displayed when inserting or",
          " * changing an edges' connectivity. A return value of null means the edge",
          " * is valid, a return value of '' means it's not valid, but do not display",
          " * an error message. Any other (non-empty) string returned from this method",
          " * is displayed as an error message when trying to connect an edge to a",
          " * source and target. This implementation uses the {@link multiplicities}, and",
          " * checks {@link multigraph}, {@link allowDanglingEdges} and {@link allowLoops} to generate",
          " * validation errors.",
          " *",
          " * For extending this method with specific checks for source/target cells,",
          " * the method can be extended as follows. Returning an empty string means",
          " * the edge is invalid with no error message, a non-null string specifies",
          " * the error message, and null means the edge is valid.",
          " *",
          " * ```javascript",
          " * graph.getEdgeValidationError = function(edge, source, target)",
          " * {",
          " *   if (source != null && target != null &&",
          " *     this.model.getValue(source) != null &&",
          " *     this.model.getValue(target) != null)",
          " *   {",
          " *     if (target is not valid for source)",
          " *     {",
          " *       return 'Invalid Target';",
          " *     }",
          " *   }",
          " *",
          " *   // \"Supercall\"",
          " *   return getEdgeValidationError.apply(this, arguments);",
          " * }",
          " * ```",
          " *",
          " * @param edge {@link mxCell} that represents the edge to validate.",
          " * @param source {@link mxCell} that represents the source terminal.",
          " * @param target {@link mxCell} that represents the target terminal.",
          " */"
        ]
      ],
      "validateEdge": [
        "validateEdge(edge: mxCell, source: mxCell, target: mxCell): string | null;",
        [
          "/**",
          " * Hook method for subclassers to return an error message for the given",
          " * edge and terminals. This implementation returns null.",
          " *",
          " * @param edge {@link mxCell} that represents the edge to validate.",
          " * @param source {@link mxCell} that represents the source terminal.",
          " * @param target {@link mxCell} that represents the target terminal.",
          " */"
        ]
      ],
      "validateGraph": [
        "validateGraph(cell: mxCell, context: any): string | null;",
        [
          "/**",
          " * Validates the graph by validating each descendant of the given cell or",
          " * the root of the model. Context is an object that contains the validation",
          " * state for the complete validation run. The validation errors are",
          " * attached to their cells using {@link setCellWarning}. Returns null in the case of",
          " * successful validation or an array of strings (warnings) in the case of",
          " * failed validations.",
          " *",
          " * Paramters:",
          " *",
          " * @param cell Optional {@link mxCell} to start the validation recursion. Default is",
          " * the graph root.",
          " * @param context Object that represents the global validation state.",
          " */"
        ]
      ],
      "getCellValidationError": [
        "getCellValidationError(cell: mxCell): string | null;",
        [
          "/**",
          " * Checks all {@link multiplicities} that cannot be enforced while the graph is",
          " * being modified, namely, all multiplicities that require a minimum of",
          " * 1 edge.",
          " *",
          " * @param cell {@link mxCell} for which the multiplicities should be checked.",
          " */"
        ]
      ],
      "validateCell": [
        "validateCell(cell: mxCell, context: any): string | null;",
        [
          "/**",
          " * Hook method for subclassers to return an error message for the given",
          " * cell and validation context. This implementation returns null. Any HTML",
          " * breaks will be converted to linefeeds in the calling method.",
          " *",
          " * @param cell {@link mxCell} that represents the cell to validate.",
          " * @param context Object that represents the global validation state.",
          " */"
        ]
      ],
      "getBackgroundImage": [
        "getBackgroundImage(): mxImage;",
        [
          "/**",
          " * Returns the {@link backgroundImage} as an {@link mxImage}.",
          " */"
        ]
      ],
      "setBackgroundImage": [
        "setBackgroundImage(image: mxImage): void;",
        [
          "/**",
          " * Sets the new {@link backgroundImage}.",
          " *",
          " * @param image New {@link mxImage} to be used for the background.",
          " */"
        ]
      ],
      "getFoldingImage": [
        "getFoldingImage(state: mxCellState): mxImage;",
        [
          "/**",
          " * Returns the {@link mxImage} used to display the collapsed state of",
          " * the specified cell state. This returns null for all edges.",
          " */"
        ]
      ],
      "convertValueToString": [
        "convertValueToString(cell: mxCell): string;",
        [
          "/**",
          " * Returns the textual representation for the given cell. This",
          " * implementation returns the nodename or string-representation of the user",
          " * object.",
          " *",
          " *",
          " * The following returns the label attribute from the cells user",
          " * object if it is an XML node.",
          " *",
          " * @example",
          " * ```javascript",
          " * graph.convertValueToString = function(cell)",
          " * {",
          " * \treturn cell.getAttribute('label');",
          " * }",
          " * ```",
          " *",
          " * See also: {@link cellLabelChanged}.",
          " *",
          " * @param cell {@link mxCell} whose textual representation should be returned.",
          " */"
        ]
      ],
      "getLabel": [
        "getLabel(cell: mxCell): string | Node;",
        [
          "/**",
          " * Returns a string or DOM node that represents the label for the given",
          " * cell. This implementation uses {@link convertValueToString} if {@link labelsVisible}",
          " * is true. Otherwise it returns an empty string.",
          " *",
          " * To truncate a label to match the size of the cell, the following code",
          " * can be used.",
          " *",
          " * ```javascript",
          " * graph.getLabel = function(cell)",
          " * {",
          " *   var label = getLabel.apply(this, arguments);",
          " *",
          " *   if (label != null && this.model.isVertex(cell))",
          " *   {",
          " *     var geo = this.getCellGeometry(cell);",
          " *",
          " *     if (geo != null)",
          " *     {",
          " *       var max = parseInt(geo.width / 8);",
          " *",
          " *       if (label.length > max)",
          " *       {",
          " *         label = label.substring(0, max)+'...';",
          " *       }",
          " *     }",
          " *   }",
          " *   return mxUtils.htmlEntities(label);",
          " * }",
          " * ```",
          " *",
          " * A resize listener is needed in the graph to force a repaint of the label",
          " * after a resize.",
          " *",
          " * ```javascript",
          " * graph.addListener(mxEvent.RESIZE_CELLS, function(sender, evt)",
          " * {",
          " *   var cells = evt.getProperty('cells');",
          " *",
          " *   for (var i = 0; i < cells.length; i++)",
          " *   {",
          " *     this.view.removeState(cells[i]);",
          " *   }",
          " * });",
          " * ```",
          " *",
          " * @param cell {@link mxCell} whose label should be returned.",
          " */"
        ]
      ],
      "isHtmlLabel": [
        "isHtmlLabel(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the label must be rendered as HTML markup. The default",
          " * implementation returns {@link htmlLabels}.",
          " *",
          " * @param cell {@link mxCell} whose label should be displayed as HTML markup.",
          " */"
        ]
      ],
      "isHtmlLabels": [
        "isHtmlLabels(): boolean;",
        [
          "/**",
          " * Returns {@link htmlLabels}.",
          " */"
        ]
      ],
      "setHtmlLabels": [
        "setHtmlLabels(value: boolean): void;",
        [
          "/**",
          " * Sets {@link htmlLabels}.",
          " */"
        ]
      ],
      "isWrapping": [
        "isWrapping(cell: mxCell): boolean;",
        [
          "/**",
          " * This enables wrapping for HTML labels.",
          " *",
          " * Returns true if no white-space CSS style directive should be used for",
          " * displaying the given cells label. This implementation returns true if",
          " * {@link 'whiteSpace'} in the style of the given cell is 'wrap'.",
          " *",
          " * This is used as a workaround for IE ignoring the white-space directive",
          " * of child elements if the directive appears in a parent element. It",
          " * should be overridden to return true if a white-space directive is used",
          " * in the HTML markup that represents the given cells label. In order for",
          " * HTML markup to work in labels, {@link isHtmlLabel} must also return true",
          " * for the given cell.",
          " *",
          " * @example",
          " *",
          " * ```javascript",
          " * graph.getLabel = function(cell)",
          " * {",
          " *   var tmp = getLabel.apply(this, arguments); // \"supercall\"",
          " *",
          " *   if (this.model.isEdge(cell))",
          " *   {",
          " *     tmp = '<div style=\"width: 150px; white-space:normal;\">'+tmp+'</div>';",
          " *   }",
          " *",
          " *   return tmp;",
          " * }",
          " *",
          " * graph.isWrapping = function(state)",
          " * {",
          " * \t return this.model.isEdge(state.cell);",
          " * }",
          " * ```",
          " *",
          " * Makes sure no edge label is wider than 150 pixels, otherwise the content",
          " * is wrapped. Note: No width must be specified for wrapped vertex labels as",
          " * the vertex defines the width in its geometry.",
          " *",
          " * @param state {@link mxCell} whose label should be wrapped.",
          " */"
        ]
      ],
      "isLabelClipped": [
        "isLabelClipped(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the overflow portion of labels should be hidden. If this",
          " * returns true then vertex labels will be clipped to the size of the vertices.",
          " * This implementation returns true if {@link mxConstants.STYLE_OVERFLOW} in the",
          " * style of the given cell is 'hidden'.",
          " *",
          " * @param state {@link mxCell} whose label should be clipped.",
          " */"
        ]
      ],
      "getTooltip": [
        "getTooltip(state: mxCellState, node: Node, x: number, y: number): string;",
        [
          "/**",
          " * Returns the string or DOM node that represents the tooltip for the given",
          " * state, node and coordinate pair. This implementation checks if the given",
          " * node is a folding icon or overlay and returns the respective tooltip. If",
          " * this does not result in a tooltip, the handler for the cell is retrieved",
          " * from {@link selectionCellsHandler} and the optional getTooltipForNode method is",
          " * called. If no special tooltip exists here then {@link getTooltipForCell} is used",
          " * with the cell in the given state as the argument to return a tooltip for the",
          " * given state.",
          " *",
          " * @param state {@link mxCellState} whose tooltip should be returned.",
          " * @param node DOM node that is currently under the mouse.",
          " * @param x X-coordinate of the mouse.",
          " * @param y Y-coordinate of the mouse.",
          " */"
        ]
      ],
      "getTooltipForCell": [
        "getTooltipForCell(cell: mxCell): string;",
        [
          "/**",
          " * Returns the string or DOM node to be used as the tooltip for the given",
          " * cell. This implementation uses the cells getTooltip function if it",
          " * exists, or else it returns {@link convertValueToString} for the cell.",
          " *",
          " * @example",
          " *",
          " * ```javascript",
          " * graph.getTooltipForCell = function(cell)",
          " * {",
          " *   return 'Hello, World!';",
          " * }",
          " * ```",
          " *",
          " * Replaces all tooltips with the string Hello, World!",
          " *",
          " * @param cell {@link mxCell} whose tooltip should be returned.",
          " */"
        ]
      ],
      "getLinkForCell": [
        "getLinkForCell(cell: mxCell): any;",
        [
          "/**",
          " * Returns the string to be used as the link for the given cell. This",
          " * implementation returns null.",
          " *",
          " * @param cell {@link mxCell} whose tooltip should be returned.",
          " */"
        ]
      ],
      "getCursorForMouseEvent": [
        "getCursorForMouseEvent(me: mxMouseEvent): string;",
        [
          "/**",
          " * Returns the cursor value to be used for the CSS of the shape for the",
          " * given event. This implementation calls {@link getCursorForCell}.",
          " *",
          " * @param me {@link mxMouseEvent} whose cursor should be returned.",
          " */"
        ]
      ],
      "getCursorForCell": [
        "getCursorForCell(cell: mxCell): string;",
        [
          "/**",
          " * Returns the cursor value to be used for the CSS of the shape for the",
          " * given cell. This implementation returns null.",
          " *",
          " * @param cell {@link mxCell} whose cursor should be returned.",
          " */"
        ]
      ],
      "getStartSize": [
        "getStartSize(swimlane: mxCell, ignoreState?: boolean): mxRectangle;",
        [
          "/**",
          " * Returns the start size of the given swimlane, that is, the width or",
          " * height of the part that contains the title, depending on the",
          " * horizontal style. The return value is an {@link mxRectangle} with either",
          " * width or height set as appropriate.",
          " *",
          " * @param swimlane {@link mxCell} whose start size should be returned.",
          " * @param ignoreState Optional boolean that specifies if cell state should be ignored.",
          " */"
        ]
      ],
      "getSwimlaneDirection": [
        "getSwimlaneDirection(style: string): string;",
        [
          "/**",
          " * Returns the direction for the given swimlane style.",
          " */"
        ]
      ],
      "getActualStartSize": [
        "getActualStartSize(swimlane: mxCell, ignoreState?: boolean): mxRectangle;",
        [
          "/**",
          " * Returns the actual start size of the given swimlane taking into account",
          " * direction and horizontal and vertial flip styles. The start size is",
          " * returned as an {@link mxRectangle} where top, left, bottom, right start sizes",
          " * are returned as x, y, height and width, respectively.",
          " *",
          " * @param swimlane {@link mxCell} whose start size should be returned.",
          " * @param ignoreState Optional boolean that specifies if cell state should be ignored.",
          " */"
        ]
      ],
      "getImage": [
        "getImage(state: mxCellState): string;",
        [
          "/**",
          " * Returns the image URL for the given cell state. This implementation",
          " * returns the value stored under {@link 'image'} in the cell",
          " * style.",
          " *",
          " * @param state {@link mxCellState} whose image URL should be returned.",
          " */"
        ]
      ],
      "isTransparentState": [
        "isTransparentState(state: mxCellState): boolean;",
        [
          "/**",
          " * Returns true if the given state has no stroke- or fillcolor and no image.",
          " *",
          " * @param state {@link mxCellState} to check.",
          " */"
        ]
      ],
      "getVerticalAlign": [
        "getVerticalAlign(state: mxCellState): string;",
        [
          "/**",
          " * Returns the vertical alignment for the given cell state. This",
          " * implementation returns the value stored under",
          " * {@link 'verticalAlign'} in the cell style.",
          " *",
          " * @param state {@link mxCellState} whose vertical alignment should be",
          " * returned.",
          " */"
        ]
      ],
      "getIndicatorColor": [
        "getIndicatorColor(state: mxCellState): string;",
        [
          "/**",
          " * Returns the indicator color for the given cell state. This",
          " * implementation returns the value stored under",
          " * {@link mxConstants.STYLE_INDICATOR_COLOR} in the cell style.",
          " *",
          " * @param state {@link mxCellState} whose indicator color should be",
          " * returned.",
          " */"
        ]
      ],
      "getIndicatorGradientColor": [
        "getIndicatorGradientColor(state: mxCellState): string;",
        [
          "/**",
          " * Returns the indicator gradient color for the given cell state. This",
          " * implementation returns the value stored under",
          " * {@link mxConstants.STYLE_INDICATOR_GRADIENTCOLOR} in the cell style.",
          " *",
          " * @param state {@link mxCellState} whose indicator gradient color should be",
          " * returned.",
          " */"
        ]
      ],
      "getIndicatorShape": [
        "getIndicatorShape(state: mxCellState): any;",
        [
          "/**",
          " * Returns the indicator shape for the given cell state. This",
          " * implementation returns the value stored under",
          " * {@link mxConstants.STYLE_INDICATOR_SHAPE} in the cell style.",
          " *",
          " * @param state {@link mxCellState} whose indicator shape should be returned.",
          " */"
        ]
      ],
      "getIndicatorImage": [
        "getIndicatorImage(state: mxCellState): any;",
        [
          "/**",
          " * Returns the indicator image for the given cell state. This",
          " * implementation returns the value stored under",
          " * {@link mxConstants.STYLE_INDICATOR_IMAGE} in the cell style.",
          " *",
          " * @param state {@link mxCellState} whose indicator image should be returned.",
          " */"
        ]
      ],
      "getBorder": [
        "getBorder(): number;",
        [
          "/**",
          " * Returns the value of {@link border}.",
          " */"
        ]
      ],
      "setBorder": [
        "setBorder(value: number): void;",
        [
          "/**",
          " * Sets the value of {@link border}.",
          " *",
          " * @param value Positive integer that represents the border to be used.",
          " */"
        ]
      ],
      "isSwimlane": [
        "isSwimlane(cell: mxCell, ignoreState?: boolean): boolean;",
        [
          "/**",
          " * Returns true if the given cell is a swimlane in the graph. A swimlane is",
          " * a container cell with some specific behaviour. This implementation",
          " * checks if the shape associated with the given cell is a {@link mxSwimlane}.",
          " *",
          " * @param cell {@link mxCell} to be checked.",
          " * @param ignoreState Optional boolean that specifies if the cell state should be ignored.",
          " */"
        ]
      ],
      "isResizeContainer": [
        "isResizeContainer(): boolean;",
        [
          "/**",
          " * Returns {@link resizeContainer}.",
          " */"
        ]
      ],
      "setResizeContainer": [
        "setResizeContainer(value: boolean): void;",
        [
          "/**",
          " * Sets {@link resizeContainer}.",
          " *",
          " * @param value Boolean indicating if the container should be resized.",
          " */"
        ]
      ],
      "isEnabled": [
        "isEnabled(): boolean;",
        [
          "/**",
          " * Returns true if the graph is {@link enabled}.",
          " */"
        ]
      ],
      "setEnabled": [
        "setEnabled(value: boolean): void;",
        [
          "/**",
          " * Specifies if the graph should allow any interactions. This",
          " * implementation updates {@link enabled}.",
          " *",
          " * @param value Boolean indicating if the graph should be enabled.",
          " */"
        ]
      ],
      "isEscapeEnabled": [
        "isEscapeEnabled(): boolean;",
        [
          "/**",
          " * Returns {@link escapeEnabled}.",
          " */"
        ]
      ],
      "setEscapeEnabled": [
        "setEscapeEnabled(value: boolean): void;",
        [
          "/**",
          " * Sets {@link escapeEnabled}.",
          " *",
          " * @param enabled Boolean indicating if escape should be enabled.",
          " */"
        ]
      ],
      "isInvokesStopCellEditing": [
        "isInvokesStopCellEditing(): boolean;",
        [
          "/**",
          " * Returns {@link invokesStopCellEditing}.",
          " */"
        ]
      ],
      "setInvokesStopCellEditing": [
        "setInvokesStopCellEditing(value: boolean): void;",
        [
          "/**",
          " * Sets {@link invokesStopCellEditing}.",
          " */"
        ]
      ],
      "isEnterStopsCellEditing": [
        "isEnterStopsCellEditing(): boolean;",
        [
          "/**",
          " * Returns {@link enterStopsCellEditing}.",
          " */"
        ]
      ],
      "setEnterStopsCellEditing": [
        "setEnterStopsCellEditing(value: boolean): void;",
        [
          "/**",
          " * Sets {@link enterStopsCellEditing}.",
          " */"
        ]
      ],
      "isCellLocked": [
        "isCellLocked(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell may not be moved, sized, bended,",
          " * disconnected, edited or selected. This implementation returns true for",
          " * all vertices with a relative geometry if {@link locked} is false.",
          " *",
          " * @param cell {@link mxCell} whose locked state should be returned.",
          " */"
        ]
      ],
      "isCellsLocked": [
        "isCellsLocked(): boolean;",
        [
          "/**",
          " * Returns true if the given cell may not be moved, sized, bended,",
          " * disconnected, edited or selected. This implementation returns true for",
          " * all vertices with a relative geometry if {@link locked} is false.",
          " *",
          " * @param cell {@link mxCell} whose locked state should be returned.",
          " */"
        ]
      ],
      "setCellsLocked": [
        "setCellsLocked(value: boolean): void;",
        [
          "/**",
          " * Sets if any cell may be moved, sized, bended, disconnected, edited or",
          " * selected.",
          " *",
          " * @param value Boolean that defines the new value for {@link cellsLocked}.",
          " */"
        ]
      ],
      "getCloneableCells": [
        "getCloneableCells(cells: mxCell[]): mxCell[];",
        [
          "/**",
          " * Returns the cells which may be exported in the given array of cells.",
          " */"
        ]
      ],
      "isCellCloneable": [
        "isCellCloneable(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is cloneable. This implementation returns",
          " * {@link isCellsCloneable} for all cells unless a cell style specifies",
          " * {@link mxConstants.STYLE_CLONEABLE} to be 0.",
          " *",
          " * @param cell Optional {@link mxCell} whose cloneable state should be returned.",
          " */"
        ]
      ],
      "isCellsCloneable": [
        "isCellsCloneable(): boolean;",
        [
          "/**",
          " * Returns {@link cellsCloneable}, that is, if the graph allows cloning of cells",
          " * by using control-drag.",
          " */"
        ]
      ],
      "setCellsCloneable": [
        "setCellsCloneable(value: boolean): void;",
        [
          "/**",
          " * Specifies if the graph should allow cloning of cells by holding down the",
          " * control key while cells are being moved. This implementation updates",
          " * {@link cellsCloneable}.",
          " *",
          " * @param value Boolean indicating if the graph should be cloneable.",
          " */"
        ]
      ],
      "getExportableCells": [
        "getExportableCells(cells: mxCell[]): mxCell[];",
        [
          "/**",
          " * Returns the cells which may be exported in the given array of cells.",
          " */"
        ]
      ],
      "canExportCell": [
        "canExportCell(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell may be exported to the clipboard. This",
          " * implementation returns {@link exportEnabled} for all cells.",
          " *",
          " * @param cell {@link mxCell} that represents the cell to be exported.",
          " */"
        ]
      ],
      "getImportableCells": [
        "getImportableCells(cells: mxCell[]): mxCell[];",
        [
          "/**",
          " * Returns the cells which may be imported in the given array of cells.",
          " */"
        ]
      ],
      "canImportCell": [
        "canImportCell(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell may be imported from the clipboard.",
          " * This implementation returns {@link importEnabled} for all cells.",
          " *",
          " * @param cell {@link mxCell} that represents the cell to be imported.",
          " */"
        ]
      ],
      "isCellSelectable": [
        "isCellSelectable(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is selectable. This implementation",
          " * returns {@link cellsSelectable}.",
          " *",
          " * To add a new style for making cells (un)selectable, use the following code.",
          " *",
          " * ```javascript",
          " * isCellSelectable = function(cell)",
          " * {",
          " *   var style = this.getCurrentCellStyle(cell);",
          " *",
          " *   return this.isCellsSelectable() && !this.isCellLocked(cell) && style.selectable != 0;",
          " * };",
          " * ```",
          " *",
          " * You can then use the new style as shown in this example.",
          " *",
          " * ```javascript",
          " * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'selectable=0');",
          " * ```",
          " *",
          " * @param cell {@link mxCell} whose selectable state should be returned.",
          " */"
        ]
      ],
      "isCellsSelectable": [
        "isCellsSelectable(): boolean;",
        [
          "/**",
          " * Returns {@link cellsSelectable}.",
          " */"
        ]
      ],
      "setCellsSelectable": [
        "setCellsSelectable(value: boolean): void;",
        [
          "/**",
          " * Sets {@link cellsSelectable}.",
          " */"
        ]
      ],
      "getDeletableCells": [
        "getDeletableCells(cells: mxCell[]): mxCell[];",
        [
          "/**",
          " * Returns the cells which may be exported in the given array of cells.",
          " */"
        ]
      ],
      "isCellDeletable": [
        "isCellDeletable(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is moveable. This returns",
          " * {@link cellsDeletable} for all given cells if a cells style does not specify",
          " * {@link 'deletable'} to be 0.",
          " *",
          " * @param cell {@link mxCell} whose deletable state should be returned.",
          " */"
        ]
      ],
      "isCellsDeletable": [
        "isCellsDeletable(): boolean;",
        [
          "/**",
          " * Returns {@link cellsDeletable}.",
          " */"
        ]
      ],
      "setCellsDeletable": [
        "setCellsDeletable(value: boolean): void;",
        [
          "/**",
          " * Sets {@link cellsDeletable}.",
          " *",
          " * @param value Boolean indicating if the graph should allow deletion of cells.",
          " */"
        ]
      ],
      "isLabelMovable": [
        "isLabelMovable(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given edges's label is moveable. This returns",
          " * {@link movable} for all given cells if {@link isLocked} does not return true",
          " * for the given cell.",
          " *",
          " * @param cell {@link mxCell} whose label should be moved.",
          " */"
        ]
      ],
      "isCellRotatable": [
        "isCellRotatable(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is rotatable. This returns true for the given",
          " * cell if its style does not specify {@link 'rotatable'} to be 0.",
          " *",
          " * @param cell {@link mxCell} whose rotatable state should be returned.",
          " */"
        ]
      ],
      "getMovableCells": [
        "getMovableCells(cells: mxCell[]): mxCell[];",
        [
          "/**",
          " * Returns the cells which are movable in the given array of cells.",
          " */"
        ]
      ],
      "isCellMovable": [
        "isCellMovable(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is moveable. This returns {@link cellsMovable}",
          " * for all given cells if {@link isCellLocked} does not return true for the given",
          " * cell and its style does not specify {@link 'movable'} to be 0.",
          " *",
          " * @param cell {@link mxCell} whose movable state should be returned.",
          " */"
        ]
      ],
      "isCellsMovable": [
        "isCellsMovable(): boolean;",
        [
          "/**",
          " * Returns {@link cellsMovable}.",
          " */"
        ]
      ],
      "setCellsMovable": [
        "setCellsMovable(value: boolean): void;",
        [
          "/**",
          " * Specifies if the graph should allow moving of cells. This implementation",
          " * updates {@link cellsMsovable}.",
          " *",
          " * @param value Boolean indicating if the graph should allow moving of cells.",
          " */"
        ]
      ],
      "isGridEnabled": [
        "isGridEnabled(): boolean;",
        [
          "/**",
          " * Returns {@link gridEnabled} as a boolean.",
          " */"
        ]
      ],
      "setGridEnabled": [
        "setGridEnabled(value: boolean): void;",
        [
          "/**",
          " * Specifies if the grid should be enabled.",
          " *",
          " * @param value Boolean indicating if the grid should be enabled.",
          " */"
        ]
      ],
      "isPortsEnabled": [
        "isPortsEnabled(): boolean;",
        [
          "/**",
          " * Returns {@link portsEnabled} as a boolean.",
          " */"
        ]
      ],
      "setPortsEnabled": [
        "setPortsEnabled(value: boolean): void;",
        [
          "/**",
          " * Specifies if the ports should be enabled.",
          " *",
          " * @param value Boolean indicating if the ports should be enabled.",
          " */"
        ]
      ],
      "getGridSize": [
        "getGridSize(): number;",
        [
          "/**",
          " * Returns {@link gridSize}.",
          " */"
        ]
      ],
      "setGridSize": [
        "setGridSize(value: number): void;",
        [
          "/**",
          " * Sets {@link gridSize}.",
          " */"
        ]
      ],
      "getTolerance": [
        "getTolerance(): number;",
        [
          "/**",
          " * Returns {@link tolerance}.",
          " */"
        ]
      ],
      "setTolerance": [
        "setTolerance(value: number): void;",
        [
          "/**",
          " * Sets {@link tolerance}.",
          " */"
        ]
      ],
      "isVertexLabelsMovable": [
        "isVertexLabelsMovable(): boolean;",
        [
          "/**",
          " * Returns {@link vertexLabelsMovable}.",
          " */"
        ]
      ],
      "setVertexLabelsMovable": [
        "setVertexLabelsMovable(value: boolean): void;",
        [
          "/**",
          " * Sets {@link vertexLabelsMovable}.",
          " */"
        ]
      ],
      "isEdgeLabelsMovable": [
        "isEdgeLabelsMovable(): boolean;",
        [
          "/**",
          " * Returns {@link edgeLabelsMovable}.",
          " */"
        ]
      ],
      "setEdgeLabelsMovable": [
        "setEdgeLabelsMovable(value: boolean): void;",
        [
          "/**",
          " * Sets {@link edgeLabelsMovable}.",
          " */"
        ]
      ],
      "isSwimlaneNesting": [
        "isSwimlaneNesting(): boolean;",
        [
          "/**",
          " * Returns {@link swimlaneNesting} as a boolean.",
          " */"
        ]
      ],
      "setSwimlaneNesting": [
        "setSwimlaneNesting(value: boolean): void;",
        [
          "/**",
          " * Specifies if swimlanes can be nested by drag and drop. This is only",
          " * taken into account if dropEnabled is true.",
          " *",
          " * @param value Boolean indicating if swimlanes can be nested.",
          " */"
        ]
      ],
      "isSwimlaneSelectionEnabled": [
        "isSwimlaneSelectionEnabled(): boolean;",
        [
          "/**",
          " * Returns {@link swimlaneSelectionEnabled} as a boolean.",
          " */"
        ]
      ],
      "setSwimlaneSelectionEnabled": [
        "setSwimlaneSelectionEnabled(value: boolean): void;",
        [
          "/**",
          " * Specifies if swimlanes should be selected if the mouse is released",
          " * over their content area.",
          " *",
          " * @param value Boolean indicating if swimlanes content areas",
          " * should be selected when the mouse is released over them.",
          " */"
        ]
      ],
      "isMultigraph": [
        "isMultigraph(): boolean;",
        [
          "/**",
          " * Returns {@link multigraph} as a boolean.",
          " */"
        ]
      ],
      "setMultigraph": [
        "setMultigraph(value: boolean): void;",
        [
          "/**",
          " * Specifies if the graph should allow multiple connections between the",
          " * same pair of vertices.",
          " *",
          " * @param value Boolean indicating if the graph allows multiple connections",
          " * between the same pair of vertices.",
          " */"
        ]
      ],
      "isAllowLoops": [
        "isAllowLoops(): boolean;",
        [
          "/**",
          " * Returns {@link allowLoops} as a boolean.",
          " */"
        ]
      ],
      "setAllowDanglingEdges": [
        "setAllowDanglingEdges(value: boolean): void;",
        [
          "/**",
          " * Specifies if dangling edges are allowed, that is, if edges are allowed",
          " * that do not have a source and/or target terminal defined.",
          " *",
          " * @param value Boolean indicating if dangling edges are allowed.",
          " */"
        ]
      ],
      "isAllowDanglingEdges": [
        "isAllowDanglingEdges(): boolean;",
        [
          "/**",
          " * Returns {@link allowDanglingEdges} as a boolean.",
          " */"
        ]
      ],
      "setConnectableEdges": [
        "setConnectableEdges(value: boolean): void;",
        [
          "/**",
          " * Specifies if edges should be connectable.",
          " *",
          " * @param value Boolean indicating if edges should be connectable.",
          " */"
        ]
      ],
      "isConnectableEdges": [
        "isConnectableEdges(): boolean;",
        [
          "/**",
          " * Returns {@link connectableEdges} as a boolean.",
          " */"
        ]
      ],
      "setCloneInvalidEdges": [
        "setCloneInvalidEdges(value: boolean): void;",
        [
          "/**",
          " * Specifies if edges should be inserted when cloned but not valid wrt.",
          " * {@link getEdgeValidationError}. If false such edges will be silently ignored.",
          " *",
          " * @param value Boolean indicating if cloned invalid edges should be",
          " * inserted into the graph or ignored.",
          " */"
        ]
      ],
      "isCloneInvalidEdges": [
        "isCloneInvalidEdges(): boolean;",
        [
          "/**",
          " * Returns {@link cloneInvalidEdges} as a boolean.",
          " */"
        ]
      ],
      "setAllowLoops": [
        "setAllowLoops(value: boolean): void;",
        [
          "/**",
          " * Specifies if loops are allowed.",
          " *",
          " * @param value Boolean indicating if loops are allowed.",
          " */"
        ]
      ],
      "isDisconnectOnMove": [
        "isDisconnectOnMove(): boolean;",
        [
          "/**",
          " * Returns {@link disconnectOnMove} as a boolean.",
          " */"
        ]
      ],
      "setDisconnectOnMove": [
        "setDisconnectOnMove(value: boolean): void;",
        [
          "/**",
          " * Specifies if edges should be disconnected when moved. (Note: Cloned",
          " * edges are always disconnected.)",
          " *",
          " * @param value Boolean indicating if edges should be disconnected",
          " * when moved.",
          " */"
        ]
      ],
      "isDropEnabled": [
        "isDropEnabled(): boolean;",
        [
          "/**",
          " * Returns {@link dropEnabled} as a boolean.",
          " */"
        ]
      ],
      "setDropEnabled": [
        "setDropEnabled(value: boolean): void;",
        [
          "/**",
          " * Specifies if the graph should allow dropping of cells onto or into other",
          " * cells.",
          " *",
          " * @param dropEnabled Boolean indicating if the graph should allow dropping",
          " * of cells into other cells.",
          " */"
        ]
      ],
      "isSplitEnabled": [
        "isSplitEnabled(): boolean;",
        [
          "/**",
          " * Returns {@link splitEnabled} as a boolean.",
          " */"
        ]
      ],
      "setSplitEnabled": [
        "setSplitEnabled(value: boolean): void;",
        [
          "/**",
          " * Specifies if the graph should allow dropping of cells onto or into other",
          " * cells.",
          " *",
          " * @param dropEnabled Boolean indicating if the graph should allow dropping",
          " * of cells into other cells.",
          " */"
        ]
      ],
      "isCellResizable": [
        "isCellResizable(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is resizable. This returns",
          " * {@link cellsResizable} for all given cells if {@link isCellLocked} does not return",
          " * true for the given cell and its style does not specify",
          " * {@link 'resizable'} to be 0.",
          " *",
          " * @param cell {@link mxCell} whose resizable state should be returned.",
          " */"
        ]
      ],
      "isCellsResizable": [
        "isCellsResizable(): boolean;",
        [
          "/**",
          " * Returns {@link cellsResizable}.",
          " */"
        ]
      ],
      "setCellsResizable": [
        "setCellsResizable(value: boolean): void;",
        [
          "/**",
          " * Specifies if the graph should allow resizing of cells. This",
          " * implementation updates {@link cellsResizable}.",
          " *",
          " * @param value Boolean indicating if the graph should allow resizing of",
          " * cells.",
          " */"
        ]
      ],
      "isTerminalPointMovable": [
        "isTerminalPointMovable(cell: mxCell, source?: boolean): boolean;",
        [
          "/**",
          " * Returns true if the given terminal point is movable. This is independent",
          " * from {@link isCellConnectable} and {@link isCellDisconnectable} and controls if terminal",
          " * points can be moved in the graph if the edge is not connected. Note that it",
          " * is required for this to return true to connect unconnected edges. This",
          " * implementation returns true.",
          " *",
          " * @param cell {@link mxCell} whose terminal point should be moved.",
          " * @param source Boolean indicating if the source or target terminal should be moved.",
          " */"
        ]
      ],
      "isCellBendable": [
        "isCellBendable(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is bendable. This returns {@link cellsBendable}",
          " * for all given cells if {@link isLocked} does not return true for the given",
          " * cell and its style does not specify {@link mxConstants.STYLE_BENDABLE} to be 0.",
          " *",
          " * @param cell {@link mxCell} whose bendable state should be returned.",
          " */"
        ]
      ],
      "isCellsBendable": [
        "isCellsBendable(): boolean;",
        [
          "/**",
          " * Returns {@link cellsBenadable}.",
          " */"
        ]
      ],
      "setCellsBendable": [
        "setCellsBendable(value: boolean): void;",
        [
          "/**",
          " * Specifies if the graph should allow bending of edges. This",
          " * implementation updates {@link bendable}.",
          " *",
          " * @param value Boolean indicating if the graph should allow bending of",
          " * edges.",
          " */"
        ]
      ],
      "isCellEditable": [
        "isCellEditable(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is editable. This returns {@link cellsEditable} for",
          " * all given cells if {@link isCellLocked} does not return true for the given cell",
          " * and its style does not specify {@link 'editable'} to be 0.",
          " *",
          " * @param cell {@link mxCell} whose editable state should be returned.",
          " */"
        ]
      ],
      "isCellsEditable": [
        "isCellsEditable(): boolean;",
        [
          "/**",
          " * Returns {@link cellsEditable}.",
          " */"
        ]
      ],
      "setCellsEditable": [
        "setCellsEditable(value: boolean): void;",
        [
          "/**",
          " * Specifies if the graph should allow in-place editing for cell labels.",
          " * This implementation updates {@link cellsEditable}.",
          " *",
          " * @param value Boolean indicating if the graph should allow in-place",
          " * editing.",
          " */"
        ]
      ],
      "isCellDisconnectable": [
        "isCellDisconnectable(cell: mxCell, terminal: mxCell, source?: boolean): boolean;",
        [
          "/**",
          " * Returns true if the given cell is disconnectable from the source or",
          " * target terminal. This returns {@link isCellsDisconnectable} for all given",
          " * cells if {@link isCellLocked} does not return true for the given cell.",
          " *",
          " * @param cell {@link mxCell} whose disconnectable state should be returned.",
          " * @param terminal {@link mxCell} that represents the source or target terminal.",
          " * @param source Boolean indicating if the source or target terminal is to be",
          " * disconnected.",
          " */"
        ]
      ],
      "isCellsDisconnectable": [
        "isCellsDisconnectable(): boolean;",
        [
          "/**",
          " * Returns {@link cellsDisconnectable}.",
          " */"
        ]
      ],
      "setCellsDisconnectable": [
        "setCellsDisconnectable(value: boolean): void;",
        [
          "/**",
          " * Sets {@link cellsDisconnectable}.",
          " */"
        ]
      ],
      "isValidSource": [
        "isValidSource(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is a valid source for new connections.",
          " * This implementation returns true for all non-null values and is",
          " * called by is called by {@link isValidConnection}.",
          " *",
          " * @param cell {@link mxCell} that represents a possible source or null.",
          " */"
        ]
      ],
      "isValidTarget": [
        "isValidTarget(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns {@link isValidSource} for the given cell. This is called by",
          " * {@link isValidConnection}.",
          " *",
          " * @param cell {@link mxCell} that represents a possible target or null.",
          " */"
        ]
      ],
      "isValidConnection": [
        "isValidConnection(source: mxCell, target: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given target cell is a valid target for source.",
          " * This is a boolean implementation for not allowing connections between",
          " * certain pairs of vertices and is called by {@link getEdgeValidationError}.",
          " * This implementation returns true if {@link isValidSource} returns true for",
          " * the source and {@link isValidTarget} returns true for the target.",
          " *",
          " * @param source {@link mxCell} that represents the source cell.",
          " * @param target {@link mxCell} that represents the target cell.",
          " */"
        ]
      ],
      "setConnectable": [
        "setConnectable(connectable: boolean): void;",
        [
          "/**",
          " * Specifies if the graph should allow new connections. This implementation",
          " * updates {@link mxConnectionHandler.enabled} in {@link connectionHandler}.",
          " *",
          " * @param connectable Boolean indicating if new connections should be allowed.",
          " */"
        ]
      ],
      "isConnectable": [
        "isConnectable(): boolean;",
        [
          "/**",
          " * Returns true if the {@link connectionHandler} is enabled.",
          " */"
        ]
      ],
      "setTooltips": [
        "setTooltips(enabled: boolean): void;",
        [
          "/**",
          " * Specifies if tooltips should be enabled. This implementation updates",
          " * {@link mxTooltipHandler.enabled} in {@link tooltipHandler}.",
          " *",
          " * @param enabled Boolean indicating if tooltips should be enabled.",
          " */"
        ]
      ],
      "setPanning": [
        "setPanning(enabled: boolean): void;",
        [
          "/**",
          " * Specifies if panning should be enabled. This implementation updates",
          " * {@link mxPanningHandler.panningEnabled} in {@link panningHandler}.",
          " *",
          " * @param enabled Boolean indicating if panning should be enabled.",
          " */"
        ]
      ],
      "isEditing": [
        "isEditing(cell?: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is currently being edited.",
          " * If no cell is specified then this returns true if any",
          " * cell is currently being edited.",
          " *",
          " * @param cell {@link mxCell} that should be checked.",
          " */"
        ]
      ],
      "isAutoSizeCell": [
        "isAutoSizeCell(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the size of the given cell should automatically be",
          " * updated after a change of the label. This implementation returns",
          " * {@link autoSizeCells} or checks if the cell style does specify",
          " * {@link 'autoSize'} to be 1.",
          " *",
          " * @param cell {@link mxCell} that should be resized.",
          " */"
        ]
      ],
      "isAutoSizeCells": [
        "isAutoSizeCells(): boolean;",
        [
          "/**",
          " * Returns {@link autoSizeCells}.",
          " */"
        ]
      ],
      "setAutoSizeCells": [
        "setAutoSizeCells(value: boolean): void;",
        [
          "/**",
          " * Specifies if cell sizes should be automatically updated after a label",
          " * change. This implementation sets {@link autoSizeCells} to the given parameter.",
          " * To update the size of cells when the cells are added, set",
          " * {@link autoSizeCellsOnAdd} to true.",
          " *",
          " * @param value Boolean indicating if cells should be resized",
          " * automatically.",
          " */"
        ]
      ],
      "isExtendParent": [
        "isExtendParent(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the parent of the given cell should be extended if the",
          " * child has been resized so that it overlaps the parent. This",
          " * implementation returns {@link isExtendParents} if the cell is not an edge.",
          " *",
          " * @param cell {@link mxCell} that has been resized.",
          " */"
        ]
      ],
      "isExtendParents": [
        "isExtendParents(): boolean;",
        [
          "/**",
          " * Returns {@link extendParents}.",
          " */"
        ]
      ],
      "setExtendParents": [
        "setExtendParents(value: boolean): void;",
        [
          "/**",
          " * Sets {@link extendParents}.",
          " *",
          " * @param value New boolean value for {@link extendParents}.",
          " */"
        ]
      ],
      "isExtendParentsOnAdd": [
        "isExtendParentsOnAdd(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns {@link extendParentsOnAdd}.",
          " */"
        ]
      ],
      "setExtendParentsOnAdd": [
        "setExtendParentsOnAdd(value: boolean): void;",
        [
          "/**",
          " * Sets {@link extendParentsOnAdd}.",
          " *",
          " * @param value New boolean value for {@link extendParentsOnAdd}.",
          " */"
        ]
      ],
      "isExtendParentsOnMove": [
        "isExtendParentsOnMove(): boolean;",
        [
          "/**",
          " * Returns {@link extendParentsOnMove}.",
          " */"
        ]
      ],
      "setExtendParentsOnMove": [
        "setExtendParentsOnMove(value: boolean): void;",
        [
          "/**",
          " * Sets {@link extendParentsOnMove}.",
          " *",
          " * @param value New boolean value for {@link extendParentsOnAdd}.",
          " */"
        ]
      ],
      "isRecursiveResize": [
        "isRecursiveResize(state?: mxCellState): boolean;",
        [
          "/**",
          " * Returns {@link recursiveResize}.",
          " *",
          " * @param state {@link mxCellState} that is being resized.",
          " */"
        ]
      ],
      "setRecursiveResize": [
        "setRecursiveResize(value: boolean): void;",
        [
          "/**",
          " * Sets {@link recursiveResize}.",
          " *",
          " * @param value New boolean value for {@link recursiveResize}.",
          " */"
        ]
      ],
      "isConstrainChild": [
        "isConstrainChild(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell should be kept inside the bounds of its",
          " * parent according to the rules defined by {@link getOverlap} and",
          " * {@link isAllowOverlapParent}. This implementation returns false for all children",
          " * of edges and {@link isConstrainChildren} otherwise.",
          " *",
          " * @param cell {@link mxCell} that should be constrained.",
          " */"
        ]
      ],
      "isConstrainChildren": [
        "isConstrainChildren(): boolean;",
        [
          "/**",
          " * Returns {@link constrainChildren}.",
          " */"
        ]
      ],
      "setConstrainChildren": [
        "setConstrainChildren(value: boolean): void;",
        [
          "/**",
          " * Sets {@link constrainChildren}.",
          " */"
        ]
      ],
      "isConstrainRelativeChildren": [
        "isConstrainRelativeChildren(): boolean;",
        [
          "/**",
          " * Returns {@link constrainRelativeChildren}.",
          " */"
        ]
      ],
      "setConstrainRelativeChildren": [
        "setConstrainRelativeChildren(value: boolean): void;",
        [
          "/**",
          " * Sets {@link constrainRelativeChildren}.",
          " */"
        ]
      ],
      "isAllowNegativeCoordinates": [
        "isAllowNegativeCoordinates(): boolean;",
        [
          "/**",
          " * Returns {@link allowNegativeCoordinates}.",
          " */"
        ]
      ],
      "setAllowNegativeCoordinates": [
        "setAllowNegativeCoordinates(value: boolean): void;",
        [
          "/**",
          " * Sets {@link allowNegativeCoordinates}.",
          " */"
        ]
      ],
      "getOverlap": [
        "getOverlap(cell: mxCell): number;",
        [
          "/**",
          " * Returns a decimal number representing the amount of the width and height",
          " * of the given cell that is allowed to overlap its parent. A value of 0",
          " * means all children must stay inside the parent, 1 means the child is",
          " * allowed to be placed outside of the parent such that it touches one of",
          " * the parents sides. If {@link isAllowOverlapParent} returns false for the given",
          " * cell, then this method returns 0.",
          " *",
          " * @param cell {@link mxCell} for which the overlap ratio should be returned.",
          " */"
        ]
      ],
      "isAllowOverlapParent": [
        "isAllowOverlapParent(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is allowed to be placed outside of the",
          " * parents area.",
          " *",
          " * @param cell {@link mxCell} that represents the child to be checked.",
          " */"
        ]
      ],
      "getFoldableCells": [
        "getFoldableCells(cells: mxCell[], collapse: boolean): mxCell[];",
        [
          "/**",
          " * Returns the cells which are movable in the given array of cells.",
          " */"
        ]
      ],
      "isCellFoldable": [
        "isCellFoldable(cell: mxCell, collapse: boolean): boolean;",
        [
          "/**",
          " * Returns true if the given cell is foldable. This implementation",
          " * returns true if the cell has at least one child and its style",
          " * does not specify {@link mxConstants.STYLE_FOLDABLE} to be 0.",
          " *",
          " * @param cell {@link mxCell} whose foldable state should be returned.",
          " */"
        ]
      ],
      "isValidDropTarget": [
        "isValidDropTarget(cell: mxCell, cells: mxCell[], evt: Event): boolean;",
        [
          "/**",
          " * Returns true if the given cell is a valid drop target for the specified",
          " * cells. If {@link splitEnabled} is true then this returns {@link isSplitTarget} for",
          " * the given arguments else it returns true if the cell is not collapsed",
          " * and its child count is greater than 0.",
          " *",
          " * @param cell {@link mxCell} that represents the possible drop target.",
          " * @param cells {@link mxCell} that should be dropped into the target.",
          " * @param evt Mouseevent that triggered the invocation.",
          " */"
        ]
      ],
      "isSplitTarget": [
        "isSplitTarget(target: mxCell, cells: mxCell[], evt: Event): boolean;",
        [
          "/**",
          " * Returns true if the given edge may be splitted into two edges with the",
          " * given cell as a new terminal between the two.",
          " *",
          " * @param target {@link mxCell} that represents the edge to be splitted.",
          " * @param cells {@link mxCell} that should split the edge.",
          " * @param evt Mouseevent that triggered the invocation.",
          " */"
        ]
      ],
      "getDropTarget": [
        "getDropTarget(cells: mxCell[], evt: Event, cell: mxCell, clone?: boolean): mxCell;",
        [
          "/**",
          " * Returns the given cell if it is a drop target for the given cells or the",
          " * nearest ancestor that may be used as a drop target for the given cells.",
          " * If the given array contains a swimlane and {@link swimlaneNesting} is false",
          " * then this always returns null. If no cell is given, then the bottommost",
          " * swimlane at the location of the given event is returned.",
          " *",
          " * This function should only be used if {@link isDropEnabled} returns true.",
          " *",
          " * @param cells Array of {@link mxCell} which are to be dropped onto the target.",
          " * @param evt Mouseevent for the drag and drop.",
          " * @param cell {@link mxCell} that is under the mousepointer.",
          " * @param clone Optional boolean to indicate of cells will be cloned.",
          " */"
        ]
      ],
      "getDefaultParent": [
        "getDefaultParent(): mxCell;",
        [
          "/**",
          " * Returns {@link defaultParent} or {@link mxGraphView.currentRoot} or the first child",
          " * child of {@link mxGraphModel.root} if both are null. The value returned by",
          " * this function should be used as the parent for new cells (aka default",
          " * layer).",
          " */"
        ]
      ],
      "setDefaultParent": [
        "setDefaultParent(cell: mxCell): void;",
        [
          "/**",
          " * Sets the {@link defaultParent} to the given cell. Set this to null to return",
          " * the first child of the root in getDefaultParent.",
          " */"
        ]
      ],
      "getSwimlane": [
        "getSwimlane(cell: mxCell): mxCell;",
        [
          "/**",
          " * Returns the nearest ancestor of the given cell which is a swimlane, or",
          " * the given cell, if it is itself a swimlane.",
          " *",
          " * @param cell {@link mxCell} for which the ancestor swimlane should be returned.",
          " */"
        ]
      ],
      "getSwimlaneAt": [
        "getSwimlaneAt(x: number, y: number, parent: mxCell): mxCell;",
        [
          "/**",
          " * Returns the bottom-most swimlane that intersects the given point (x, y)",
          " * in the cell hierarchy that starts at the given parent.",
          " *",
          " * @param x X-coordinate of the location to be checked.",
          " * @param y Y-coordinate of the location to be checked.",
          " * @param parent {@link mxCell} that should be used as the root of the recursion.",
          " * Default is {@link defaultParent}.",
          " */"
        ]
      ],
      "getCellAt": [
        "getCellAt(x: number, y: number, parent?: mxCell, vertices?: boolean, edges?: boolean, ignoreFn?: Function): mxCell;",
        [
          "/**",
          " * Returns the bottom-most cell that intersects the given point (x, y) in",
          " * the cell hierarchy starting at the given parent. This will also return",
          " * swimlanes if the given location intersects the content area of the",
          " * swimlane. If this is not desired, then the {@link hitsSwimlaneContent} may be",
          " * used if the returned cell is a swimlane to determine if the location",
          " * is inside the content area or on the actual title of the swimlane.",
          " *",
          " * @param x X-coordinate of the location to be checked.",
          " * @param y Y-coordinate of the location to be checked.",
          " * @param parent {@link mxCell} that should be used as the root of the recursion.",
          " * Default is current root of the view or the root of the model.",
          " * @param vertices Optional boolean indicating if vertices should be returned.",
          " * Default is `true`.",
          " * @param edges Optional boolean indicating if edges should be returned. Default",
          " * is `true`.",
          " * @param ignoreFn Optional function that returns true if cell should be ignored.",
          " * The function is passed the cell state and the x and y parameter.",
          " */"
        ]
      ],
      "intersects": [
        "intersects(state: mxCellState, x: number, y: number): mxCell;",
        [
          "/**",
          " * Returns the bottom-most cell that intersects the given point (x, y) in",
          " * the cell hierarchy that starts at the given parent.",
          " *",
          " * @param state {@link mxCellState} that represents the cell state.",
          " * @param x X-coordinate of the location to be checked.",
          " * @param y Y-coordinate of the location to be checked.",
          " */"
        ]
      ],
      "hitsSwimlaneContent": [
        "hitsSwimlaneContent(swimlane: mxCell, x: number, y: number): boolean;",
        [
          "/**",
          " * Returns true if the given coordinate pair is inside the content",
          " * are of the given swimlane.",
          " *",
          " * @param swimlane {@link mxCell} that specifies the swimlane.",
          " * @param x X-coordinate of the mouse event.",
          " * @param y Y-coordinate of the mouse event.",
          " */"
        ]
      ],
      "getChildVertices": [
        "getChildVertices(parent: mxCell): mxCell[];",
        [
          "/**",
          " * Returns the visible child vertices of the given parent.",
          " *",
          " * @param parent {@link mxCell} whose children should be returned.",
          " */"
        ]
      ],
      "getChildEdges": [
        "getChildEdges(parent: mxCell): mxCell[];",
        [
          "/**",
          " * Returns the visible child edges of the given parent.",
          " *",
          " * @param parent {@link mxCell} whose child vertices should be returned.",
          " */"
        ]
      ],
      "getChildCells": [
        "getChildCells(parent: mxCell, vertices?: boolean, edges?: boolean): mxCell[];",
        [
          "/**",
          " * Returns the visible child vertices or edges in the given parent. If",
          " * vertices and edges is false, then all children are returned.",
          " *",
          " * @param parent {@link mxCell} whose children should be returned.",
          " * @param vertices Optional boolean that specifies if child vertices should",
          " * be returned. Default is `false`.",
          " * @param edges Optional boolean that specifies if child edges should",
          " * be returned. Default is `false`.",
          " */"
        ]
      ],
      "getConnections": [
        "getConnections(cell: mxCell, parent: mxCell): mxCell[];",
        [
          "/**",
          " * Returns all visible edges connected to the given cell without loops.",
          " *",
          " * @param cell {@link mxCell} whose connections should be returned.",
          " * @param parent Optional parent of the opposite end for a connection to be",
          " * returned.",
          " */"
        ]
      ],
      "getIncomingEdges": [
        "getIncomingEdges(cell: mxCell, parent: mxCell): mxCell[];",
        [
          "/**",
          " * Returns the visible incoming edges for the given cell. If the optional",
          " * parent argument is specified, then only child edges of the given parent",
          " * are returned.",
          " *",
          " * @param cell {@link mxCell} whose incoming edges should be returned.",
          " * @param parent Optional parent of the opposite end for an edge to be",
          " * returned.",
          " */"
        ]
      ],
      "getOutgoingEdges": [
        "getOutgoingEdges(cell: mxCell, parent?: mxCell): mxCell[];",
        [
          "/**",
          " * Returns the visible outgoing edges for the given cell. If the optional",
          " * parent argument is specified, then only child edges of the given parent",
          " * are returned.",
          " *",
          " * @param cell {@link mxCell} whose outgoing edges should be returned.",
          " * @param parent Optional parent of the opposite end for an edge to be",
          " * returned.",
          " */"
        ]
      ],
      "isValidAncestor": [
        "isValidAncestor(cell: mxCell, parent: mxCell, recurse?: boolean): boolean;",
        [
          "/**",
          " * Returns whether or not the specified parent is a valid",
          " * ancestor of the specified cell, either direct or indirectly",
          " * based on whether ancestor recursion is enabled.",
          " *",
          " * @param cell {@link mxCell} the possible child cell",
          " * @param parent {@link mxCell} the possible parent cell",
          " * @param recurse boolean whether or not to recurse the child ancestors",
          " */"
        ]
      ],
      "getOpposites": [
        "getOpposites(edges: mxCell[], terminal: mxCellState, sources?: boolean, targets?: boolean): mxCellState[];",
        [
          "/**",
          " * Returns all distinct visible opposite cells for the specified terminal",
          " * on the given edges.",
          " *",
          " * @param edges Array of {@link mxCell} that contains the edges whose opposite",
          " * terminals should be returned.",
          " * @param terminal Terminal that specifies the end whose opposite should be",
          " * returned.",
          " * @param sources Optional boolean that specifies if source terminals should be",
          " * included in the result. Default is `true`.",
          " * @param targets Optional boolean that specifies if targer terminals should be",
          " * included in the result. Default is `true`.",
          " */"
        ]
      ],
      "getEdgesBetween": [
        "getEdgesBetween(source: mxCell, target: mxCell, directed?: boolean): mxCell[];",
        [
          "/**",
          " * Returns the edges between the given source and target. This takes into",
          " * account collapsed and invisible cells and returns the connected edges",
          " * as displayed on the screen.",
          " *",
          " * source -",
          " * target -",
          " * directed -",
          " */"
        ]
      ],
      "getPointForEvent": [
        "getPointForEvent(evt: MouseEvent, addOffset: boolean): mxPoint;",
        [
          "/**",
          " * Returns an {@link mxPoint} representing the given event in the unscaled,",
          " * non-translated coordinate space of {@link container} and applies the grid.",
          " *",
          " * @param evt Mousevent that contains the mouse pointer location.",
          " * @param addOffset Optional boolean that specifies if the position should be",
          " * offset by half of the {@link gridSize}. Default is `true`.",
          " */"
        ]
      ],
      "getCells": [
        "getCells(x: number, y: number, width: number, height: number, parent?: mxCell, result?: mxCell[]): mxCell[];",
        [
          "/**",
          " * Returns the child vertices and edges of the given parent that are contained",
          " * in the given rectangle. The result is added to the optional result array,",
          " * which is returned. If no result array is specified then a new array is",
          " * created and returned.",
          " *",
          " * @param x X-coordinate of the rectangle.",
          " * @param y Y-coordinate of the rectangle.",
          " * @param width Width of the rectangle.",
          " * @param height Height of the rectangle.",
          " * @param parent {@link mxCell} that should be used as the root of the recursion.",
          " * Default is current root of the view or the root of the model.",
          " * @param result Optional array to store the result in.",
          " */"
        ]
      ],
      "findTreeRoots": [
        "findTreeRoots(parent: mxCell, isolate?: boolean, invert?: boolean): mxCell[];",
        [
          "/**",
          " * Returns all children in the given parent which do not have incoming",
          " * edges. If the result is empty then the with the greatest difference",
          " * between incoming and outgoing edges is returned.",
          " *",
          " * @param parent {@link mxCell} whose children should be checked.",
          " * @param isolate Optional boolean that specifies if edges should be ignored if",
          " * the opposite end is not a child of the given parent cell. Default is",
          " * false.",
          " * @param invert Optional boolean that specifies if outgoing or incoming edges",
          " * should be counted for a tree root. If false then outgoing edges will be",
          " * counted. Default is `false`.",
          " */"
        ]
      ],
      "isCellSelected": [
        "isCellSelected(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is selected.",
          " *",
          " * @param cell {@link mxCell} for which the selection state should be returned.",
          " */"
        ]
      ],
      "isSelectionEmpty": [
        "isSelectionEmpty(): boolean;",
        [
          "/**",
          " * Returns true if the selection is empty.",
          " */"
        ]
      ],
      "clearSelection": [
        "clearSelection(): void;",
        [
          "/**",
          " * Clears the selection using {@link mxGraphSelectionModel.clear}.",
          " */"
        ]
      ],
      "getSelectionCount": [
        "getSelectionCount(): number;",
        [
          "/**",
          " * Returns the number of selected cells.",
          " */"
        ]
      ],
      "getSelectionCell": [
        "getSelectionCell(): mxCell;",
        [
          "/**",
          " * Returns the first cell from the array of selected {@link mxCell}.",
          " */"
        ]
      ],
      "getSelectionCells": [
        "getSelectionCells(): mxCell[];",
        [
          "/**",
          " * Returns the array of selected {@link mxCell}.",
          " */"
        ]
      ],
      "setSelectionCell": [
        "setSelectionCell(cell: mxCell): void;",
        [
          "/**",
          " * Sets the selection cell.",
          " *",
          " * @param cell {@link mxCell} to be selected.",
          " */"
        ]
      ],
      "setSelectionCells": [
        "setSelectionCells(cells: mxCell[]): void;",
        [
          "/**",
          " * Sets the selection cell.",
          " *",
          " * @param cells Array of {@link mxCell} to be selected.",
          " */"
        ]
      ],
      "addSelectionCell": [
        "addSelectionCell(cell: mxCell): void;",
        [
          "/**",
          " * Adds the given cell to the selection.",
          " *",
          " * @param cell {@link mxCell} to be add to the selection.",
          " */"
        ]
      ],
      "addSelectionCells": [
        "addSelectionCells(cells: mxCell[]): void;",
        [
          "/**",
          " * Adds the given cells to the selection.",
          " *",
          " * @param cells Array of {@link mxCell} to be added to the selection.",
          " */"
        ]
      ],
      "removeSelectionCell": [
        "removeSelectionCell(cell: mxCell): void;",
        [
          "/**",
          " * Removes the given cell from the selection.",
          " *",
          " * @param cell {@link mxCell} to be removed from the selection.",
          " */"
        ]
      ],
      "removeSelectionCells": [
        "removeSelectionCells(cells: mxCell[]): void;",
        [
          "/**",
          " * Removes the given cells from the selection.",
          " *",
          " * @param cells Array of {@link mxCell} to be removed from the selection.",
          " */"
        ]
      ],
      "selectRegion": [
        "selectRegion(rect: mxRectangle, evt: Event): mxCell[];",
        [
          "/**",
          " * Selects and returns the cells inside the given rectangle for the",
          " * specified event.",
          " *",
          " * @param rect {@link mxRectangle} that represents the region to be selected.",
          " * @param evt Mouseevent that triggered the selection.",
          " */"
        ]
      ],
      "selectNextCell": [
        "selectNextCell(): void;",
        [
          "/**",
          " * Selects the next cell.",
          " */"
        ]
      ],
      "selectPreviousCell": [
        "selectPreviousCell(): void;",
        [
          "/**",
          " * Selects the previous cell.",
          " */"
        ]
      ],
      "selectParentCell": [
        "selectParentCell(): void;",
        [
          "/**",
          " * Selects the parent cell.",
          " */"
        ]
      ],
      "selectChildCell": [
        "selectChildCell(): void;",
        [
          "/**",
          " * Selects the first child cell.",
          " */"
        ]
      ],
      "selectCell": [
        "selectCell(isNext?: boolean, isParent?: boolean, isChild?: boolean): void;",
        [
          "/**",
          " * Selects the next, parent, first child or previous cell, if all arguments",
          " * are false.",
          " *",
          " * @param isNext Boolean indicating if the next cell should be selected.",
          " * @param isParent Boolean indicating if the parent cell should be selected.",
          " * @param isChild Boolean indicating if the first child cell should be selected.",
          " */"
        ]
      ],
      "selectAll": [
        "selectAll(parent: mxCell, descendants?: boolean): void;",
        [
          "/**",
          " * Selects all children of the given parent cell or the children of the",
          " * default parent if no parent is specified. To select leaf vertices and/or",
          " * edges use {@link selectCells}.",
          " *",
          " * @param parent Optional {@link mxCell} whose children should be selected.",
          " * Default is {@link defaultParent}.",
          " * @param descendants Optional boolean specifying whether all descendants should be",
          " * selected. Default is `false`.",
          " */"
        ]
      ],
      "selectVertices": [
        "selectVertices(parent: mxCell, selectGroups: boolean): void;",
        [
          "/**",
          " * Select all vertices inside the given parent or the default parent.",
          " */"
        ]
      ],
      "selectEdges": [
        "selectEdges(parent: mxCell): void;",
        [
          "/**",
          " * Select all vertices inside the given parent or the default parent.",
          " */"
        ]
      ],
      "selectCells": [
        "selectCells(vertices: boolean, edges: boolean, parent?: mxCell, selectGroups?: boolean): void;",
        [
          "/**",
          " * Selects all vertices and/or edges depending on the given boolean",
          " * arguments recursively, starting at the given parent or the default",
          " * parent if no parent is specified. Use {@link selectAll} to select all cells.",
          " * For vertices, only cells with no children are selected.",
          " *",
          " * @param vertices Boolean indicating if vertices should be selected.",
          " * @param edges Boolean indicating if edges should be selected.",
          " * @param parent Optional {@link mxCell} that acts as the root of the recursion.",
          " * Default is {@link defaultParent}.",
          " * @param selectGroups Optional boolean that specifies if groups should be",
          " * selected. Default is `false`.",
          " */"
        ]
      ],
      "selectCellsForEvent": [
        "selectCellsForEvent(cells: mxCell[], evt?: MouseEvent): void;",
        [
          "/**",
          " * Selects the given cell by either adding it to the selection or",
          " * replacing the selection depending on whether the given mouse event is a",
          " * toggle event.",
          " *",
          " * @param cell {@link mxCell} to be selected.",
          " * @param evt Optional mouseevent that triggered the selection.",
          "",
          "  */",
          "selectCellForEvent(cell: mxCell, evt?: MouseEvent): void;",
          "",
          "/**",
          " * Selects the given cells by either adding them to the selection or",
          " * replacing the selection depending on whether the given mouse event is a",
          " * toggle event.",
          " *",
          " * @param cells Array of {@link mxCell} to be selected.",
          " * @param evt Optional mouseevent that triggered the selection.",
          " */"
        ]
      ],
      "createHandler": [
        "createHandler(state: mxCellState): mxVertexHandler | mxEdgeHandler;",
        [
          "/**",
          " * Creates a new handler for the given cell state. This implementation",
          " * returns a new {@link mxEdgeHandler} of the corresponding cell is an edge,",
          " * otherwise it returns an {@link mxVertexHandler}.",
          " *",
          " * @param state {@link mxCellState} whose handler should be created.",
          " */"
        ]
      ],
      "createVertexHandler": [
        "createVertexHandler(state: mxCellState): mxVertexHandler;",
        [
          "/**",
          " * Hooks to create a new {@link mxVertexHandler} for the given {@link mxCellState}.",
          " *",
          " * @param state {@link mxCellState} to create the handler for.",
          " */"
        ]
      ],
      "createEdgeHandler": [
        "createEdgeHandler(state: mxCellState, edgeStyle: any): mxEdgeHandler;",
        [
          "/**",
          " * Hooks to create a new {@link mxEdgeHandler} for the given {@link mxCellState}.",
          " *",
          " * @param state {@link mxCellState} to create the handler for.",
          " */"
        ]
      ],
      "createEdgeSegmentHandler": [
        "createEdgeSegmentHandler(state: mxCellState): mxEdgeSegmentHandler;",
        [
          "/**",
          " * Hooks to create a new {@link mxEdgeSegmentHandler} for the given {@link mxCellState}.",
          " *",
          " * @param state {@link mxCellState} to create the handler for.",
          " */"
        ]
      ],
      "createElbowEdgeHandler": [
        "createElbowEdgeHandler(state: mxCellState): mxElbowEdgeHandler;",
        [
          "/**",
          " * Hooks to create a new {@link mxElbowEdgeHandler} for the given {@link mxCellState}.",
          " *",
          " * @param state {@link mxCellState} to create the handler for.",
          " */"
        ]
      ],
      "addMouseListener": [
        "addMouseListener(listener: { [key: string]: (sender: mxEventSource, me: mxMouseEvent) => void }): void;",
        [
          "/**",
          " * Adds a listener to the graph event dispatch loop. The listener",
          " * must implement the mouseDown, mouseMove and mouseUp methods",
          " * as shown in the {@link mxMouseEvent} class.",
          " *",
          " * @param listener Listener to be added to the graph event listeners.",
          " */"
        ]
      ],
      "removeMouseListener": [
        "removeMouseListener(listener: { [key: string]: (sender: mxEventSource, me: mxMouseEvent) => void }): void;",
        [
          "/**",
          " * Removes the specified graph listener.",
          " *",
          " * @param listener Listener to be removed from the graph event listeners.",
          " */"
        ]
      ],
      "updateMouseEvent": [
        "updateMouseEvent(me: mxMouseEvent, evtName: string): mxMouseEvent;",
        [
          "/**",
          " * Sets the graphX and graphY properties if the given {@link mxMouseEvent} if",
          " * required and returned the event.",
          " *",
          " * @param me {@link mxMouseEvent} to be updated.",
          " * @param evtName Name of the mouse event.",
          " */"
        ]
      ],
      "getStateForTouchEvent": [
        "getStateForTouchEvent(evt: MouseEvent | TouchEvent): mxCellState;",
        [
          "/**",
          " * Returns the state for the given touch event.",
          " */"
        ]
      ],
      "isEventIgnored": [
        "isEventIgnored(evtName: string, me: mxMouseEvent, sender: mxEventSource): boolean;",
        [
          "/**",
          " * Returns true if the event should be ignored in {@link fireMouseEvent}.",
          " */"
        ]
      ],
      "isSyntheticEventIgnored": [
        "isSyntheticEventIgnored(evtName: string, me: mxMouseEvent, sender: mxEventSource): boolean;",
        [
          "/**",
          " * Hook for ignoring synthetic mouse events after touchend in Firefox.",
          " */"
        ]
      ],
      "isEventSourceIgnored": [
        "isEventSourceIgnored(evtName: string, me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Returns true if the event should be ignored in {@link fireMouseEvent}. This",
          " * implementation returns true for select, option and input (if not of type",
          " * checkbox, radio, button, submit or file) event sources if the event is not",
          " * a mouse event or a left mouse button press event.",
          " *",
          " * @param evtName The name of the event.",
          " * @param me {@link mxMouseEvent} that should be ignored.",
          " */"
        ]
      ],
      "getEventState": [
        "getEventState(state: mxCellState): mxCellState;",
        [
          "/**",
          " * Returns the {@link mxCellState} to be used when firing the mouse event for the",
          " * given state. This implementation returns the given state.",
          " *",
          " * {@link mxCellState} - State whose event source should be returned.",
          " */"
        ]
      ],
      "fireMouseEvent": [
        "fireMouseEvent(evtName: string, me: mxMouseEvent, sender?: mxEventSource): void;",
        [
          "/**",
          " * Dispatches the given event in the graph event dispatch loop. Possible",
          " * event names are {@link mxEvent.MOUSE_DOWN}, {@link mxEvent.MOUSE_MOVE} and",
          " * {@link mxEvent.MOUSE_UP}. All listeners are invoked for all events regardless",
          " * of the consumed state of the event.",
          " *",
          " * @param evtName String that specifies the type of event to be dispatched.",
          " * @param me {@link mxMouseEvent} to be fired.",
          " * @param sender Optional sender argument. Default is `this`.",
          " */"
        ]
      ],
      "consumeMouseEvent": [
        "consumeMouseEvent(evtName: string, me: mxMouseEvent, sender: mxEventSource): void;",
        [
          "/**",
          " * Consumes the given {@link mxMouseEvent} if it's a touchStart event.",
          " */"
        ]
      ],
      "fireGestureEvent": [
        "fireGestureEvent(evt: any, cell?: mxCell): void;",
        [
          "/**",
          " * Dispatches a {@link mxEvent.GESTURE} event. The following example will resize the",
          " * cell under the mouse based on the scale property of the native touch event.",
          " *",
          " * ```javascript",
          " * graph.addListener(mxEvent.GESTURE, function(sender, eo)",
          " * {",
          " *   var evt = eo.getProperty('event');",
          " *   var state = graph.view.getState(eo.getProperty('cell'));",
          " *",
          " *   if (graph.isEnabled() && graph.isCellResizable(state.cell) && Math.abs(1 - evt.scale) > 0.2)",
          " *   {",
          " *     var scale = graph.view.scale;",
          " *     var tr = graph.view.translate;",
          " *",
          " *     var w = state.width * evt.scale;",
          " *     var h = state.height * evt.scale;",
          " *     var x = state.x - (w - state.width) / 2;",
          " *     var y = state.y - (h - state.height) / 2;",
          " *",
          " *     var bounds = new mxRectangle(graph.snap(x / scale) - tr.x,",
          " *     \t\tgraph.snap(y / scale) - tr.y, graph.snap(w / scale), graph.snap(h / scale));",
          " *     graph.resizeCell(state.cell, bounds);",
          " *     eo.consume();",
          " *   }",
          " * });",
          " * ```",
          " *",
          " * @param evt Gestureend event that represents the gesture.",
          " * @param cell Optional {@link mxCell} associated with the gesture.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Destroys the graph and all its resources.",
          " */"
        ]
      ]
    }
  ],
  "mxPerimeter": [
    [
      "/**",
      " * @class mxPerimeter",
      " *",
      " * Provides various perimeter functions to be used in a style",
      " * as the value of {@link mxConstants.STYLE_PERIMETER}. Perimeters for",
      " * rectangle, circle, rhombus and triangle are available.",
      " *",
      " * ### Example",
      " *",
      " * @example",
      " * ```javascript",
      " * <add as=\"perimeter\">mxPerimeter.RectanglePerimeter</add>",
      " * ```",
      " *",
      " * ### Or programmatically",
      " *",
      " * @example",
      " * ```javascript",
      " * style.perimiter = mxPerimeter.RectanglePerimeter;",
      " * ```",
      " *",
      " * When adding new perimeter functions, it is recommended to use the",
      " * mxPerimeter-namespace as follows:",
      " *",
      " * @example",
      " * ```javascript",
      " * mxPerimeter.CustomPerimeter = function (bounds, vertex, next, orthogonal)",
      " * {",
      " *   var x = 0; // Calculate x-coordinate",
      " *   var y = 0; // Calculate y-coordainte",
      " *",
      " *   return new mxPoint(x, y);",
      " * }",
      " * ```",
      " *",
      " * #### The new perimeter should then be registered in the {@link mxStyleRegistry} as follows",
      " * @example",
      " * ```javascript",
      " * mxStyleRegistry.putValue('customPerimeter', mxPerimeter.CustomPerimeter);",
      " * ```",
      " *",
      " * #### The custom perimeter above can now be used in a specific vertex as follows:",
      " *",
      " * @example",
      " * ```javascript",
      " * model.setStyle(vertex, 'perimeter=customPerimeter');",
      " * ```",
      " *",
      " * Note that the key of the {@link mxStyleRegistry} entry for the function should",
      " * be used in string values, unless {@link mxGraphView.allowEval} is true, in",
      " * which case you can also use mxPerimeter.CustomPerimeter for the value in",
      " * the cell style above.",
      " *",
      " * #### Or it can be used for all vertices in the graph as follows:",
      " *",
      " * @example",
      " * ```javascript",
      " * var style = graph.getStylesheet().getDefaultVertexStyle();",
      " * style.perimiter = mxPerimeter.CustomPerimeter;",
      " * ```",
      " *",
      " * Note that the object can be used directly when programmatically setting",
      " * the value, but the key in the {@link mxStyleRegistry} should be used when",
      " * setting the value via a key, value pair in a cell style.",
      " *",
      " * The parameters are explained in {@link RectanglePerimeter}.",
      " */"
    ],
    {
      "static RectanglePerimeter": [
        "static RectanglePerimeter(bounds: mxRectangle, vertex: mxCellState, next: mxPoint, orthogonal?: boolean): mxPoint;",
        [
          "/**",
          " * Describes a rectangular perimeter for the given bounds.",
          " *",
          " * @param bounds {@link mxRectangle} that represents the absolute bounds of the",
          " * vertex.",
          " * @param vertex {@link mxCellState} that represents the vertex.",
          " * @param next {@link mxPoint} that represents the nearest neighbour point on the",
          " * given edge.",
          " * @param orthogonal Boolean that specifies if the orthogonal projection onto",
          " * the perimeter should be returned. If this is false then the intersection",
          " * of the perimeter and the line between the next and the center point is",
          " * returned.",
          " */"
        ]
      ],
      "static EllipsePerimeter": [
        "static EllipsePerimeter(bounds: mxRectangle, vertex: mxCellState, next: mxPoint, orthogonal?: boolean): mxPoint;",
        [
          "/**",
          " * Describes an elliptic perimeter. See {@link RectanglePerimeter}",
          " * for a description of the parameters.",
          " */"
        ]
      ],
      "static RhombusPerimeter": [
        "static RhombusPerimeter(bounds: mxRectangle, vertex: mxCellState, next: mxPoint, orthogonal?: boolean): mxPoint;",
        [
          "/**",
          " * Describes a rhombus (aka diamond) perimeter. See {@link RectanglePerimeter}",
          " * for a description of the parameters.",
          " */"
        ]
      ],
      "static TrianglePerimeter": [
        "static TrianglePerimeter(bounds: mxRectangle, vertex: mxCellState, next: mxPoint, orthogonal?: boolean): mxPoint;",
        [
          "/**",
          " * Describes a triangle perimeter. See {@link RectanglePerimeter}",
          " * for a description of the parameters.",
          " */"
        ]
      ],
      "static HexagonPerimeter": [
        "static HexagonPerimeter(bounds: mxRectangle, vertex: mxCellState, next: mxPoint, orthogonal?: boolean): mxPoint;",
        [
          "/**",
          " * Describes a hexagon perimeter. See {@link RectanglePerimeter}",
          " * for a description of the parameters.",
          " */"
        ]
      ]
    }
  ],
  "mxPrintPreview": [
    [
      "/**",
      " * @class mxPrintPreview",
      " *",
      " * Implements printing of a diagram across multiple pages. The following opens",
      " * a print preview for an existing graph:",
      " *",
      " * @example",
      " * ```javascript",
      " * var preview = new mxPrintPreview(graph);",
      " * preview.open();",
      " * ```",
      " *",
      " * Use {@link mxUtils.getScaleForPageCount} as follows in order to print the graph",
      " * across a given number of pages:",
      " *",
      " * @example",
      " * ```javascript",
      " * var pageCount = mxUtils.prompt('Enter page count', '1');",
      " *",
      " * if (pageCount != null)",
      " * {",
      " *   var scale = mxUtils.getScaleForPageCount(pageCount, graph);",
      " *   var preview = new mxPrintPreview(graph, scale);",
      " *   preview.open();",
      " * }",
      " * ```",
      " *",
      " * ### Additional pages",
      " *",
      " * To add additional pages before and after the output, {@link getCoverPages} and",
      " * {@link getAppendices} can be used, respectively.",
      " *",
      " * @example",
      " * ```javascript",
      " * var preview = new mxPrintPreview(graph, 1);",
      " *",
      " * preview.getCoverPages(w, h)",
      " * {",
      " *   return [this.renderPage(w, h, 0, 0, mxUtils.bind(this, function(div)",
      " *   {",
      " *     div.innerHTML = '<div style=\"position:relative;margin:4px;\">Cover Page</p>'",
      " *   }))];",
      " * };",
      " *",
      " * preview.getAppendices(w, h)",
      " * {",
      " *   return [this.renderPage(w, h, 0, 0, mxUtils.bind(this, function(div)",
      " *   {",
      " *     div.innerHTML = '<div style=\"position:relative;margin:4px;\">Appendix</p>'",
      " *   }))];",
      " * };",
      " *",
      " * preview.open();",
      " * ```",
      " *",
      " * ### CSS",
      " *",
      " * The CSS from the original page is not carried over to the print preview.",
      " * To add CSS to the page, use the css argument in the {@link open} function or",
      " * override {@link writeHead} to add the respective link tags as follows:",
      " *",
      " * @example",
      " * ```javascript",
      " * var writeHead = preview.writeHead;",
      " * preview.writeHead(doc, css)",
      " * {",
      " *   writeHead.apply(this, arguments);",
      " *   doc.writeln('<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">');",
      " * };",
      " * ```",
      " *",
      " * ### Padding",
      " *",
      " * To add a padding to the page in the preview (but not the print output), use",
      " * the following code:",
      " *",
      " * @example",
      " * ```javascript",
      " * preview.writeHead(doc)",
      " * {",
      " *   writeHead.apply(this, arguments);",
      " *",
      " *   doc.writeln('<style type=\"text/css\">');",
      " *   doc.writeln('@media screen {');",
      " *   doc.writeln('  body > div { padding-top:30px;padding-left:40px;box-sizing:content-box; }');",
      " *   doc.writeln('}');",
      " *   doc.writeln('</style>');",
      " * };",
      " * ```",
      " *",
      " * ### Headers",
      " *",
      " * Apart from setting the title argument in the mxPrintPreview constructor you",
      " * can override {@link renderPage} as follows to add a header to any page:",
      " *",
      " * @example",
      " * ```javascript",
      " * var oldRenderPage = renderPage;",
      " * renderPage(w, h, x, y, content, pageNumber)",
      " * {",
      " *   var div = oldRenderPage.apply(this, arguments);",
      " *",
      " *   var header = document.createElement('div');",
      " *   header.style.position = 'absolute';",
      " *   header.style.top = '0px';",
      " *   header.style.width = '100%';",
      " *   header.style.textAlign = 'right';",
      " *   mxUtils.write(header, 'Your header here');",
      " *   div.firstChild.appendChild(header);",
      " *",
      " *   return div;",
      " * };",
      " * ```",
      " *",
      " * The pageNumber argument contains the number of the current page, starting at",
      " * 1. To display a header on the first page only, check pageNumber and add a",
      " * vertical offset in the constructor call for the height of the header.",
      " *",
      " * ### Page Format",
      " *",
      " * For landscape printing, use {@link mxConstants.PAGE_FORMAT_A4_LANDSCAPE} as",
      " * the pageFormat in {@link mxUtils.getScaleForPageCount} and {@link mxPrintPreview}.",
      " * Keep in mind that one can not set the defaults for the print dialog",
      " * of the operating system from JavaScript so the user must manually choose",
      " * a page format that matches this setting.",
      " *",
      " * You can try passing the following CSS directive to {@link open} to set the",
      " * page format in the print dialog to landscape. However, this CSS",
      " * directive seems to be ignored in most major browsers, including IE.",
      " *",
      " * @example",
      " * ```javascript",
      " * @page {",
      " *   size: landscape;",
      " * }",
      " * ```",
      " *",
      " * Note that the print preview behaves differently in IE when used from the",
      " * filesystem or via HTTP so printing should always be tested via HTTP.",
      " *",
      " * If you are using a DOCTYPE in the source page you can override {@link getDoctype}",
      " * and provide the same DOCTYPE for the print preview if required. Here is",
      " * an example for IE8 standards mode.",
      " *",
      " * @example",
      " * ```javascript",
      " * var preview = new mxPrintPreview(graph);",
      " * preview.getDoctype()",
      " * {",
      " *   return '<!--[if IE]><meta http-equiv=\"X-UA-Compatible\" content=\"IE=5,IE=8\" ><![endif]-->';",
      " * };",
      " * preview.open();",
      " * ```",
      " */"
    ],
    {
      ");": [
        ");",
        [
          "/**",
          " * @constructor mxPrintPreview",
          " *",
          " * Constructs a new print preview for the given parameters.",
          " *",
          " * @param graph {@link mxGraph} to be previewed.",
          " * @param scale Optional scale of the output. Default is 1 / {@link mxGraph.pageScale}.",
          " * @param pageFormat {@link mxRectangle} that specifies the page format (in pixels).",
          " * @param border Border in pixels along each side of every page. Note that the",
          " * actual print function in the browser will add another border for",
          " * printing.",
          " * This should match the page format of the printer. Default uses the",
          " * {@link mxGraph.pageFormat} of the given graph.",
          " * @param x0 Optional left offset of the output. Default is 0.",
          " * @param y0 Optional top offset of the output. Default is 0.",
          " * @param borderColor Optional color of the page border. Default is no border.",
          " * Note that a border is sometimes useful to highlight the printed page",
          " * border in the print preview of the browser.",
          " * @param title Optional string that is used for the window title. Default",
          " * is 'Printer-friendly version'.",
          " * @param pageSelector Optional boolean that specifies if the page selector",
          " * should appear in the window with the print preview. Default is true.",
          " */"
        ]
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Reference to the {@link mxGraph} that should be previewed.",
          " */"
        ]
      ],
      "pageFormat": [
        "pageFormat: mxRectangle;",
        [
          "/**",
          " * Holds the {@link mxRectangle} that defines the page format.",
          " */"
        ]
      ],
      "scale": [
        "scale: number;",
        [
          "/**",
          " * Holds the scale of the print preview.",
          " */"
        ]
      ],
      "border": [
        "border: number;",
        [
          "/**",
          " * The border inset around each side of every page in the preview. This is set",
          " * to 0 if autoOrigin is false.",
          " * @default 0",
          " */"
        ]
      ],
      "marginTop": [
        "marginTop: number;",
        [
          "/**",
          " * The margin at the top of the page (number).",
          " * @default 0",
          " */"
        ]
      ],
      "marginBottom": [
        "marginBottom: number;",
        [
          "/**",
          " * The margin at the bottom of the page (number).",
          " * @default 0",
          " */"
        ]
      ],
      "x0": [
        "x0: number;",
        [
          "/**",
          " * Holds the horizontal offset of the output.",
          " */"
        ]
      ],
      "y0": [
        "y0: number;",
        [
          "/**",
          " * Holds the vertical offset of the output.",
          " */"
        ]
      ],
      "autoOrigin": [
        "autoOrigin: boolean;",
        [
          "/**",
          " * Specifies if the origin should be automatically computed based on the top,",
          " * left corner of the actual diagram contents. The required offset will be added",
          " * to {@link x0} and {@link y0} in {@link open}.",
          " * @default true",
          " */"
        ]
      ],
      "printOverlays": [
        "printOverlays: boolean;",
        [
          "/**",
          " * Specifies if overlays should be printed.",
          " * @default false",
          " */"
        ]
      ],
      "printControls": [
        "printControls: boolean;",
        [
          "/**",
          " * Specifies if controls (such as folding icons) should be printed. Default is",
          " * false.",
          " */"
        ]
      ],
      "printBackgroundImage": [
        "printBackgroundImage: boolean;",
        [
          "/**",
          " * Specifies if the background image should be printed.",
          " * @default false",
          " */"
        ]
      ],
      "backgroundColor": [
        "backgroundColor: string;",
        [
          "/**",
          " * Holds the color value for the page background color.",
          " * @default '#ffffff'",
          " */"
        ]
      ],
      "borderColor": [
        "borderColor: string;",
        [
          "/**",
          " * Holds the color value for the page border.",
          " */"
        ]
      ],
      "title": [
        "title: string;",
        [
          "/**",
          " * Holds the title of the preview window.",
          " */"
        ]
      ],
      "pageSelector": [
        "pageSelector: boolean;",
        [
          "/**",
          " * Boolean that specifies if the page selector should be",
          " * displayed.",
          " * @default true",
          " */"
        ]
      ],
      "wnd": [
        "wnd: Window;",
        [
          "/**",
          " * Reference to the preview window.",
          " */"
        ]
      ],
      "targetWindow": [
        "targetWindow: Window;",
        [
          "/**",
          " * Assign any window here to redirect the rendering in {@link open}.",
          " */"
        ]
      ],
      "pageCount": [
        "pageCount: number;",
        [
          "/**",
          " * Holds the actual number of pages in the preview.",
          " */"
        ]
      ],
      "clipping": [
        "clipping: boolean;",
        [
          "/**",
          " * Specifies is clipping should be used to avoid creating too many cell states",
          " * in large diagrams. The bounding box of the cells in the original diagram is",
          " * used if this is enabled.",
          " * @default true",
          " */"
        ]
      ],
      "getWindow": [
        "getWindow(): Window;",
        [
          "/**",
          " * Returns {@link wnd}.",
          " */"
        ]
      ],
      "getDoctype": [
        "getDoctype(): string;",
        [
          "/**",
          " * Returns the string that should go before the HTML tag in the print preview",
          " * page. This implementation returns an X-UA meta tag for IE5 in quirks mode,",
          " * IE8 in IE8 standards mode and edge in IE9 standards mode.",
          " */"
        ]
      ],
      ")": [
        "): void;",
        [
          "/**",
          " * Adds a graph fragment to the given div.",
          " *",
          " * @param dx Horizontal translation for the diagram.",
          " * @param dy Vertical translation for the diagram.",
          " * @param scale Scale for the diagram.",
          " * @param pageNumber Number of the page to be rendered.",
          " * @param div Div that contains the output.",
          " * @param clip Contains the clipping rectangle as an {@link mxRectangle}.",
          " */"
        ]
      ],
      "open": [
        "open(css?: string, targetWindow?: Window, forcePageBreaks?: boolean, keepOpen?: boolean): Window;",
        [
          "/**",
          " * Shows the print preview window. The window is created here if it does",
          " * not exist.",
          " *",
          " * @param css Optional CSS string to be used in the head section.",
          " * @param targetWindow Optional window that should be used for rendering. If",
          " * this is specified then no HEAD tag, CSS and BODY tag will be written.",
          " */"
        ]
      ],
      "addPageBreak": [
        "addPageBreak(doc: Document): void;",
        [
          "/**",
          " * Adds a page break to the given document.",
          " */"
        ]
      ],
      "closeDocument": [
        "closeDocument(): void;",
        [
          "/**",
          " * Writes the closing tags for body and page after calling {@link writePostfix}.",
          " */"
        ]
      ],
      "writeHead": [
        "writeHead(doc: Document, css: string): void;",
        [
          "/**",
          " * Writes the HEAD section into the given document, without the opening",
          " * and closing HEAD tags.",
          " */"
        ]
      ],
      "writePostfix": [
        "writePostfix(doc: Document): any;",
        [
          "/**",
          " * Called before closing the body of the page. This implementation is empty.",
          " */"
        ]
      ],
      "createPageSelector": [
        "createPageSelector(vpages: number, hpages: number): HTMLTableElement;",
        [
          "/**",
          " * Creates the page selector table.",
          " */"
        ]
      ],
      "renderPage": [
        "renderPage(w: number, h: number, dx?: number, dy?: number, content?: Function, pageNumber?: number): HTMLDivElement;",
        [
          "/**",
          " * Creates a DIV that prints a single page of the given",
          " * graph using the given scale and returns the DIV that",
          " * represents the page.",
          " *",
          " * @param w Width of the page in pixels.",
          " * @param h Height of the page in pixels.",
          " * @param dx Optional horizontal page offset in pixels (used internally).",
          " * @param dy Optional vertical page offset in pixels (used internally).",
          " * @param content Callback that adds the HTML content to the inner div of a page.",
          " * Takes the inner div as the argument.",
          " * @param pageNumber Integer representing the page number.",
          " */"
        ]
      ],
      "getRoot": [
        "getRoot(): mxCell;",
        [
          "/**",
          " * Returns the root cell for painting the graph.",
          " */"
        ]
      ],
      "getLinkForCellState": [
        "getLinkForCellState(state: mxCellState): string;",
        [
          "/**",
          " * Returns the link for the given cell state. This returns null.",
          " */"
        ]
      ],
      "insertBackgroundImage": [
        "insertBackgroundImage(div: HTMLDivElement, dx: number, dy: number): void;",
        [
          "/**",
          " * Inserts the background image into the given div.",
          " */"
        ]
      ],
      "getCoverPages": [
        "getCoverPages(): any;",
        [
          "/**",
          " * Returns the pages to be added before the print output. This returns null.",
          " */"
        ]
      ],
      "getAppendices": [
        "getAppendices(): any;",
        [
          "/**",
          " * Returns the pages to be added after the print output. This returns null.",
          " */"
        ]
      ],
      "print": [
        "print(css?: string): void;",
        [
          "/**",
          " * Opens the print preview and shows the print dialog.",
          " *",
          " * Parameters:",
          " *",
          " * @param css Optional CSS string to be used in the head section.",
          " */"
        ]
      ],
      "close": [
        "close(): void;",
        [
          "/**",
          " * Closes the print preview window.",
          " */"
        ]
      ]
    }
  ],
  "mxStyleRegistry": [
    [
      "/**",
      " * @class mxStyleRegistry",
      " *",
      " * Singleton class that acts as a global converter from string to object values",
      " * in a style. This is currently only used to perimeters and edge styles.",
      " */"
    ],
    {
      "values": [
        "values: { [key: string]: any };",
        [
          "/**",
          " * Maps from strings to objects.",
          " */"
        ]
      ],
      "putValue": [
        "putValue(name: string, obj: any): void;",
        [
          "/**",
          " * Puts the given object into the registry under the given name.",
          " */"
        ]
      ],
      "getValue": [
        "getValue(name: string): any;",
        [
          "/**",
          " * Returns the value associated with the given name.",
          " */"
        ]
      ],
      "getName": [
        "getName(value: any): string;",
        [
          "/**",
          " * Returns the name for the given value.",
          " */"
        ]
      ]
    }
  ],
  "mxEdgeStyle": [
    null,
    {
      ")": [
        "): void;",
        [
          "/**",
          " * Function: OrthConnector",
          " *",
          " * Implements a local orthogonal router between the given",
          " * cells.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> that represents the edge to be updated.",
          " * source - <mxCellState> that represents the source terminal.",
          " * target - <mxCellState> that represents the target terminal.",
          " * points - List of relative control points.",
          " * result - Array of <mxPoints> that represent the actual points of the",
          " * edge.",
          " *",
          " */"
        ]
      ]
    }
  ],
  "mxCellRenderer": [
    null,
    {
      "constructor": [
        "constructor();",
        null
      ],
      "defaultShapes": [
        "defaultShapes: Object;",
        [
          "/**",
          " * Variable: defaultShapes",
          " *",
          " * Static array that contains the globally registered shapes which are",
          " * known to all instances of this class. For adding new shapes you should",
          " * use the static <mxCellRenderer.registerShape> function.",
          " */"
        ]
      ],
      "defaultEdgeShape": [
        "defaultEdgeShape: mxConnector;",
        [
          "/**",
          " * Variable: defaultEdgeShape",
          " *",
          " * Defines the default shape for edges. Default is <mxConnector>.",
          " */"
        ]
      ],
      "defaultVertexShape": [
        "defaultVertexShape: mxRectangleShape;",
        [
          "/**",
          " * Variable: defaultVertexShape",
          " *",
          " * Defines the default shape for vertices. Default is <mxRectangleShape>.",
          " */"
        ]
      ],
      "defaultTextShape": [
        "defaultTextShape: mxText;",
        [
          "/**",
          " * Variable: defaultTextShape",
          " *",
          " * Defines the default shape for labels. Default is <mxText>.",
          " */"
        ]
      ],
      "legacyControlPosition": [
        "legacyControlPosition: boolean;",
        [
          "/**",
          " * Variable: legacyControlPosition",
          " *",
          " * Specifies if the folding icon should ignore the horizontal",
          " * orientation of a swimlane. Default is true.",
          " */"
        ]
      ],
      "legacySpacing": [
        "legacySpacing: boolean;",
        [
          "/**",
          " * Variable: legacySpacing",
          " *",
          " * Specifies if spacing and label position should be ignored if overflow is",
          " * fill or width. Default is true for backwards compatiblity.",
          " */"
        ]
      ],
      "antiAlias": [
        "antiAlias: boolean;",
        [
          "/**",
          " * Variable: antiAlias",
          " *",
          " * Anti-aliasing option for new shapes. Default is true.",
          " */"
        ]
      ],
      "minSvgStrokeWidth": [
        "minSvgStrokeWidth: number;",
        [
          "/**",
          " * Variable: minSvgStrokeWidth",
          " *",
          " * Minimum stroke width for SVG output.",
          " */"
        ]
      ],
      "forceControlClickHandler": [
        "forceControlClickHandler: boolean;",
        [
          "/**",
          " * Variable: forceControlClickHandler",
          " *",
          " * Specifies if the enabled state of the graph should be ignored in the control",
          " * click handler (to allow folding in disabled graphs). Default is false.",
          " */"
        ]
      ],
      "static registerShape": [
        "static registerShape(key: string, shape: new (...args: any) => mxShape): void;",
        [
          "/**",
          " * Registers the given constructor under the specified key in this instance of the renderer.",
          " * @example",
          " * ```",
          " * mxCellRenderer.registerShape(mxConstants.SHAPE_RECTANGLE, mxRectangleShape);",
          " * ```",
          " *",
          " * @param key the shape name.",
          " * @param shape constructor of the {@link mxShape} subclass.",
          " */"
        ]
      ],
      "initializeShape": [
        "initializeShape(state: mxCellState): void;",
        [
          "/**",
          " * Function: initializeShape",
          " *",
          " * Initializes the shape in the given state by calling its init method with",
          " * the correct container after configuring it using <configureShape>.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> for which the shape should be initialized.",
          " */"
        ]
      ],
      "createShape": [
        "createShape(state: mxCellState): mxShape;",
        [
          "/**",
          " * Function: createShape",
          " *",
          " * Creates and returns the shape for the given cell state.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> for which the shape should be created.",
          " */"
        ]
      ],
      "createIndicatorShape": [
        "createIndicatorShape(state: mxCellState): void;",
        [
          "/**",
          " * Function: createIndicatorShape",
          " *",
          " * Creates the indicator shape for the given cell state.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> for which the indicator shape should be created.",
          " */"
        ]
      ],
      "getShape": [
        "getShape(name: string): mxShape;",
        [
          "/**",
          " * Function: getShape",
          " *",
          " * Returns the shape for the given name from <defaultShapes>.",
          " */"
        ]
      ],
      "getShapeConstructor": [
        "getShapeConstructor(state: mxCellState): any;",
        [
          "/**",
          " * Function: getShapeConstructor",
          " *",
          " * Returns the constructor to be used for creating the shape.",
          " */"
        ]
      ],
      "configureShape": [
        "configureShape(state: mxCellState): void;",
        [
          "/**",
          " * Function: configureShape",
          " *",
          " * Configures the shape for the given cell state.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> for which the shape should be configured.",
          " */"
        ]
      ],
      "postConfigureShape": [
        "postConfigureShape(state: mxCellState): void;",
        [
          "/**",
          " * Function: postConfigureShape",
          " *",
          " * Replaces any reserved words used for attributes, eg. inherit,",
          " * indicated or swimlane for colors in the shape for the given state.",
          " * This implementation resolves these keywords on the fill, stroke",
          " * and gradient color keys.",
          " */"
        ]
      ],
      "checkPlaceholderStyles": [
        "checkPlaceholderStyles(state: mxCellState): boolean;",
        [
          "/**",
          " * Function: checkPlaceholderStyles",
          " *",
          " * Resolves special keywords 'inherit', 'indicated' and 'swimlane' and sets",
          " * the respective color on the shape.",
          " */"
        ]
      ],
      "resolveColor": [
        "resolveColor(state: mxCellState, field: string, key: string): void;",
        [
          "/**",
          " * Function: resolveColor",
          " *",
          " * Resolves special keywords 'inherit', 'indicated' and 'swimlane' and sets",
          " * the respective color on the shape.",
          " */"
        ]
      ],
      "getLabelValue": [
        "getLabelValue(state: mxCellState): string;",
        [
          "/**",
          " * Function: getLabelValue",
          " *",
          " * Returns the value to be used for the label.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> for which the label should be created.",
          " */"
        ]
      ],
      "createLabel": [
        "createLabel(state: mxCellState, value: string): void;",
        [
          "/**",
          " * Function: createLabel",
          " *",
          " * Creates the label for the given cell state.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> for which the label should be created.",
          " */"
        ]
      ],
      "initializeLabel": [
        "initializeLabel(state: mxCellState, shape: mxShape): void;",
        [
          "/**",
          " * Function: initializeLabel",
          " *",
          " * Initiailzes the label with a suitable container.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> whose label should be initialized.",
          " */"
        ]
      ],
      "createCellOverlays": [
        "createCellOverlays(state: mxCellState): void;",
        [
          "/**",
          " * Function: createCellOverlays",
          " *",
          " * Creates the actual shape for showing the overlay for the given cell state.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> for which the overlay should be created.",
          " */"
        ]
      ],
      "initializeOverlay": [
        "initializeOverlay(state: mxCellState, overlay: mxImageShape): void;",
        [
          "/**",
          " * Function: initializeOverlay",
          " *",
          " * Initializes the given overlay.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> for which the overlay should be created.",
          " * overlay - <mxImageShape> that represents the overlay.",
          " */"
        ]
      ],
      "installCellOverlayListeners": [
        "installCellOverlayListeners(state: mxCellState, overlay: mxCellOverlay, shape: mxShape): void;",
        [
          "/**",
          " * Function: installOverlayListeners",
          " *",
          " * Installs the listeners for the given <mxCellState>, <mxCellOverlay> and",
          " * <mxShape> that represents the overlay.",
          " */"
        ]
      ],
      "createControl": [
        "createControl(state: mxCellState): void;",
        [
          "/**",
          " * Function: createControl",
          " *",
          " * Creates the control for the given cell state.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> for which the control should be created.",
          " */"
        ]
      ],
      "createControlClickHandler": [
        "createControlClickHandler(state: mxCellState): void;",
        [
          "/**",
          " * Function: createControlClickHandler",
          " *",
          " * Hook for creating the click handler for the folding icon.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> whose control click handler should be returned.",
          " */"
        ]
      ],
      "initControl": [
        "initControl(state: mxCellState, control: mxShape, handleEvents: boolean, clickHandler?: Function): Element;",
        [
          "/**",
          " * Function: initControl",
          " *",
          " * Initializes the given control and returns the corresponding DOM node.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> for which the control should be initialized.",
          " * control - <mxShape> to be initialized.",
          " * handleEvents - Boolean indicating if mousedown and mousemove should fire events via the graph.",
          " * clickHandler - Optional function to implement clicks on the control.",
          " */"
        ]
      ],
      "isShapeEvent": [
        "isShapeEvent(state: mxCellState, evt: MouseEvent): boolean;",
        [
          "/**",
          " * Function: isShapeEvent",
          " *",
          " * Returns true if the event is for the shape of the given state. This",
          " * implementation always returns true.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> whose shape fired the event.",
          " * evt - Mouse event which was fired.",
          " */"
        ]
      ],
      "isLabelEvent": [
        "isLabelEvent(state: mxCellState, evt: MouseEvent): boolean;",
        [
          "/**",
          " * Function: isLabelEvent",
          " *",
          " * Returns true if the event is for the label of the given state. This",
          " * implementation always returns true.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> whose label fired the event.",
          " * evt - Mouse event which was fired.",
          " */"
        ]
      ],
      "installListeners": [
        "installListeners(state: mxCellState): void;",
        [
          "/**",
          " * Function: installListeners",
          " *",
          " * Installs the event listeners for the given cell state.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> for which the event listeners should be isntalled.",
          " */"
        ]
      ],
      "redrawLabel": [
        "redrawLabel(state: mxCellState, forced?: boolean): void;",
        [
          "/**",
          " * Function: redrawLabel",
          " *",
          " * Redraws the label for the given cell state.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> whose label should be redrawn.",
          " */"
        ]
      ],
      "isTextShapeInvalid": [
        "isTextShapeInvalid(state: mxCellState, shape: mxText): boolean;",
        [
          "/**",
          " * Function: isTextShapeInvalid",
          " *",
          " * Returns true if the style for the text shape has changed.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> whose label should be checked.",
          " * shape - <mxText> shape to be checked.",
          " */"
        ]
      ],
      "redrawLabelShape": [
        "redrawLabelShape(shape: mxText): void;",
        [
          "/**",
          " * Function: redrawLabelShape",
          " *",
          " * Called to invoked redraw on the given text shape.",
          " *",
          " * Parameters:",
          " *",
          " * shape - <mxText> shape to be redrawn.",
          " */"
        ]
      ],
      "getTextScale": [
        "getTextScale(state: mxCellState): number;",
        [
          "/**",
          " * Function: getTextScale",
          " *",
          " * Returns the scaling used for the label of the given state",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> whose label scale should be returned.",
          " */"
        ]
      ],
      "getLabelBounds": [
        "getLabelBounds(state: mxCellState): mxRectangle;",
        [
          "/**",
          " * Function: getLabelBounds",
          " *",
          " * Returns the bounds to be used to draw the label of the given state.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> whose label bounds should be returned.",
          " */"
        ]
      ],
      "rotateLabelBounds": [
        "rotateLabelBounds(state: mxCellState, bounds: mxRectangle): void;",
        [
          "/**",
          " * Function: rotateLabelBounds",
          " *",
          " * Adds the shape rotation to the given label bounds and",
          " * applies the alignment and offsets.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> whose label bounds should be rotated.",
          " * bounds - <mxRectangle> the rectangle to be rotated.",
          " */"
        ]
      ],
      "redrawCellOverlays": [
        "redrawCellOverlays(state: mxCellState, forced?: boolean): void;",
        [
          "/**",
          " * Function: redrawCellOverlays",
          " *",
          " * Redraws the overlays for the given cell state.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> whose overlays should be redrawn.",
          " */"
        ]
      ],
      "redrawControl": [
        "redrawControl(state: mxCellState, forced?: boolean): void;",
        [
          "/**",
          " * Function: redrawControl",
          " *",
          " * Redraws the control for the given cell state.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> whose control should be redrawn.",
          " */"
        ]
      ],
      "getControlBounds": [
        "getControlBounds(state: mxCellState, w: number, h: number): mxRectangle;",
        [
          "/**",
          " * Function: getControlBounds",
          " *",
          " * Returns the bounds to be used to draw the control (folding icon) of the",
          " * given state.",
          " */"
        ]
      ],
      "insertStateAfter": [
        "insertStateAfter(state: mxCellState, node: Element, htmlNode: HTMLElement): void;",
        [
          "/**",
          " * Function: insertStateAfter",
          " *",
          " * Inserts the given array of <mxShapes> after the given nodes in the DOM.",
          " *",
          " * Parameters:",
          " *",
          " * shapes - Array of <mxShapes> to be inserted.",
          " * node - Node in <drawPane> after which the shapes should be inserted.",
          " * htmlNode - Node in the graph container after which the shapes should be inserted that",
          " * will not go into the <drawPane> (eg. HTML labels without foreignObjects).",
          " */"
        ]
      ],
      "getShapesForState": [
        "getShapesForState(state: mxCellState): mxShape[];",
        [
          "/**",
          " * Function: getShapesForState",
          " *",
          " * Returns the <mxShapes> for the given cell state in the order in which they should",
          " * appear in the DOM.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> whose shapes should be returned.",
          " */"
        ]
      ],
      "redraw": [
        "redraw(state: mxCellState, force?: boolean, rendering?: boolean): void;",
        [
          "/**",
          " * Function: redraw",
          " *",
          " * Updates the bounds or points and scale of the shapes for the given cell",
          " * state. This is called in mxGraphView.validatePoints as the last step of",
          " * updating all cells.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> for which the shapes should be updated.",
          " * force - Optional boolean that specifies if the cell should be reconfiured",
          " * and redrawn without any additional checks.",
          " * rendering - Optional boolean that specifies if the cell should actually",
          " * be drawn into the DOM. If this is false then redraw and/or reconfigure",
          " * will not be called on the shape.",
          " */"
        ]
      ],
      "redrawShape": [
        "redrawShape(state: mxCellState, force?: boolean, rendering?: boolean): void;",
        [
          "/**",
          " * Function: redrawShape",
          " *",
          " * Redraws the shape for the given cell state.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> whose label should be redrawn.",
          " */"
        ]
      ],
      "doRedrawShape": [
        "doRedrawShape(state: mxCellState): void;",
        [
          "/**",
          " * Function: doRedrawShape",
          " *",
          " * Invokes redraw on the shape of the given state.",
          " */"
        ]
      ],
      "isShapeInvalid": [
        "isShapeInvalid(state: mxCellState, shape: mxShape): boolean;",
        [
          "/**",
          " * Function: isShapeInvalid",
          " *",
          " * Returns true if the given shape must be repainted.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(state: mxCellState): void;",
        [
          "/**",
          " * Function: destroy",
          " *",
          " * Destroys the shapes associated with the given cell state.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> for which the shapes should be destroyed.",
          " */"
        ]
      ]
    }
  ],
  "mxMultiplicity": [
    [
      "/**",
      " * @class mxMultiplicity",
      " *",
      " * Defines invalid connections along with the error messages that they produce.",
      " * To add or remove rules on a graph, you must add/remove instances of this",
      " * class to {@link mxGraph.multiplicities}.",
      " *",
      " * ### Example",
      " *",
      " * @example",
      " * ```javascript",
      " * graph.multiplicities.push(new mxMultiplicity(",
      " *   true, 'rectangle', null, null, 0, 2, ['circle'],",
      " *   'Only 2 targets allowed',",
      " *   'Only circle targets allowed'));",
      " * ```",
      " *",
      " * Defines a rule where each rectangle must be connected to no more than 2",
      " * circles and no other types of targets are allowed.",
      " */"
    ],
    {
      ");": [
        ");",
        [
          "/**",
          " * @constructor",
          " *",
          " * Instantiate class mxMultiplicity in order to describe allowed",
          " * connections in a graph. Not all constraints can be enforced while",
          " * editing, some must be checked at validation time. The {@link countError} and",
          " * {@link typeError} are treated as resource keys in {@link mxResources}.",
          " *",
          " * @param source Boolean indicating if this rule applies to the source or target",
          " * terminal.",
          " * @param type Type of the source or target terminal that this rule applies to.",
          " * See {@link type} for more information.",
          " * @param attr Optional attribute name to match the source or target terminal.",
          " * @param value Optional attribute value to match the source or target terminal.",
          " * @param min Minimum number of edges for this rule. Default is 1.",
          " * @param max Maximum number of edges for this rule. n means infinite. Default",
          " * is n.",
          " * @param validNeighbors Array of types of the opposite terminal for which this",
          " * rule applies.",
          " * @param countError Error to be displayed for invalid number of edges.",
          " * @param typeError Error to be displayed for invalid opposite terminals.",
          " * @param validNeighborsAllowed Optional boolean indicating if the array of",
          " * opposite types should be valid or invalid.",
          " */"
        ]
      ],
      "type": [
        "type: string;",
        [
          "/**",
          " * Defines the type of the source or target terminal. The type is a string",
          " * passed to {@link mxUtils.isNode} together with the source or target vertex",
          " * value as the first argument.",
          " */"
        ]
      ],
      "attr": [
        "attr: string;",
        [
          "/**",
          " * Optional string that specifies the attributename to be passed to",
          " * {@link mxUtils.isNode} to check if the rule applies to a cell.",
          " */"
        ]
      ],
      "value": [
        "value: string;",
        [
          "/**",
          " * Optional string that specifies the value of the attribute to be passed",
          " * to {@link mxUtils.isNode} to check if the rule applies to a cell.",
          " */"
        ]
      ],
      "source": [
        "source: boolean;",
        [
          "/**",
          " * Boolean that specifies if the rule is applied to the source or target",
          " * terminal of an edge.",
          " */"
        ]
      ],
      "min": [
        "min: number;",
        [
          "/**",
          " * Defines the minimum number of connections for which this rule applies.",
          " *",
          " * @default 0",
          " */"
        ]
      ],
      "max": [
        "max: number | 'n';",
        [
          "/**",
          " * Defines the maximum number of connections for which this rule applies.",
          " * A value of 'n' means unlimited times.",
          " * @default 'n'",
          " */"
        ]
      ],
      "validNeighbors": [
        "validNeighbors: Array<string>;",
        [
          "/**",
          " * Holds an array of strings that specify the type of neighbor for which",
          " * this rule applies. The strings are used in {@link mxCell.is} on the opposite",
          " * terminal to check if the rule applies to the connection.",
          " */"
        ]
      ],
      "validNeighborsAllowed": [
        "validNeighborsAllowed: boolean;",
        [
          "/**",
          " * Boolean indicating if the list of validNeighbors are those that are allowed",
          " * for this rule or those that are not allowed for this rule.",
          " */"
        ]
      ],
      "countError": [
        "countError: string;",
        [
          "/**",
          " * Holds the localized error message to be displayed if the number of",
          " * connections for which the rule applies is smaller than {@link min} or greater",
          " * than {@link max}.",
          " */"
        ]
      ],
      "typeError": [
        "typeError: string;",
        [
          "/**",
          " * Holds the localized error message to be displayed if the type of the",
          " * neighbor for a connection does not match the rule.",
          " */"
        ]
      ],
      "check": [
        "check(graph: mxGraph, edge: mxCell, source: mxCell, target: mxCell, sourceOut: number, targetIn: number): string;",
        [
          "/**",
          " * Checks the multiplicity for the given arguments and returns the error",
          " * for the given connection or null if the multiplicity does not apply.",
          " *",
          " * @param graph Reference to the enclosing {@link mxGraph} instance.",
          " * @param edge {@link mxCell} that represents the edge to validate.",
          " * @param source {@link mxCell} that represents the source terminal.",
          " * @param target {@link mxCell} that represents the target terminal.",
          " * @param sourceOut Number of outgoing edges from the source terminal.",
          " * @param targetIn Number of incoming edges for the target terminal.",
          " */"
        ]
      ],
      "checkNeighbors": [
        "checkNeighbors(graph: mxGraph, edge: mxCell, source: mxCell, target: mxCell): boolean;",
        [
          "/**",
          " * Checks if there are any valid neighbours in {@link validNeighbors}. This is only",
          " * called if {@link validNeighbors} is a non-empty array.",
          " */"
        ]
      ],
      "checkTerminal": [
        "checkTerminal(graph: mxGraph, terminal: mxCell, edge: mxCell): boolean;",
        [
          "/**",
          " * Checks the given terminal cell and returns true if this rule applies. The",
          " * given cell is the source or target of the given edge, depending on",
          " * {@link source}. This implementation uses {@link checkType} on the terminal's value.",
          " */"
        ]
      ],
      "checkType": [
        "checkType(graph: mxCell, value: string, type: string, attr: string, attrValue: any): boolean;",
        [
          "/**",
          " * Checks the type of the given value.",
          " */"
        ]
      ]
    }
  ],
  "mxConnectionConstraint": [
    [
      "/**",
      " * Defines an object that contains the constraints about how to connect one side of an edge to its terminal.",
      " * @class mxConnectionConstraint",
      " */"
    ],
    {
      "constructor": [
        "constructor(point?: mxPoint, perimeter?: boolean, name?: string, dx?: number, dy?: number);",
        [
          "/**",
          " * Constructs a new connection constraint for the given point and boolean arguments.",
          " * @param point       Optional mxPoint that specifies the fixed location of the point in relative coordinates.  Default is null.",
          " * @param perimeter   Optional boolean that specifies if the fixed point should be projected onto the perimeter of the terminal.  Default is true.",
          " * @param name",
          " * @param dx",
          " * @param dy",
          " */"
        ]
      ],
      "point": [
        "point: mxPoint;",
        [
          "/**",
          " * Variable: point",
          " *",
          " * <mxPoint> that specifies the fixed location of the connection point.",
          " */"
        ]
      ],
      "perimeter": [
        "perimeter: boolean;",
        [
          "/**",
          " * Variable: perimeter",
          " *",
          " * Boolean that specifies if the point should be projected onto the perimeter",
          " * of the terminal.",
          " */"
        ]
      ],
      "name": [
        "name: string;",
        [
          "/**",
          " * Variable: name",
          " *",
          " * Optional string that specifies the name of the constraint.",
          " */"
        ]
      ]
    }
  ],
  "mxStackLayout": [
    null,
    {
      "constructor": [
        "constructor(graph: mxGraph, horizontal?: boolean, spacing?: number, x0?: number, y0?: number, border?: number);",
        null
      ],
      "horizontal": [
        "horizontal: boolean;",
        [
          "/**",
          " * Specifies the orientation of the layout.",
          " */"
        ]
      ],
      "spacing": [
        "spacing: number;",
        [
          "/**",
          " * Specifies the spacing between the cells.",
          " */"
        ]
      ],
      "x0": [
        "x0: number;",
        [
          "/**",
          " * Specifies the horizontal origin of the layout.",
          " */"
        ]
      ],
      "y0": [
        "y0: number;",
        [
          "/**",
          " * Specifies the vertical origin of the layout.",
          " */"
        ]
      ],
      "border": [
        "border: number;",
        [
          "/**",
          " * Border to be added if fill is true.",
          " */"
        ]
      ],
      "marginTop": [
        "marginTop: number;",
        [
          "/**",
          " * Top margin for the child area.",
          " */"
        ]
      ],
      "marginLeft": [
        "marginLeft: number;",
        [
          "/**",
          " * Top margin for the child area.",
          " */"
        ]
      ],
      "marginRight": [
        "marginRight: number;",
        [
          "/**",
          " * Top margin for the child area.",
          " */"
        ]
      ],
      "marginBottom": [
        "marginBottom: number;",
        [
          "/**",
          " * Top margin for the child area.",
          " */"
        ]
      ],
      "keepFirstLocation": [
        "keepFirstLocation: boolean;",
        [
          "/**",
          " * Boolean indicating if the location of the first cell should be kept, that is, it will not be moved to x0 or y0.",
          " */"
        ]
      ],
      "fill": [
        "fill: boolean;",
        [
          "/**",
          " * Boolean indicating if dimension should be changed to fill out the parent cell.",
          " */"
        ]
      ],
      "resizeParent": [
        "resizeParent: boolean;",
        [
          "/**",
          " * If the parent should be resized to match the width/height of the stack.",
          " */"
        ]
      ],
      "resizeParentMax": [
        "resizeParentMax: boolean;",
        [
          "/**",
          " * Use maximum of existing value and new value for resize of parent.",
          " */"
        ]
      ],
      "resizeLast": [
        "resizeLast: boolean;",
        [
          "/**",
          " * If the last element should be resized to fill out the parent.",
          " */"
        ]
      ],
      "wrap": [
        "wrap: boolean;",
        [
          "/**",
          " * Value at which a new column or row should be created.",
          " */"
        ]
      ],
      "borderCollapse": [
        "borderCollapse: boolean;",
        [
          "/**",
          " * If the strokeWidth should be ignored.",
          " */"
        ]
      ],
      "allowGaps": [
        "allowGaps: boolean;",
        [
          "/**",
          " * If gaps should be allowed in the stack.",
          " */"
        ]
      ],
      "gridSize": [
        "gridSize: number;",
        [
          "/**",
          " * Grid size for alignment of position and size.",
          " */"
        ]
      ],
      "isHorizontal": [
        "isHorizontal(): boolean;",
        [
          "/**",
          " * Returns horizontal.",
          " */"
        ]
      ],
      "moveCell": [
        "moveCell(cell: mxCell, x: number, y: number): void;",
        [
          "/**",
          " * Implements mxGraphLayout.moveCell.",
          " */"
        ]
      ],
      "getParentSize": [
        "getParentSize(): void;",
        [
          "/**",
          " * Returns the size for the parent container or the size of the graph container if the parent is a layer or the root of the model.",
          " */"
        ]
      ],
      "getLayoutCells": [
        "getLayoutCells(parent: mxCell): Array<mxCell>;",
        [
          "/**",
          " * Returns the cells to be layouted.",
          " */"
        ]
      ],
      "snap": [
        "snap(): void;",
        [
          "/**",
          " * Snaps the given value to the grid size.",
          " */"
        ]
      ],
      "execute": [
        "execute(parent: mxCell): void;",
        [
          "/**",
          " * Implements mxGraphLayout.execute.",
          " */"
        ]
      ],
      "cell?": [
        "cell?: mxCell;",
        null
      ],
      "x?": [
        "x?: number;",
        null
      ],
      "y?": [
        "y?: number;",
        null
      ],
      "width?": [
        "width?: number;",
        null
      ],
      "height?": [
        "height?: number;",
        null
      ],
      "offsetX?": [
        "offsetX?: number;",
        null
      ],
      "offsetY?": [
        "offsetY?: number;",
        null
      ],
      "upperTail": [
        "upperTail: _mxCompactTreeLayoutLine;",
        null
      ],
      "upperHead": [
        "upperHead: _mxCompactTreeLayoutLine;",
        null
      ],
      "lowerTail": [
        "lowerTail: _mxCompactTreeLayoutLine;",
        null
      ],
      "lowerHead": [
        "lowerHead: _mxCompactTreeLayoutLine;",
        null
      ],
      "key": [
        "[key: string]: any;",
        null
      ],
      "};": [
        "};",
        null
      ],
      "child?": [
        "child?: _mxCompactTreeLayoutNode;",
        null
      ],
      "dx": [
        "dx: number;",
        null
      ],
      "dy": [
        "dy: number;",
        null
      ],
      "next": [
        "next: _mxCompactTreeLayoutLine;",
        null
      ]
    }
  ],
  "mxCompactTreeLayout": [
    [
      "/**",
      " * @class mxCompactTreeLayout",
      " * @extends {mxGraphLayout}",
      " *",
      " * Extends {@link mxGraphLayout} to implement a compact tree (Moen) algorithm. This",
      " * layout is suitable for graphs that have no cycles (trees). Vertices that are",
      " * not connected to the tree will be ignored by this layout.",
      " *",
      " * ### Example",
      " *",
      " * @example",
      " * ```javascript",
      " * var layout = new mxCompactTreeLayout(graph);",
      " * layout.execute(graph.getDefaultParent());",
      " * ```",
      " */"
    ],
    {
      "constructor": [
        "constructor(graph: mxGraph, horizontal?: boolean, invert?: boolean);",
        [
          "/**",
          " * Constructs a new compact tree layout for the specified graph",
          " * and orientation.",
          " * @param {mxGraph} graph",
          " * @param {boolean} [horizontal]",
          " * @param {boolean} [invert]",
          " */"
        ]
      ],
      "horizontal": [
        "horizontal: boolean;",
        [
          "/**",
          " * Specifies the orientation of the layout.",
          " * @default true",
          " */"
        ]
      ],
      "invert": [
        "invert: boolean;",
        [
          "/**",
          " * Specifies if edge directions should be inverted.",
          " * @default false.",
          " */"
        ]
      ],
      "resizeParent": [
        "resizeParent: boolean;",
        [
          "/**",
          " * If the parents should be resized to match the width/height of the",
          " * children. Default is true.",
          " * @default true",
          " */"
        ]
      ],
      "maintainParentLocation": [
        "maintainParentLocation: boolean;",
        [
          "/**",
          " * Specifies if the parent location should be maintained, so that the",
          " * top, left corner stays the same before and after execution of",
          " * the layout. Default is false for backwards compatibility.",
          " * @default false",
          " */"
        ]
      ],
      "groupPadding": [
        "groupPadding: boolean;",
        [
          "/**",
          " * Padding added to resized parents.",
          " * @default 10",
          " */"
        ]
      ],
      "groupPaddingTop": [
        "groupPaddingTop: boolean;",
        [
          "/**",
          " * Top padding added to resized parents.",
          " * @default 0",
          " */"
        ]
      ],
      "groupPaddingRight": [
        "groupPaddingRight: boolean;",
        [
          "/**",
          " * Right padding added to resized parents.",
          " * @default 0",
          " */"
        ]
      ],
      "groupPaddingBottom": [
        "groupPaddingBottom: boolean;",
        [
          "/**",
          " * Bottom padding added to resized parents.",
          " * @default 0",
          " */"
        ]
      ],
      "groupPaddingLeft": [
        "groupPaddingLeft: boolean;",
        [
          "/**",
          " * Left padding added to resized parents.",
          " * @default 0",
          " */"
        ]
      ],
      "parentsChanged": [
        "parentsChanged: { [id: string]: mxCell };",
        [
          "/**",
          " * A set of the parents that need updating based on children",
          " * process as part of the layout.",
          " */"
        ]
      ],
      "moveTree": [
        "moveTree: boolean;",
        [
          "/**",
          " * Specifies if the tree should be moved to the top, left corner",
          " * if it is inside a top-level layer.",
          " * @default false",
          " */"
        ]
      ],
      "visited": [
        "visited: boolean;",
        [
          "/**",
          " * Specifies if the tree should be moved to the top, left corner",
          " * if it is inside a top-level layer.",
          " * @default false",
          " */"
        ]
      ],
      "levelDistance": [
        "levelDistance: number;",
        [
          "/**",
          " * Holds the levelDistance.",
          " * @default 10",
          " */"
        ]
      ],
      "nodeDistance": [
        "nodeDistance: number;",
        [
          "/**",
          " * Holds the nodeDistance.",
          " * @default 20",
          " */"
        ]
      ],
      "resetEdges": [
        "resetEdges: boolean;",
        [
          "/**",
          " * Specifies if all edge points of traversed edges should be removed.",
          " *",
          " * @default true",
          " */"
        ]
      ],
      "prefHozEdgeSep": [
        "prefHozEdgeSep: boolean;",
        [
          "/**",
          " * The preferred horizontal distance between edges exiting a vertex.",
          " */"
        ]
      ],
      "prefVertEdgeOff": [
        "prefVertEdgeOff: boolean;",
        [
          "/**",
          " * The preferred vertical offset between edges exiting a vertex.",
          " */"
        ]
      ],
      "minEdgeJetty": [
        "minEdgeJetty: boolean;",
        [
          "/**",
          " * The minimum distance for an edge jetty from a vertex.",
          " */"
        ]
      ],
      "channelBuffer": [
        "channelBuffer: boolean;",
        [
          "/**",
          " * The size of the vertical buffer in the center of inter-rank channels",
          " * where edge control points should not be placed.",
          " */"
        ]
      ],
      "edgeRouting": [
        "edgeRouting: boolean;",
        [
          "/**",
          " * Whether or not to apply the internal tree edge routing.",
          " */"
        ]
      ],
      "sortEdges": [
        "sortEdges: boolean;",
        [
          "/**",
          " * Specifies if edges should be sorted according to the order of their",
          " * opposite terminal cell in the model.",
          " */"
        ]
      ],
      "alignRanks": [
        "alignRanks: boolean;",
        [
          "/**",
          " * Whether or not the tops of cells in each rank should be aligned",
          " * across the rank",
          " */"
        ]
      ],
      "maxRankHeight": [
        "maxRankHeight: Array<number>;",
        [
          "/**",
          " * An array of the maximum height of cells (relative to the layout direction)",
          " * per rank",
          " */"
        ]
      ],
      "root": [
        "root: mxCell;",
        [
          "/**",
          " * The cell to use as the root of the tree",
          " */"
        ]
      ],
      "node": [
        "node: _mxCompactTreeLayoutNode;",
        [
          "/**",
          " * The internal node representation of the root cell. Do not set directly",
          " * , this value is only exposed to assist with post-processing functionality",
          " */"
        ]
      ],
      "isVertexIgnored": [
        "isVertexIgnored(vertex: mxCell): boolean;",
        [
          "/**",
          " * Returns a boolean indicating if the given {@link mxCell} should be ignored as a",
          " * vertex. This returns true if the cell has no connections.",
          " *",
          " * @param vertex {@link mxCell} whose ignored state should be returned.",
          " */"
        ]
      ],
      "isHorizontal": [
        "isHorizontal(): boolean;",
        [
          "/**",
          " * Returns {@link horizontal}.",
          " */"
        ]
      ],
      "execute": [
        "execute(parent: mxCell, root?: mxCell): void;",
        [
          "/**",
          " * Implements {@link mxGraphLayout.execute}.",
          " *",
          " * If the parent has any connected edges, then it is used as the root of",
          " * the tree. Else, {@link mxGraph.findTreeRoots} will be used to find a suitable",
          " * root node within the set of children of the given parent.",
          " *",
          " * @param parent  {@link mxCell} whose children should be laid out.",
          " * @param root    Optional {@link mxCell} that will be used as the root of the tree. Overrides {@link root} if specified.",
          " */"
        ]
      ],
      "moveNode": [
        "moveNode(node: any, dx: number, dy: number): void;",
        [
          "/**",
          " * Moves the specified node and all of its children by the given amount.",
          " */"
        ]
      ],
      "sortOutgoingEdges": [
        "sortOutgoingEdges(source: mxCell, edges: Array<mxCell>): void;",
        [
          "/**",
          " * Called if {@link sortEdges} is true to sort the array of outgoing edges in place.",
          " */"
        ]
      ],
      "findRankHeights": [
        "findRankHeights(node: any, rank: number): void;",
        [
          "/**",
          " * Stores the maximum height (relative to the layout",
          " * direction) of cells in each rank",
          " */"
        ]
      ],
      "setCellHeights": [
        "setCellHeights(node: any, rank: number): void;",
        [
          "/**",
          " * Set the cells heights (relative to the layout",
          " * direction) when the tops of each rank are to be aligned",
          " */"
        ]
      ],
      "layout": [
        "layout(node: any): void;",
        [
          "/**",
          " * Starts the actual compact tree layout algorithm",
          " * at the given node.",
          " */"
        ]
      ],
      "horizontalLayout": [
        "horizontalLayout(node: any, x0: number, y0: number, bounds: mxRectangle): mxRectangle;",
        [
          "/**",
          " * Starts the actual compact tree layout algorithm",
          " * at the given node.",
          " */"
        ]
      ],
      "verticalLayout": [
        "verticalLayout(node: any, parent: mxCell, x0: number, y0: number, bounds: mxRectangle): mxRectangle;",
        [
          "/**",
          " * Starts the actual compact tree layout algorithm",
          " * at the given node.",
          " */"
        ]
      ],
      "attachParent": [
        "attachParent(node: any, height: number): void;",
        [
          "/**",
          " * Starts the actual compact tree layout algorithm",
          " * at the given node.",
          " */"
        ]
      ],
      "layoutLeaf": [
        "layoutLeaf(node: any): void;",
        [
          "/**",
          " * Starts the actual compact tree layout algorithm",
          " * at the given node.",
          " */"
        ]
      ],
      "join": [
        "join(node: any): number;",
        [
          "/**",
          " * Starts the actual compact tree layout algorithm",
          " * at the given node.",
          " */"
        ]
      ],
      "merge": [
        "merge(p1: any, p2: any): number;",
        [
          "/**",
          " * Starts the actual compact tree layout algorithm",
          " * at the given node.",
          " */"
        ]
      ],
      "offset": [
        "offset(p1: number, p2: number, a1: number, a2: number, b1: number, b2: number): number;",
        [
          "/**",
          " * Starts the actual compact tree layout algorithm",
          " * at the given node.",
          " */"
        ]
      ],
      ")": [
        "): _mxCompactTreeLayoutLine;",
        [
          "/**",
          " * Starts the actual compact tree layout algorithm",
          " * at the given node.",
          " */"
        ]
      ],
      "createNode": [
        "createNode(cell: mxCell): _mxCompactTreeLayoutNode;",
        [
          "/**",
          " * Starts the actual compact tree layout algorithm",
          " * at the given node.",
          " */"
        ]
      ],
      "apply": [
        "apply(node: any, bounds: mxRectangle): mxRectangle;",
        [
          "/**",
          " * Starts the actual compact tree layout algorithm",
          " * at the given node.",
          " */"
        ]
      ],
      "createLine": [
        "createLine(dx: number, dy: number, next: any): _mxCompactTreeLayoutLine;",
        [
          "/**",
          " * Starts the actual compact tree layout algorithm",
          " * at the given node.",
          " */"
        ]
      ],
      "adjustParents": [
        "adjustParents(): void;",
        [
          "/**",
          " * Adjust parent cells whose child geometries have changed. The default",
          " * implementation adjusts the group to just fit around the children with",
          " * a padding.",
          " */"
        ]
      ],
      "localEdgeProcessing": [
        "localEdgeProcessing(node: _mxCompactTreeLayoutNode): void;",
        [
          "/**",
          " * Moves the specified node and all of its children by the given amount.",
          " */"
        ]
      ],
      "processNodeOutgoing": [
        "processNodeOutgoing(node: _mxCompactTreeLayoutNode): void;",
        [
          "/**",
          " * Separates the x position of edges as they connect to vertices",
          " */"
        ]
      ]
    }
  ],
  "mxRadialTreeLayout": [
    [
      "/**",
      " * Extends {@link mxGraphLayout} to implement a radial tree algorithm. This",
      " * layout is suitable for graphs that have no cycles (trees). Vertices that are",
      " * not connected to the tree will be ignored by this layout.",
      " *",
      " * @example",
      " * ```javascript",
      " * var layout = new mxRadialTreeLayout(graph);",
      " * layout.execute(graph.getDefaultParent());",
      " * ```",
      " */"
    ],
    {
      "constructor": [
        "constructor(graph: mxGraph);",
        [
          "/**",
          " * Constructs a new radial tree layout for the specified graph",
          " */"
        ]
      ],
      "angleOffset": [
        "angleOffset: number;",
        [
          "/**",
          " * The initial offset to compute the angle position.",
          " * @default 0.5",
          " */"
        ]
      ],
      "rootx": [
        "rootx: number;",
        [
          "/**",
          " * The X co-ordinate of the root cell",
          " * @default 0",
          " */"
        ]
      ],
      "rooty": [
        "rooty: number;",
        [
          "/**",
          " * The Y co-ordinate of the root cell",
          " * @default 0",
          " */"
        ]
      ],
      "levelDistance": [
        "levelDistance: number;",
        [
          "/**",
          " * Holds the levelDistance.",
          " * @default 120",
          " */"
        ]
      ],
      "nodeDistance": [
        "nodeDistance: number;",
        [
          "/**",
          " * Holds the nodeDistance.",
          " * @default 10",
          " */"
        ]
      ],
      "autoRadius": [
        "autoRadius: boolean;",
        [
          "/**",
          " * Specifies if the radios should be computed automatically",
          " * @default false",
          " */"
        ]
      ],
      "sortEdges": [
        "sortEdges: boolean;",
        [
          "/**",
          " * Specifies if edges should be sorted according to the order of their",
          " * opposite terminal cell in the model.",
          " * @default false",
          " */"
        ]
      ],
      "rowMinX": [
        "rowMinX: Array<number>;",
        [
          "/**",
          " * Array of leftmost x coordinate of each row",
          " */"
        ]
      ],
      "rowMaxX": [
        "rowMaxX: Array<number>;",
        [
          "/**",
          " * Array of rightmost x coordinate of each row",
          " */"
        ]
      ],
      "rowMinCenX": [
        "rowMinCenX: Array<number>;",
        [
          "/**",
          " * Array of x coordinate of leftmost vertex of each row",
          " */"
        ]
      ],
      "rowMaxCenX": [
        "rowMaxCenX: Array<number>;",
        [
          "/**",
          " * Variable: rowMaxCenX",
          " *",
          " * Array of x coordinate of rightmost vertex of each row",
          " */"
        ]
      ],
      "rowRadi": [
        "rowRadi: Array<number>;",
        [
          "/**",
          " * Array of y deltas of each row behind root vertex, also the radius in the tree",
          " */"
        ]
      ],
      "row": [
        "row: Array<mxCell>;",
        [
          "/**",
          " * Array of vertices on each row",
          " */"
        ]
      ],
      "isVertexIgnored": [
        "isVertexIgnored(vertex: mxCell): boolean;",
        [
          "/**",
          " * Returns a boolean indicating if the given {@link mxCell} should be ignored as a vertex.",
          " *",
          " * @param vertex {@link mxCell} whose ignored state should be returned.",
          " * @return true if the cell has no connections.",
          " */"
        ]
      ],
      "execute": [
        "execute(parent: mxCell, root?: mxCell): void;",
        [
          "/**",
          " * Function: execute",
          " *",
          " * Implements <mxGraphLayout.execute>.",
          " *",
          " * If the parent has any connected edges, then it is used as the root of",
          " * the tree. Else, <mxGraph.findTreeRoots> will be used to find a suitable",
          " * root node within the set of children of the given parent.",
          " *",
          " * Parameters:",
          " *",
          " * @param parent    {@link mxCell} whose children should be laid out.",
          " * @param root      Optional {@link mxCell} that will be used as the root of the tree.",
          " */"
        ]
      ],
      "calcRowDims": [
        "calcRowDims(row: Array<number>, rowNum: number): void;",
        [
          "/**",
          " * Recursive function to calculate the dimensions of each row",
          " *",
          " * @param row      Array of internal nodes, the children of which are to be processed.",
          " * @param rowNum   Integer indicating which row is being processed.",
          " */"
        ]
      ]
    }
  ],
  "mxCircleLayout": [
    null,
    {
      "x0": [
        "x0: number;",
        null
      ],
      "y0": [
        "y0: number;",
        null
      ],
      "radius": [
        "radius: number;",
        null
      ],
      "moveCircle": [
        "moveCircle: boolean;",
        null
      ],
      "disableEdgeStyle": [
        "disableEdgeStyle: boolean;",
        null
      ],
      "constructor": [
        "constructor(graph: mxGraph, radius?: number);",
        null
      ],
      "execute": [
        "execute(parent: mxCell): void;",
        null
      ],
      "getRadius": [
        "getRadius(count: number, max: number): number;",
        null
      ]
    }
  ],
  "mxPartitionLayout": [
    [
      "/**",
      " * Extends <mxGraphLayout> for partitioning the parent cell vertically or",
      " * horizontally by filling the complete area with the child cells. A horizontal",
      " * layout partitions the height of the given parent whereas a a non-horizontal",
      " * layout partitions the width. If the parent is a layer (that is, a child of",
      " * the root node), then the current graph size is partitioned. The children do",
      " * not need to be connected for this layout to work.",
      " *",
      " * Example:",
      " *",
      " * @example",
      " * ```javascript",
      " * var layout = new mxPartitionLayout(graph, true, 10, 20);",
      " * layout.execute(graph.getDefaultParent());",
      " * ```",
      " * @class",
      " */"
    ],
    {
      "constructor": [
        "constructor(graph: mxGraph, horizontal?: boolean, spacing?: number, border?: number);",
        [
          "/**",
          " * Constructs a new stack layout layout for the specified graph,",
          " * spacing, orientation and offset.",
          " * @param {mxGraph} graph",
          " * @param {boolean} [horizontal]",
          " * @param {number} [spacing]",
          " * @param {number} [border]",
          " * @memberof mxPartitionLayout",
          " */"
        ]
      ],
      "horizontal": [
        "horizontal: boolean;",
        [
          "/**",
          " * Boolean indicating the direction in which the space is partitioned.",
          " * Default is true.",
          " */"
        ]
      ],
      "spacing": [
        "spacing: number;",
        [
          "/**",
          " * Integer that specifies the absolute spacing in pixels between the",
          " * children. Default is 0.",
          " */"
        ]
      ],
      "border": [
        "border: number;",
        [
          "/**",
          " * Integer that specifies the absolute inset in pixels for the parent that",
          " * contains the children. Default is 0.",
          " */"
        ]
      ],
      "resizeVertices": [
        "resizeVertices: boolean;",
        [
          "/**",
          " * Boolean that specifies if vertices should be resized. Default is true.",
          " */"
        ]
      ],
      "isHorizontal": [
        "isHorizontal(): boolean;",
        [
          "/**",
          " * Returns <horizontal>.",
          " */"
        ]
      ],
      "moveCell": [
        "moveCell(cell: mxCell, x: number, y: number): void;",
        [
          "/**",
          " * Implements {@link mxGraphLayout.moveCell}.",
          " *",
          " * @param {mxCell} cell",
          " * @param {number} x",
          " * @param {number} y",
          " * @memberof mxPartitionLayout",
          " */"
        ]
      ],
      "execute": [
        "execute(parent: mxCell): void;",
        [
          "/**",
          " * Implements <mxGraphLayout.execute>. All children where <isVertexIgnored>",
          " * returns false and <isVertexMovable> returns true are modified.",
          " */"
        ]
      ]
    }
  ],
  "mxGraphLayout": [
    [
      "/**",
      " * @class mxGraphLayout",
      " *",
      " * Base class for all layout algorithms in mxGraph. Main public functions are",
      " * {@link moveCell} for handling a moved cell within a layouted parent, and {@link execute} for",
      " * running the layout on a given parent cell.",
      " *",
      " * Known Subclasses:",
      " *",
      " * {@link mxCircleLayout}, {@link mxCompactTreeLayout}, {@link mxCompositeLayout},",
      " * {@link mxFastOrganicLayout}, {@link mxParallelEdgeLayout}, {@link mxPartitionLayout},",
      " * {@link mxStackLayout}",
      " */"
    ],
    {
      "constructor": [
        "constructor(graph: mxGraph);",
        [
          "/**",
          " * Constructs a new layout using the given layouts.",
          " * @param {mxGraph} graph   Enclosing",
          " */"
        ]
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Reference to the enclosing {@link mxGraph}.",
          " */"
        ]
      ],
      "useBoundingBox": [
        "useBoundingBox: boolean;",
        [
          "/**",
          " * Boolean indicating if the bounding box of the label should be used if",
          " * its available. Default is true.",
          " */"
        ]
      ],
      "parent": [
        "parent: mxCell;",
        [
          "/**",
          " * The parent cell of the layout, if any",
          " */"
        ]
      ],
      "moveCell": [
        "moveCell(cell: mxCell, x: number, y: number): void;",
        [
          "/**",
          " * Notified when a cell is being moved in a parent that has automatic",
          " * layout to update the cell state (eg. index) so that the outcome of the",
          " * layout will position the vertex as close to the point (x, y) as",
          " * possible.",
          " *",
          " * Empty implementation.",
          " *",
          " * @param cell {@link mxCell} which has been moved.",
          " * @param x X-coordinate of the new cell location.",
          " * @param y Y-coordinate of the new cell location.",
          " */"
        ]
      ],
      "execute": [
        "execute(parent: mxCell): void;",
        [
          "/**",
          " * Executes the layout algorithm for the children of the given parent.",
          " *",
          " * @param parent {@link mxCell} whose children should be layed out.",
          " */"
        ]
      ],
      "getGraph": [
        "getGraph(): mxGraph;",
        [
          "/**",
          " * Returns the graph that this layout operates on.",
          " */"
        ]
      ],
      "getConstraint": [
        "getConstraint(key: string, cell: mxCell, edge?: mxCell, source?: boolean): any;",
        [
          "/**",
          " * Returns the constraint for the given key and cell. The optional edge and",
          " * source arguments are used to return inbound and outgoing routing-",
          " * constraints for the given edge and vertex. This implementation always",
          " * returns the value for the given key in the style of the given cell.",
          " *",
          " * @param key Key of the constraint to be returned.",
          " * @param cell {@link mxCell} whose constraint should be returned.",
          " * @param edge Optional {@link mxCell} that represents the connection whose constraint",
          " * should be returned. Default is null.",
          " * @param source Optional boolean that specifies if the connection is incoming",
          " * or outgoing. Default is null.",
          " */"
        ]
      ],
      "traverse": [
        "traverse(vertex: mxCell, directed?: boolean, func?: Function, edge?: mxCell, visited?: mxDictionary): void;",
        [
          "/**",
          " * Traverses the (directed) graph invoking the given function for each",
          " * visited vertex and edge. The function is invoked with the current vertex",
          " * and the incoming edge as a parameter. This implementation makes sure",
          " * each vertex is only visited once. The function may return false if the",
          " * traversal should stop at the given vertex.",
          " *",
          " * Example:",
          " *",
          " * (code)",
          " * mxLog.show();",
          " * var cell = graph.getSelectionCell();",
          " * graph.traverse(cell, false, function(vertex, edge)",
          " * {",
          " *   mxLog.debug(graph.getLabel(vertex));",
          " * });",
          " * (end)",
          " *",
          " * @param vertex {@link mxCell} that represents the vertex where the traversal starts.",
          " * @param directed Optional boolean indicating if edges should only be traversed",
          " * from source to target. Default is true.",
          " * @param func Visitor function that takes the current vertex and the incoming",
          " * edge as arguments. The traversal stops if the function returns false.",
          " * @param edge Optional {@link mxCell} that represents the incoming edge. This is",
          " * null for the first step of the traversal.",
          " * @param visited Optional {@link mxDictionary} of cell paths for the visited cells.",
          " */"
        ]
      ],
      "isAncestor": [
        "isAncestor(parent: mxCell, child: mxCell, traverseAncestors?: boolean): boolean;",
        [
          "/**",
          " * Returns true if the given parent is an ancestor of the given child.",
          " *",
          " * @param parent {@link mxCell} that specifies the parent.",
          " * @param child {@link mxCell} that specifies the child.",
          " * @param traverseAncestors boolean whether to",
          " */"
        ]
      ],
      "isVertexMovable": [
        "isVertexMovable(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns a boolean indicating if the given {@link mxCell} is movable or",
          " * bendable by the algorithm. This implementation returns true if the given",
          " * cell is movable in the graph.",
          " *",
          " * @param cell {@link mxCell} whose movable state should be returned.",
          " */"
        ]
      ],
      "isVertexIgnored": [
        "isVertexIgnored(vertex: mxCell): boolean;",
        [
          "/**",
          " * Returns a boolean indicating if the given {@link mxCell} should be ignored by",
          " * the algorithm. This implementation returns false for all vertices.",
          " *",
          " * @param vertex {@link mxCell} whose ignored state should be returned.",
          " */"
        ]
      ],
      "isEdgeIgnored": [
        "isEdgeIgnored(edge: mxCell): boolean;",
        [
          "/**",
          " * Returns a boolean indicating if the given {@link mxCell} should be ignored by",
          " * the algorithm. This implementation returns false for all vertices.",
          " *",
          " * @param cell {@link mxCell} whose ignored state should be returned.",
          " */"
        ]
      ],
      "setEdgeStyleEnabled": [
        "setEdgeStyleEnabled(edge: mxCell, value: any): void;",
        [
          "/**",
          " * Disables or enables the edge style of the given edge.",
          " */"
        ]
      ],
      "setOrthogonalEdge": [
        "setOrthogonalEdge(edge: mxCell, value: any): void;",
        [
          "/**",
          " * Disables or enables orthogonal end segments of the given edge.",
          " */"
        ]
      ],
      "getParentOffset": [
        "getParentOffset(parent: mxCell): mxPoint;",
        [
          "/**",
          " * Determines the offset of the given parent to the parent",
          " * of the layout",
          " */"
        ]
      ],
      "setEdgePoints": [
        "setEdgePoints(edge: mxCell, points: Array<mxPoint>): void;",
        [
          "/**",
          " * Replaces the array of mxPoints in the geometry of the given edge",
          " * with the given array of mxPoints.",
          " */"
        ]
      ],
      "setVertexLocation": [
        "setVertexLocation(cell: mxCell, x: number, y: number): mxRectangle;",
        [
          "/**",
          " * Sets the new position of the given cell taking into account the size of",
          " * the bounding box if {@link useBoundingBox} is true. The change is only carried",
          " * out if the new location is not equal to the existing location, otherwise",
          " * the geometry is not replaced with an updated instance. The new or old",
          " * bounds are returned (including overlapping labels).",
          " *",
          " * @param cell {@link mxCell} whose geometry is to be set.",
          " * @param x Integer that defines the x-coordinate of the new location.",
          " * @param y Integer that defines the y-coordinate of the new location.",
          " */"
        ]
      ],
      "getVertexBounds": [
        "getVertexBounds(cell: mxCell): mxRectangle;",
        [
          "/**",
          " * Returns an {@link mxRectangle} that defines the bounds of the given cell or",
          " * the bounding box if {@link useBoundingBox} is true.",
          " */"
        ]
      ],
      ")": [
        "): Array<mxCell>;",
        [
          "/**",
          " * Shortcut to {@link mxGraph.updateGroupBounds} with moveGroup set to true.",
          " */"
        ]
      ]
    }
  ],
  "WeightedCellSorter": [
    [
      "/**",
      " * @class WeightedCellSorter",
      " *",
      " * A utility class used to track cells whilst sorting occurs on the weighted",
      " * sum of their connected edges. Does not violate (x.compareTo(y)==0) ==",
      " * (x.equals(y))",
      " *",
      " */"
    ],
    {
      "constructor": [
        "constructor(cell: mxCell, weightedValue: number);",
        [
          "/**",
          " * Constructs a new weighted cell sorted for the given cell and weight.",
          " * @constructor",
          " * @param {mxCell} cell",
          " * @param {number} weightedValue",
          " */"
        ]
      ],
      "weightedValue": [
        "weightedValue: number;",
        [
          "/**",
          " * The weighted value of the cell stored.",
          " */"
        ]
      ],
      "nudge": [
        "nudge: boolean;",
        [
          "/**",
          " * Whether or not to flip equal weight values.",
          " */"
        ]
      ],
      "visited": [
        "visited: boolean;",
        [
          "/**",
          " * Whether or not this cell has been visited in the current assignment.",
          " */"
        ]
      ],
      "rankIndex": [
        "rankIndex: number;",
        [
          "/**",
          " * The index this cell is in the model rank.",
          " */"
        ]
      ],
      "cell": [
        "cell: mxCell;",
        [
          "/**",
          " * The cell whose median value is being calculated.",
          " */"
        ]
      ],
      "compare": [
        "compare(a: WeightedCellSorter, b: WeightedCellSorter): number;",
        [
          "/**",
          " * Compares two WeightedCellSorters.",
          " */"
        ]
      ]
    }
  ],
  "mxParallelEdgeLayout": [
    null,
    {}
  ],
  "mxCompositeLayout": [
    null,
    {
      "constructor": [
        "constructor(graph: mxGraph, layouts: Array<mxGraphLayout>, master: mxGraphLayout);",
        null
      ]
    }
  ],
  "mxEdgeLabelLayout": [
    [
      "/**",
      " * Extends <mxGraphLayout> to implement an edge label layout. This layout",
      " * makes use of cell states, which means the graph must be validated in",
      " * a graph view (so that the label bounds are available) before this layout",
      " * can be executed.",
      " *",
      " * @example",
      " * ```javascript",
      " * var layout = new mxEdgeLabelLayout(graph);",
      " * layout.execute(graph.getDefaultParent());",
      " * ```",
      " */"
    ],
    {
      "constructor": [
        "constructor(graph: mxGraph, radius?: number);",
        [
          "/**",
          " * Constructs a new edge label layout.",
          " *",
          " * @param graph   {@link mxGraph} that contains the cells.",
          " */"
        ]
      ],
      "execute": [
        "execute(parent: mxCell): void;",
        [
          "/**",
          " * Implements {@link mxGraphLayout.execute}",
          " */"
        ]
      ],
      "placeLabels": [
        "placeLabels(v: Array<mxCell>, e: Array<mxCell>): void;",
        [
          "/**",
          " * Places the labels of the given edges.",
          " *",
          " * @param v   vertexes",
          " * @param e   edges",
          " */"
        ]
      ],
      "avoid": [
        "avoid(edge: mxCell, vertex: mxCell): void;",
        [
          "/**",
          " * Places the labels of the given edges.",
          " */"
        ]
      ]
    }
  ],
  "mxFastOrganicLayout": [
    null,
    {
      "useInputOrigin": [
        "useInputOrigin: boolean;",
        [
          "/**",
          " * Specifies if the top left corner of the input cells should be the origin of the layout result.  Default is true.",
          " */"
        ]
      ],
      "resetEdges": [
        "resetEdges: boolean;",
        [
          "/**",
          " * Specifies if all edge points of traversed edges should be removed.  Default is true.",
          " */"
        ]
      ],
      "disableEdgeStyle": [
        "disableEdgeStyle: boolean;",
        [
          "/**",
          " * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are modified by the result.  Default is true.",
          " */"
        ]
      ],
      "forceConstant": [
        "forceConstant: number;",
        [
          "/**",
          " * The force constant by which the attractive forces are divided and the replusive forces are multiple by the square of.  The value equates to the average radius there is of free space around each node.  Default is 50.",
          " */"
        ]
      ],
      "forceConstantSquared": [
        "forceConstantSquared: any;",
        [
          "/**",
          " * Cache of <forceConstant>^2 for performance.",
          " */"
        ]
      ],
      "minDistanceLimit": [
        "minDistanceLimit: number;",
        [
          "/**",
          " * Minimal distance limit.  Default is 2.  Prevents of dividing by zero.",
          " */"
        ]
      ],
      "minDistanceLimitSquared": [
        "minDistanceLimitSquared: number;",
        [
          "/**",
          " * Cached version of minDistanceLimit squared.",
          " */"
        ]
      ]
    }
  ],
  "mxArrow": [
    [
      "/**",
      " * Extends {@link mxShape} to implement an arrow shape. The shape is used to represent edges, not vertices.",
      " *",
      " * This shape is registered under {@link mxConstants.SHAPE_ARROW} in {@link mxCellRenderer}.",
      " */"
    ],
    {
      ");": [
        ");",
        [
          "/**",
          " * Constructs a new arrow shape.",
          " *",
          " * @param points         Array of {@link mxPoint} that define the points. This is stored in {@link mxShape.points}.",
          " * @param fill           String that defines the fill color. This is stored in {@link mxShape.fill}.",
          " * @param stroke         String that defines the stroke color. This is stored in {@link mxShape.stroke}.",
          " * @param strokewidth    Optional integer that defines the stroke width. Default is 1. This is stored in {@link mxShape.strokewidth}.",
          " * @param arrowWidth     Optional integer that defines the arrow width. Default is {@link mxConstants.ARROW_WIDTH}. This is stored in {@link mxShape.arrowWidth}.",
          " * @param spacing        Optional integer that defines the spacing between the arrow shape and its endpoints. Default is {@link mxConstants.ARROW_SPACING}. This is stored in {@link mxShape.spacing}.",
          " * @param endSize        Optional integer that defines the size of the arrowhead. Default is {@link mxConstants.ARROW_SIZE}. This is stored in {@link mxShape.endSize}.",
          " */"
        ]
      ],
      "augmentBoundingBox": [
        "augmentBoundingBox(bbox: mxRectangle): void;",
        [
          "/**",
          " * Augments the bounding box with the edge width and markers.",
          " */"
        ]
      ],
      "paintEdgeShape": [
        "paintEdgeShape(c: mxAbstractCanvas2D, pts: mxPoint[]): void;",
        [
          "/**",
          " * Paints the line shape.",
          " */"
        ]
      ]
    }
  ],
  "mxShape": [
    [
      "/**",
      " * Base class for all shapes.",
      " * A shape in mxGraph is a separate implementation for SVG, VML and HTML.",
      " * Which implementation to use is controlled by the dialect property which",
      " * is assigned from within the mxCellRenderer when the shape is created.",
      " * The dialect must be assigned for a shape, and it does normally depend on",
      " * the browser and the configuration of the graph (see mxGraph rendering hint).",
      " *",
      " * For each supported shape in SVG and VML, a corresponding shape exists in",
      " * mxGraph, namely for text, image, rectangle, rhombus, ellipse and polyline.",
      " * The other shapes are a combination of these shapes (eg. label and swimlane)",
      " * or they consist of one or more (filled) path objects (eg. actor and cylinder).",
      " * The HTML implementation is optional but may be required for a HTML-only view",
      " * of the graph.",
      " *",
      " * ### Custom Shapes",
      " * To extend from this class, the basic code looks as follows.",
      " * In the special case where the custom shape consists only of one filled region",
      " * or one filled region and an additional stroke the mxActor and mxCylinder",
      " * should be subclassed, respectively.",
      " * @example",
      " * ```javascript",
      " * function CustomShape() { }",
      " *",
      " * CustomShape.prototype = new mxShape();",
      " * CustomShape.prototype.constructor = CustomShape;",
      " * ```",
      " * To register a custom shape in an existing graph instance, one must register the",
      " * shape under a new name in the graphs cell renderer as follows:",
      " * @example",
      " * ```javascript",
      " * mxCellRenderer.registerShape('customShape', CustomShape);",
      " * ```",
      " * The second argument is the name of the constructor.",
      " * In order to use the shape you can refer to the given name above in a stylesheet.",
      " * For example, to change the shape for the default vertex style, the following code",
      " * is used:",
      " * @example",
      " * ```javascript",
      " * var style = graph.getStylesheet().getDefaultVertexStyle();",
      " * style.shape = 'customShape';",
      " * ```",
      " */"
    ],
    {
      "constructor": [
        "constructor(stencil: mxStencil);",
        [
          "/**",
          " * Constructs a new shape.",
          " * @param {mxStencil} stencil",
          " */"
        ]
      ],
      "fill": [
        "fill: string;",
        [
          "/**",
          " * Fill color.<br>",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "gradient": [
        "gradient: string;",
        [
          "/**",
          " * Gradient color.<br>",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "gradientDirection": [
        "gradientDirection: string;",
        [
          "/**",
          " * Gradient direction.<br>",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "opacity": [
        "opacity: number;",
        [
          "/**",
          " * Opacity. Possible range is `0-100`.<br>",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "fillOpacity": [
        "fillOpacity: number;",
        [
          "/**",
          " * Fill opacity. Possible range is `0-100`.<br>",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "strokeOpacity": [
        "strokeOpacity: number;",
        [
          "/**",
          " * Stroke opacity. Possible range is `0-100`.<br>",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "stroke": [
        "stroke: string;",
        [
          "/**",
          " * Stroke color.<br>",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "strokewidth": [
        "strokewidth: number;",
        [
          "/**",
          " * Stroke width.<br>",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "isShadow": [
        "isShadow: boolean;",
        [
          "/**",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "isDashed": [
        "isDashed: boolean;",
        [
          "/**",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "spacing": [
        "spacing: number;",
        [
          "/**",
          " * The value represents the spacing, in pixels, added to each side of a label in a vertex (style applies to vertices only).<br>",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "startSize": [
        "startSize: number;",
        [
          "/**",
          " *  Size of the start marker or the size of the swimlane title region depending on the shape it is used for.<br>",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "endSize": [
        "endSize: number;",
        [
          "/**",
          " *  Size of the end marker in pixels.<br>",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "isRounded": [
        "isRounded: boolean;",
        [
          "/**",
          " * For edges this determines whether or not joins between edges segments are smoothed to a rounded finish.<br>",
          " * For vertices that have the rectangle shape, this determines whether or not the rectangle is rounded.<br>",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "startArrow": [
        "startArrow: string;",
        [
          "/**",
          " * Possible values are all constants with an ARROW-prefix.<br>",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "endArrow": [
        "endArrow: string;",
        [
          "/**",
          " * Possible values are all constants with an ARROW-prefix.<br>",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "rotation": [
        "rotation: number;",
        [
          "/**",
          " * Possible range is 0-360.<br>",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "direction": [
        "direction: string;",
        [
          "/**",
          " * Specify the direction of certain shapes (eg. {@link mxTriangle}). Possible values are {@link mxConstants.DIRECTION_EAST} (default),",
          " * {@link mxConstants.DIRECTION_WEST}, {@link mxConstants.DIRECTION_NORTH}, and {@link mxConstants.DIRECTION_SOUTH}.<br>",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "glass": [
        "glass: boolean;",
        [
          "/**",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply}).",
          " */"
        ]
      ],
      "flipH": [
        "flipH: boolean;",
        [
          "/**",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply} implementation).",
          " */"
        ]
      ],
      "flipV": [
        "flipV: boolean;",
        [
          "/**",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply} implementation).",
          " */"
        ]
      ],
      "constraints": [
        "constraints: Array<mxConnectionConstraint>;",
        [
          "/**",
          " * <b>Note:</b> this property is not documented in the JavaScript API but it does exist and is necessary (see {@link apply} implementation).",
          " */"
        ]
      ],
      "dialect": [
        "dialect: string;",
        [
          "/**",
          " * Variable: dialect",
          " *",
          " * Holds the dialect in which the shape is to be painted.",
          " * This can be one of the DIALECT constants in <mxConstants>.",
          " */"
        ]
      ],
      "scale": [
        "scale: number;",
        [
          "/**",
          " * Variable: scale",
          " *",
          " * Holds the scale in which the shape is being painted.",
          " */"
        ]
      ],
      "antiAlias": [
        "antiAlias: boolean;",
        [
          "/**",
          " * Variable: antiAlias",
          " *",
          " * Rendering hint for configuring the canvas.",
          " */"
        ]
      ],
      "minSvgStrokeWidth": [
        "minSvgStrokeWidth: number;",
        [
          "/**",
          " * Variable: minSvgStrokeWidth",
          " *",
          " * Minimum stroke width for SVG output.",
          " */"
        ]
      ],
      "bounds": [
        "bounds: mxRectangle;",
        [
          "/**",
          " * Variable: bounds",
          " *",
          " * Holds the <mxRectangle> that specifies the bounds of this shape.",
          " */"
        ]
      ],
      "points": [
        "points: mxPoint[];",
        [
          "/**",
          " * Variable: points",
          " *",
          " * Holds the array of <mxPoints> that specify the points of this shape.",
          " */"
        ]
      ],
      "node": [
        "node: HTMLElement;",
        [
          "/**",
          " * Variable: node",
          " *",
          " * Holds the outermost DOM node that represents this shape.",
          " */"
        ]
      ],
      "state?": [
        "state?: mxCellState;",
        [
          "/**",
          " * Variable: state",
          " *",
          " * Optional reference to the corresponding <mxCellState>.",
          " */"
        ]
      ],
      "style?": [
        "style?: { [key: string]: any };",
        [
          "/**",
          " * Variable: style",
          " *",
          " * Optional reference to the style of the corresponding <mxCellState>.",
          " */"
        ]
      ],
      "boundingBox": [
        "boundingBox: mxRectangle;",
        [
          "/**",
          " * Variable: boundingBox",
          " *",
          " * Contains the bounding box of the shape, that is, the smallest rectangle",
          " * that includes all pixels of the shape.",
          " */"
        ]
      ],
      "stencil": [
        "stencil: mxStencil;",
        [
          "/**",
          " * Variable: stencil",
          " *",
          " * Holds the <mxStencil> that defines the shape.",
          " */"
        ]
      ],
      "svgStrokeTolerance": [
        "svgStrokeTolerance: number;",
        [
          "/**",
          " * Variable: svgStrokeTolerance",
          " *",
          " * Event-tolerance for SVG strokes (in px). Default is 8. This is only passed",
          " * to the canvas in <createSvgCanvas> if <pointerEvents> is true.",
          " */"
        ]
      ],
      "pointerEvents": [
        "pointerEvents: boolean;",
        [
          "/**",
          " * Variable: pointerEvents",
          " *",
          " * Specifies if pointer events should be handled. Default is true.",
          " */"
        ]
      ],
      "svgPointerEvents": [
        "svgPointerEvents: 'all';",
        [
          "/**",
          " * Variable: svgPointerEvents",
          " *",
          " * Specifies if pointer events should be handled. Default is true.",
          " */"
        ]
      ],
      "shapePointerEvents": [
        "shapePointerEvents: boolean;",
        [
          "/**",
          " * Variable: shapePointerEvents",
          " *",
          " * Specifies if pointer events outside of shape should be handled. Default",
          " * is false.",
          " */"
        ]
      ],
      "stencilPointerEvents": [
        "stencilPointerEvents: boolean;",
        [
          "/**",
          " * Variable: stencilPointerEvents",
          " *",
          " * Specifies if pointer events outside of stencils should be handled. Default",
          " * is false. Set this to true for backwards compatibility with the 1.x branch.",
          " */"
        ]
      ],
      "vmlScale": [
        "vmlScale: number;",
        [
          "/**",
          " * Variable: vmlScale",
          " *",
          " * Scale for improving the precision of VML rendering. Default is 1.",
          " */"
        ]
      ],
      "outline": [
        "outline: boolean;",
        [
          "/**",
          " * Variable: outline",
          " *",
          " * Specifies if the shape should be drawn as an outline. This disables all",
          " * fill colors and can be used to disable other drawing states that should",
          " * not be painted for outlines. Default is false. This should be set before",
          " * calling <apply>.",
          " */"
        ]
      ],
      "visible": [
        "visible: boolean;",
        [
          "/**",
          " * Variable: visible",
          " *",
          " * Specifies if the shape is visible. Default is true.",
          " */"
        ]
      ],
      "useSvgBoundingBox": [
        "useSvgBoundingBox: boolean;",
        [
          "/**",
          " * Variable: useSvgBoundingBox",
          " *",
          " * Allows to use the SVG bounding box in SVG. Default is false for performance",
          " * reasons.",
          " */"
        ]
      ],
      "init": [
        "init(container: Element): void;",
        [
          "/**",
          " * Function: init",
          " *",
          " * Initializes the shape by creaing the DOM node using <create>",
          " * and adding it into the given container.",
          " *",
          " * Parameters:",
          " *",
          " * container - DOM node that will contain the shape.",
          " */"
        ]
      ],
      "initStyles": [
        "initStyles(container: Element): void;",
        [
          "/**",
          " * Function: initStyles",
          " *",
          " * Sets the styles to their default values.",
          " */"
        ]
      ],
      "isParseVml": [
        "isParseVml(): boolean;",
        [
          "/**",
          " * Function: isParseVml",
          " *",
          " * Specifies if any VML should be added via insertAdjacentHtml to the DOM. This",
          " * is only needed in IE8 and only if the shape contains VML markup. This method",
          " * returns true.",
          " */"
        ]
      ],
      "isHtmlAllowed": [
        "isHtmlAllowed(): boolean;",
        [
          "/**",
          " * Function: isHtmlAllowed",
          " *",
          " * Returns true if HTML is allowed for this shape. This implementation always",
          " * returns false.",
          " */"
        ]
      ],
      "getSvgScreenOffset": [
        "getSvgScreenOffset(): number;",
        [
          "/**",
          " * Function: getSvgScreenOffset",
          " *",
          " * Returns 0, or 0.5 if <strokewidth> % 2 == 1.",
          " */"
        ]
      ],
      "create": [
        "create(container: Element): Element;",
        [
          "/**",
          " * Function: create",
          " *",
          " * Creates and returns the DOM node(s) for the shape in",
          " * the given container. This implementation invokes",
          " * <createSvg>, <createHtml> or <createVml> depending",
          " * on the <dialect> and style settings.",
          " *",
          " * Parameters:",
          " *",
          " * container - DOM node that will contain the shape.",
          " */"
        ]
      ],
      "createSvg": [
        "createSvg(): Element;",
        [
          "/**",
          " * Function: createSvg",
          " *",
          " * Creates and returns the SVG node(s) to represent this shape.",
          " */"
        ]
      ],
      "createVml": [
        "createVml(): Element;",
        [
          "/**",
          " * Function: createVml",
          " *",
          " * Creates and returns the VML node to represent this shape.",
          " */"
        ]
      ],
      "createHtml": [
        "createHtml(): HTMLElement;",
        [
          "/**",
          " * Function: createHtml",
          " *",
          " * Creates and returns the HTML DOM node(s) to represent",
          " * this shape. This implementation falls back to <createVml>",
          " * so that the HTML creation is optional.",
          " */"
        ]
      ],
      "reconfigure": [
        "reconfigure(): void;",
        [
          "/**",
          " * Function: reconfigure",
          " *",
          " * Reconfigures this shape. This will update the colors etc in",
          " * addition to the bounds or points.",
          " */"
        ]
      ],
      "redraw": [
        "redraw(): void;",
        [
          "/**",
          " * Function: redraw",
          " *",
          " * Creates and returns the SVG node(s) to represent this shape.",
          " */"
        ]
      ],
      "clear": [
        "clear(): void;",
        [
          "/**",
          " * Function: clear",
          " *",
          " * Removes all child nodes and resets all CSS.",
          " */"
        ]
      ],
      "updateBoundsFromPoints": [
        "updateBoundsFromPoints(): void;",
        [
          "/**",
          " * Function: updateBoundsFromPoints",
          " *",
          " * Updates the bounds based on the points.",
          " */"
        ]
      ],
      "getLabelBounds": [
        "getLabelBounds(rect: mxRectangle): mxRectangle;",
        [
          "/**",
          " * Function: getLabelBounds",
          " *",
          " * Returns the <mxRectangle> for the label bounds of this shape, based on the",
          " * given scaled and translated bounds of the shape. This method should not",
          " * change the rectangle in-place. This implementation returns the given rect.",
          " */"
        ]
      ],
      "getLabelMargins": [
        "getLabelMargins(rect: mxRectangle): mxRectangle | null;",
        [
          "/**",
          " * Function: getLabelMargins",
          " *",
          " * Returns the scaled top, left, bottom and right margin to be used for",
          " * computing the label bounds as an <mxRectangle>, where the bottom and right",
          " * margin are defined in the width and height of the rectangle, respectively.",
          " */"
        ]
      ],
      "checkBounds": [
        "checkBounds(): boolean;",
        [
          "/**",
          " * Function: checkBounds",
          " *",
          " * Returns true if the bounds are not null and all of its variables are numeric.",
          " */"
        ]
      ],
      "createVmlGroup": [
        "createVmlGroup(): Element;",
        [
          "/**",
          " * Function: createVmlGroup",
          " *",
          " * Returns the temporary element used for rendering in IE8 standards mode.",
          " */"
        ]
      ],
      "redrawShape": [
        "redrawShape(): void;",
        [
          "/**",
          " * Function: redrawShape",
          " *",
          " * Updates the SVG or VML shape.",
          " */"
        ]
      ],
      "createCanvas": [
        "createCanvas(): Element;",
        [
          "/**",
          " * Function: createCanvas",
          " *",
          " * Creates a new canvas for drawing this shape. May return null.",
          " */"
        ]
      ],
      "createSvgCanvas": [
        "createSvgCanvas(): mxSvgCanvas2D;",
        [
          "/**",
          " * Function: createSvgCanvas",
          " *",
          " * Creates and returns an <mxSvgCanvas2D> for rendering this shape.",
          " */"
        ]
      ],
      "createVmlCanvas": [
        "createVmlCanvas(): mxVmlCanvas2D;",
        [
          "/**",
          " * Function: createVmlCanvas",
          " *",
          " * Creates and returns an <mxVmlCanvas2D> for rendering this shape.",
          " */"
        ]
      ],
      "updateVmlContainer": [
        "updateVmlContainer(): void;",
        [
          "/**",
          " * Function: updateVmlContainer",
          " *",
          " * Updates the bounds of the VML container.",
          " */"
        ]
      ],
      "redrawHtmlShape": [
        "redrawHtmlShape(): void;",
        [
          "/**",
          " * Function: redrawHtml",
          " *",
          " * Allow optimization by replacing VML with HTML.",
          " */"
        ]
      ],
      "updateHtmlFilters": [
        "updateHtmlFilters(node: HTMLElement): void;",
        [
          "/**",
          " * Function: updateHtmlFilters",
          " *",
          " * Allow optimization by replacing VML with HTML.",
          " */"
        ]
      ],
      "updateHtmlColors": [
        "updateHtmlColors(node: HTMLElement): void;",
        [
          "/**",
          " * Function: mixedModeHtml",
          " *",
          " * Allow optimization by replacing VML with HTML.",
          " */"
        ]
      ],
      "updateHtmlBounds": [
        "updateHtmlBounds(node: HTMLElement): void;",
        [
          "/**",
          " * Function: mixedModeHtml",
          " *",
          " * Allow optimization by replacing VML with HTML.",
          " */"
        ]
      ],
      "paint": [
        "paint(c: mxAbstractCanvas2D): void;",
        [
          "/**",
          " * Generic rendering code.",
          " */"
        ]
      ],
      "configureCanvas": [
        "configureCanvas(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Sets the state of the canvas for drawing the shape.",
          " */"
        ]
      ],
      "getGradientBounds": [
        "getGradientBounds(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): mxRectangle;",
        [
          "/**",
          " * Function: getGradientBounds",
          " *",
          " * Returns the bounding box for the gradient box for this shape.",
          " */"
        ]
      ],
      "updateTransform": [
        "updateTransform(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Function: updateTransform",
          " *",
          " * Sets the scale and rotation on the given canvas.",
          " */"
        ]
      ],
      "paintVertexShape": [
        "paintVertexShape(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Function: paintVertexShape",
          " *",
          " * Paints the vertex shape.",
          " */"
        ]
      ],
      "paintBackground": [
        "paintBackground(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Function: paintBackground",
          " *",
          " * Hook for subclassers. This implementation is empty.",
          " */"
        ]
      ],
      "paintForeground": [
        "paintForeground(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Hook for subclassers. This implementation is empty.",
          " */"
        ]
      ],
      "paintEdgeShape": [
        "paintEdgeShape(c: mxAbstractCanvas2D, pts: mxPoint[]): void;",
        [
          "/**",
          " * Function: paintEdgeShape",
          " *",
          " * Hook for subclassers. This implementation is empty.",
          " */"
        ]
      ],
      "getArcSize": [
        "getArcSize(w: number, h: number): number;",
        [
          "/**",
          " * Function: getArcSize",
          " *",
          " * Returns the arc size for the given dimension.",
          " */"
        ]
      ],
      "paintGlassEffect": [
        "paintGlassEffect(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number, arc: number): void;",
        [
          "/**",
          " * Function: paintGlassEffect",
          " *",
          " * Paints the glass gradient effect.",
          " */"
        ]
      ],
      ")": [
        "): void;",
        [
          "/**",
          " * Paints the given points with rounded corners.",
          " */"
        ]
      ],
      "resetStyles": [
        "resetStyles(): void;",
        [
          "/**",
          " * Function: resetStyles",
          " *",
          " * Resets all styles.",
          " */"
        ]
      ],
      "apply": [
        "apply(state: mxCellState): void;",
        [
          "/**",
          " * Function: apply",
          " *",
          " * Applies the style of the given <mxCellState> to the shape. This",
          " * implementation assigns the following styles to local fields:",
          " *",
          " * - <'fillColor'> => fill",
          " * - <'gradientColor'> => gradient",
          " * - <'gradientDirection'> => gradientDirection",
          " * - <'opacity'> => opacity",
          " * - <mxConstants.STYLE_FILL_OPACITY> => fillOpacity",
          " * - <mxConstants.STYLE_STROKE_OPACITY> => strokeOpacity",
          " * - <'strokeColor'> => stroke",
          " * - <'strokeWidth'> => strokewidth",
          " * - <'shadow'> => isShadow",
          " * - <'dashed'> => isDashed",
          " * - <'spacing'> => spacing",
          " * - <'startSize'> => startSize",
          " * - <'endSize'> => endSize",
          " * - <'rounded'> => isRounded",
          " * - <'startArrow'> => startArrow",
          " * - <'endArrow'> => endArrow",
          " * - <'rotation'> => rotation",
          " * - <'direction'> => direction",
          " * - <'glass'> => glass",
          " *",
          " * This keeps a reference to the <style>. If you need to keep a reference to",
          " * the cell, you can override this method and store a local reference to",
          " * state.cell or the <mxCellState> itself. If <outline> should be true, make",
          " * sure to set it before calling this method.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> of the corresponding cell.",
          " */"
        ]
      ],
      "setCursor": [
        "setCursor(cursor: string): void;",
        [
          "/**",
          " * Function: setCursor",
          " *",
          " * Sets the cursor on the given shape.",
          " *",
          " * Parameters:",
          " *",
          " * cursor - The cursor to be used.",
          " */"
        ]
      ],
      "getCursor": [
        "getCursor(): string;",
        [
          "/**",
          " * Function: getCursor",
          " *",
          " * Returns the current cursor.",
          " */"
        ]
      ],
      "isRoundable": [
        "isRoundable(): boolean;",
        [
          "/**",
          " * Hook for subclassers.",
          " */"
        ]
      ],
      "updateBoundingBox": [
        "updateBoundingBox(): void;",
        [
          "/**",
          " * Function: updateBoundingBox",
          " *",
          " * Updates the <boundingBox> for this shape using <createBoundingBox> and",
          " * <augmentBoundingBox> and stores the result in <boundingBox>.",
          " */"
        ]
      ],
      "createBoundingBox": [
        "createBoundingBox(): mxRectangle;",
        [
          "/**",
          " * Function: createBoundingBox",
          " *",
          " * Returns a new rectangle that represents the bounding box of the bare shape",
          " * with no shadows or strokewidths.",
          " */"
        ]
      ],
      "augmentBoundingBox": [
        "augmentBoundingBox(bbox: mxRectangle): void;",
        [
          "/**",
          " * Augments the bounding box with the strokewidth and shadow offsets.",
          " */"
        ]
      ],
      "isPaintBoundsInverted": [
        "isPaintBoundsInverted(): boolean;",
        [
          "/**",
          " * Function: isPaintBoundsInverted",
          " *",
          " * Returns true if the bounds should be inverted.",
          " */"
        ]
      ],
      "getRotation": [
        "getRotation(): number;",
        [
          "/**",
          " * Function: getRotation",
          " *",
          " * Returns the rotation from the style.",
          " */"
        ]
      ],
      "getTextRotation": [
        "getTextRotation(): number;",
        [
          "/**",
          " * Function: getTextRotation",
          " *",
          " * Returns the rotation for the text label.",
          " */"
        ]
      ],
      "getShapeRotation": [
        "getShapeRotation(): number;",
        [
          "/**",
          " * Function: getShapeRotation",
          " *",
          " * Returns the actual rotation of the shape.",
          " */"
        ]
      ],
      "createTransparentSvgRectangle": [
        "createTransparentSvgRectangle(x: number, y: number, w: number, h: number): Element;",
        [
          "/**",
          " * Function: createTransparentSvgRectangle",
          " *",
          " * Adds a transparent rectangle that catches all events.",
          " */"
        ]
      ],
      "setTransparentBackgroundImage": [
        "setTransparentBackgroundImage(node: Element): void;",
        [
          "/**",
          " * Function: setTransparentBackgroundImage",
          " *",
          " * Sets a transparent background CSS style to catch all events.",
          " *",
          " * Paints the line shape.",
          " */"
        ]
      ],
      "releaseSvgGradients": [
        "releaseSvgGradients(grads: any[]): void;",
        [
          "/**",
          " * Function: releaseSvgGradients",
          " *",
          " * Paints the line shape.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Function: destroy",
          " *",
          " * Destroys the shape by removing it from the DOM and releasing the DOM",
          " * node associated with the shape using <mxEvent.release>.",
          " */"
        ]
      ]
    }
  ],
  "mxRectangleShape": [
    [
      "/**",
      " * Extends {@link mxShape} to implement a rectangle shape.",
      " * This shape is registered under {@link mxConstants.SHAPE_RECTANGLE} in {@link mxCellRenderer}.",
      " * @class mxRectangleShape",
      " * @extends {mxShape}",
      " */"
    ],
    {
      "constructor": [
        "constructor(bounds: mxRectangle, fill: string, stroke: string, strokewidth?: number);",
        [
          "/**",
          " * @param {mxRectangle} bounds",
          " * @param {string} fill",
          " * @param {string} stroke",
          " * @param {number} [strokewidth]",
          " */"
        ]
      ],
      "isHtmlAllowed": [
        "isHtmlAllowed(): boolean;",
        [
          "/**",
          " * Returns true for non-rounded, non-rotated shapes with no glass gradient.",
          " */"
        ]
      ],
      "paintBackground": [
        "paintBackground(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Generic background painting implementation.",
          " */"
        ]
      ],
      "isRoundable": [
        "isRoundable(c?: mxAbstractCanvas2D, x?: number, y?: number, w?: number, h?: number): boolean;",
        [
          "/**",
          " * Adds roundable support.",
          " */"
        ]
      ],
      "paintForeground": [
        "paintForeground(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Generic background painting implementation.",
          " */"
        ]
      ]
    }
  ],
  "mxConnector": [
    [
      "/**",
      " * Extends {@link mxShape} to implement a connector shape.",
      " * The connector shape allows for arrow heads on either side.",
      " * This shape is registered under {@link mxConstants.SHAPE_CONNECTOR} in {@link mxCellRenderer}.",
      " *",
      " * @class mxConnector",
      " * @extends {mxPolyline}",
      " */"
    ],
    {
      "constructor": [
        "constructor(points: mxPoint[], stroke: string, strokewidth?: number);",
        [
          "/**",
          " * Constructs a new connector shape.",
          " *",
          " * @param {mxPoint[]} points - Array of {@link mxPoints} that define the points.  This is stored in {@link mxShape.points}.",
          " * @param {string} stroke - String that defines the stroke color.  This is stored in <stroke>.  Default is black.",
          " * @param {number} [strokewidth] - Optional integer that defines the stroke width.  Default is 1.  This is stored in <strokewidth>.",
          " */"
        ]
      ],
      "updateBoundingBox": [
        "updateBoundingBox(): void;",
        [
          "/**",
          " * Updates the <boundingBox> for this shape using <createBoundingBox>",
          " * and augmentBoundingBox and stores the result in <boundingBox>.",
          " */"
        ]
      ],
      "paintEdgeShape": [
        "paintEdgeShape(c: mxAbstractCanvas2D, pts: mxPoint[]): void;",
        [
          "/**",
          " * Paints the line shape.",
          " */"
        ]
      ],
      "createMarker": [
        "createMarker(c: mxAbstractCanvas2D, pts: mxPoint[], source: boolean): mxMarker;",
        [
          "/**",
          " * Prepares the marker by adding offsets in pts and returning a function to paint the marker.",
          " */"
        ]
      ],
      "augmentBoundingBox": [
        "augmentBoundingBox(bbox: mxRectangle): void;",
        [
          "/**",
          " * Augments the bounding box with the strokewidth and shadow offsets.",
          " */"
        ]
      ]
    }
  ],
  "mxTriangle": [
    [
      "/**",
      " * Implementation of the triangle shape.",
      " * @class mxTriangle",
      " * @extends {mxActor}",
      " */"
    ],
    {
      "constructor": [
        "constructor();",
        null
      ],
      "isRoundable": [
        "isRoundable(): boolean;",
        [
          "/**",
          " * Adds roundable support.",
          " * @returns {boolean}",
          " */"
        ]
      ],
      "redrawPath": [
        "redrawPath(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Draws the path for this shape.",
          " * @param {mxAbstractCanvas2D} c",
          " * @param {number} x",
          " * @param {number} y",
          " * @param {number} w",
          " * @param {number} h",
          " */"
        ]
      ]
    }
  ],
  "mxHexagon": [
    [
      "/**",
      " * Implementation of the hexagon shape.",
      " * @class mxHexagon",
      " * @extends {mxActor}",
      " */"
    ],
    {
      "constructor": [
        "constructor();",
        [
          "/**",
          " * Constructs a new hexagon shape.",
          " */"
        ]
      ],
      "redrawPath": [
        "redrawPath(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Draws the path for this shape.",
          " * @param {mxAbstractCanvas2D} c",
          " * @param {number} x",
          " * @param {number} y",
          " * @param {number} w",
          " * @param {number} h",
          " */"
        ]
      ]
    }
  ],
  "mxCloud": [
    [
      "/**",
      " * Extends {@link mxActor} to implement a cloud shape.",
      " *",
      " * This shape is registered under {@link mxConstants.SHAPE_CLOUD} in {@link mxCellRenderer}.",
      " */"
    ],
    {
      "constructor": [
        "constructor(bounds: mxRectangle, fill: string, stroke: string, strokewidth?: number);",
        [
          "/**",
          " * Constructs a new actor shape.",
          " *",
          " * @param bounds         {@link mxRectangle} that defines the bounds. This is stored in {@link mxShape.bounds}.",
          " * @param fill           String that defines the fill color. This is stored in {@link mxShape.fill}.",
          " * @param stroke         String that defines the stroke color. This is stored in {@link mxShape.stroke}.",
          " * @param strokewidth    Optional integer that defines the stroke width. Default is 1. This is stored in {@link mxShape.strokewidth}.",
          " */"
        ]
      ],
      "redrawPath": [
        "redrawPath(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Draws the path for this shape.",
          " */"
        ]
      ]
    }
  ],
  "mxCylinder": [
    [
      "/**",
      " * Extends {@link mxShape} to implement an cylinder shape. If a custom shape with one filled area and an overlay path is",
      " * needed, then this shape's {@link redrawPath} should be overridden.",
      " *",
      " * This shape is registered under {@link mxConstants.SHAPE_CYLINDER} in {@link mxCellRenderer}.",
      " */"
    ],
    {
      "constructor": [
        "constructor(bounds: mxRectangle, fill: string, stroke: string, strokewidth?: number);",
        [
          "/**",
          " * Constructs a new cylinder shape.",
          " *",
          " * @param bounds         {@link mxRectangle} that defines the bounds. This is stored in {@link mxShape.bounds}.",
          " * @param fill           String that defines the fill color. This is stored in {@link mxShape.fill}.",
          " * @param stroke         String that defines the stroke color. This is stored in {@link mxShape.stroke}.",
          " * @param strokewidth    Optional integer that defines the stroke width. Default is 1. This is stored in {@link mxShape.strokewidth}.",
          " */"
        ]
      ],
      "maxHeight": [
        "maxHeight: number;",
        [
          "/**",
          " * Defines the maximum height of the top and bottom part of the cylinder shape.",
          " */"
        ]
      ],
      "svgStrokeTolerance": [
        "svgStrokeTolerance: number;",
        [
          "/**",
          " * Sets stroke tolerance to 0 for SVG.",
          " */"
        ]
      ],
      "paintVertexShape": [
        "paintVertexShape(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Redirects to redrawPath for subclasses to work.",
          " */"
        ]
      ],
      "getCylinderSize": [
        "getCylinderSize(x: number, y: number, w: number, h: number): number;",
        [
          "/**",
          " * Redirects to redrawPath for subclasses to work.",
          " */"
        ]
      ],
      "redrawPath": [
        "redrawPath(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number, isForeground: boolean): void;",
        [
          "/**",
          " * Draws the path for this shape.",
          " */"
        ]
      ]
    }
  ],
  "mxSwimlane": [
    [
      "/**",
      " * Extends {@link mxShape} to implement a swimlane shape.",
      " * This shape is registered under {@link mxConstants.SHAPE_SWIMLANE} in {@link mxCellRenderer}.",
      " * Use the {@link mxConstants.STYLE_STYLE_STARTSIZE} to define the size of the title",
      " * region, {@link 'swimlaneFillColor'} for the content area fill,",
      " * {@link mxConstants.STYLE_SEPARATORCOLOR} to draw an additional vertical separator and",
      " * {@link mxConstants.STYLE_SWIMLANE_LINE} to hide the line between the title region and",
      " * the content area.",
      " * The {@link 'horizontal'} affects the orientation of this shape,",
      " * not only its label.",
      " *",
      " * @class mxSwimlane",
      " * @extends {mxShape}",
      " */"
    ],
    {
      "constructor": [
        "constructor(bounds: mxRectangle, fill: string, stroke: string, strokewidth?: number);",
        [
          "/**",
          " * Constructs a new swimlane shape.",
          " * @param {mxRectangle} bounds      {@link mxRectangle} that defines the bounds.  This is stored in mxShape.bounds.",
          " * @param {string} fill             String that defines the fill color.  This is stored in <fill>.",
          " * @param {string} stroke           String that defines the stroke color.  This is stored in <stroke>.",
          " * @param {number} [strokewidth]    Optional integer that defines the stroke width.  Default is 1.  This is stored in <strokewidth>.",
          " */"
        ]
      ],
      "imageSize": [
        "imageSize: number;",
        [
          "/**",
          " *",
          " * Default imagewidth and imageheight if an image but no imagewidth",
          " * and imageheight are defined in the style. Value is 16.",
          " * @type {number}",
          " * @default 16",
          " */"
        ]
      ],
      "isRoundable": [
        "isRoundable(c?: mxAbstractCanvas2D, x?: number, y?: number, w?: number, h?: number): boolean;",
        [
          "/**",
          " * Adds roundable support.",
          " * @param {mxAbstractCanvas2D} c",
          " * @param {number} x",
          " * @param {number} y",
          " * @param {number} w",
          " * @param {number} h",
          " * @returns {boolean}",
          " */"
        ]
      ],
      "getTitleSize": [
        "getTitleSize(): number;",
        [
          "/**",
          " * Returns the bounding box for the gradient box for this shape.",
          " */"
        ]
      ],
      "getLabelBounds": [
        "getLabelBounds(rect: mxRectangle): mxRectangle;",
        [
          "/**",
          " * Returns the bounding box for the gradient box for this shape.",
          " */"
        ]
      ],
      "getGradientBounds": [
        "getGradientBounds(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): mxRectangle;",
        [
          "/**",
          " * Returns the bounding box for the gradient box for this shape.",
          " */"
        ]
      ],
      "getArcSize": [
        "getArcSize(w: number, h: number, start?: number): number;",
        [
          "/**",
          " * Returns the arcsize for the swimlane.",
          " */"
        ]
      ],
      "isHorizontal": [
        "isHorizontal(): boolean;",
        [
          "/**",
          " * Paints the swimlane vertex shape.",
          " */"
        ]
      ],
      "paintVertexShape": [
        "paintVertexShape(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Paints the swimlane vertex shape.",
          " */"
        ]
      ],
      ")": [
        "): void;",
        [
          "/**",
          " * Paints the vertical or horizontal separator line between swimlanes.",
          " */"
        ]
      ],
      "getImageBounds": [
        "getImageBounds(x: number, y: number, w: number, h: number): mxRectangle;",
        [
          "/**",
          " * Paints the swimlane vertex shape.",
          " */"
        ]
      ]
    }
  ],
  "mxActor": [
    [
      "/**",
      " * Extends {@link mxShape} to implement an actor shape. If a custom shape with one",
      " * filled area is needed, then this shape's {@link redrawPath} method should be overridden.",
      " *",
      " * This shape is registered under {@link mxConstants.SHAPE_ACTOR} in {@link mxCellRenderer}.",
      " *",
      " * @example",
      " * ```javascript",
      " * function SampleShape() { }",
      " *",
      " * SampleShape.prototype = new mxActor();",
      " * SampleShape.prototype.constructor = vsAseShape;",
      " *",
      " * mxCellRenderer.registerShape('sample', SampleShape);",
      " * SampleShape.prototype.redrawPath = function(path, x, y, w, h)",
      " * {",
      " *   path.moveTo(0, 0);",
      " *   path.lineTo(w, h);",
      " *   // ...",
      " *   path.close();",
      " * }",
      " * ```",
      " */"
    ],
    {
      "constructor": [
        "constructor(bounds: mxRectangle, fill: string, stroke: string, strokewidth?: number);",
        [
          "/**",
          " * Constructs a new actor shape.",
          " *",
          " * @param bounds         {@link mxRectangle} that defines the bounds. This is stored in {@link mxShape.bounds}.",
          " * @param fill           String that defines the fill color. This is stored in {@link mxShape.fill}.",
          " * @param stroke         String that defines the stroke color. This is stored in {@link mxShape.stroke}.",
          " * @param strokewidth    Optional integer that defines the stroke width. Default is 1. This is stored in {@link mxShape.strokewidth}.",
          " */"
        ]
      ],
      "paintVertexShape": [
        "paintVertexShape(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Redirects to redrawPath for subclasses to work.",
          " */"
        ]
      ],
      "redrawPath": [
        "redrawPath(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Draws the path for this shape.",
          " */"
        ]
      ]
    }
  ],
  "mxPolyline": [
    null,
    {
      "constructor": [
        "constructor(points: Array<mxPoint>, stroke: string, strokewidth?: number);",
        [
          "/**",
          " * Constructs a new polyline shape.",
          " * @param {Array<mxPoint>} points   Array of mxPoints that define the points.  This is stored in mxShape.points.",
          " * @param {string} stroke           String that defines the stroke color.  Default is black.  This is stored in <stroke>.",
          " * @param {number} [strokewidth]    Optional integer that defines the stroke width.  Default is 1.  This is stored in <strokewidth>.",
          " */"
        ]
      ],
      "getRotation": [
        "getRotation(): number;",
        [
          "/**",
          " * Returns 0.",
          " */"
        ]
      ],
      "getShapeRotation": [
        "getShapeRotation(): number;",
        [
          "/**",
          " * Returns 0.",
          " */"
        ]
      ],
      "isPaintBoundsInverted": [
        "isPaintBoundsInverted(): boolean;",
        [
          "/**",
          " * Returns false.",
          " */"
        ]
      ],
      "paintEdgeShape": [
        "paintEdgeShape(c: mxAbstractCanvas2D, pts: Array<mxPoint>): void;",
        [
          "/**",
          " * Paints the line shape.",
          " */"
        ]
      ],
      "paintLine": [
        "paintLine(c: mxAbstractCanvas2D, pts: Array<mxPoint>, rounded?: boolean): void;",
        [
          "/**",
          " * Paints the line shape.",
          " */"
        ]
      ],
      "paintCurvedLine": [
        "paintCurvedLine(c: mxAbstractCanvas2D, pts: Array<mxPoint>): void;",
        [
          "/**",
          " * Paints the line shape.",
          " */"
        ]
      ]
    }
  ],
  "mxText": [
    [
      "/**",
      " * Extends mxShape to implement a text shape.",
      " * To change vertical text from bottom to top to top to bottom,",
      " * the following code can be used:",
      " * @example",
      " * ```javascript",
      " * mxText.prototype.verticalTextRotation = 90;",
      " * ```",
      " * @class mxText",
      " * @extends {mxShape}",
      " */"
    ],
    {
      ");": [
        ");",
        [
          "/**",
          " * @param value             String that represents the text to be displayed.  This is stored in <value>.",
          " * @param bounds            mxRectangle that defines the bounds.  This is stored in mxShape.bounds.",
          " * @param align             Specifies the horizontal alignment.  Default is .  This is stored in <align>.",
          " * @param valign            Specifies the vertical alignment.  Default is .  This is stored in <valign>.",
          " * @param color             String that specifies the text color.  Default is black.  This is stored in <color>.",
          " * @param family            String that specifies the font family.  Default is mxConstants.DEFAULT_FONTFAMILY.  This is stored in <family>.",
          " * @param size              Integer that specifies the font size.  Default is mxConstants.DEFAULT_FONTSIZE.  This is stored in <size>.",
          " * @param fontStyle         Specifies the font style.  Default is 0.  This is stored in <fontStyle>.",
          " * @param spacing           Integer that specifies the global spacing.  Default is 2.  This is stored in <spacing>.",
          " * @param spacingTop        Integer that specifies the top spacing.  Default is 0.  The sum of the spacing and this is stored in <spacingTop>.",
          " * @param spacingRight      Integer that specifies the right spacing.  Default is 0.  The sum of the spacing and this is stored in <spacingRight>.",
          " * @param spacingBottom     Integer that specifies the bottom spacing.  Default is 0.The sum of the spacing and this is stored in <spacingBottom>.",
          " * @param spacingLeft       Integer that specifies the left spacing.  Default is 0.  The sum of the spacing and this is stored in <spacingLeft>.",
          " * @param horizontal        Boolean that specifies if the label is horizontal.  Default is true.  This is stored in <horizontal>.",
          " * @param background        String that specifies the background color.  Default is null.  This is stored in <background>.",
          " * @param border            String that specifies the label border color.  Default is null.  This is stored in <border>.",
          " * @param wrap              Specifies if word-wrapping should be enabled.  Default is false.  This is stored in <wrap>.",
          " * @param clipped           Specifies if the label should be clipped.  Default is false.  This is stored in <clipped>.",
          " * @param overflow          Value of the overflow style.  Default is visible.",
          " */"
        ]
      ],
      "baseSpacingTop": [
        "baseSpacingTop: number;",
        [
          "/**",
          " * Variable: baseSpacingTop",
          " *",
          " * Specifies the spacing to be added to the top spacing. Default is 0. Use the",
          " * value 5 here to get the same label positions as in mxGraph 1.x.",
          " */"
        ]
      ],
      "baseSpacingBottom": [
        "baseSpacingBottom: number;",
        [
          "/**",
          " * Variable: baseSpacingBottom",
          " *",
          " * Specifies the spacing to be added to the bottom spacing. Default is 0. Use the",
          " * value 1 here to get the same label positions as in mxGraph 1.x.",
          " */"
        ]
      ],
      "baseSpacingLeft": [
        "baseSpacingLeft: number;",
        [
          "/**",
          " * Variable: baseSpacingLeft",
          " *",
          " * Specifies the spacing to be added to the left spacing. Default is 0.",
          " */"
        ]
      ],
      "baseSpacingRight": [
        "baseSpacingRight: number;",
        [
          "/**",
          " * Variable: baseSpacingRight",
          " *",
          " * Specifies the spacing to be added to the right spacing. Default is 0.",
          " */"
        ]
      ],
      "replaceLinefeeds": [
        "replaceLinefeeds: boolean;",
        [
          "/**",
          " * Variable: replaceLinefeeds",
          " *",
          " * Specifies if linefeeds in HTML labels should be replaced with BR tags.",
          " * Default is true.",
          " */"
        ]
      ],
      "verticalTextRotation": [
        "verticalTextRotation: number;",
        [
          "/**",
          " * Variable: verticalTextRotation",
          " *",
          " * Rotation for vertical text. Default is -90 (bottom to top).",
          " */"
        ]
      ],
      "ignoreClippedStringSize": [
        "ignoreClippedStringSize: boolean;",
        [
          "/**",
          " * Variable: ignoreClippedStringSize",
          " *",
          " * Specifies if the string size should be measured in <updateBoundingBox> if",
          " * the label is clipped and the label position is center and middle. If this is",
          " * true, then the bounding box will be set to <bounds>. Default is true.",
          " * <ignoreStringSize> has precedence over this switch.",
          " */"
        ]
      ],
      "ignoreStringSize": [
        "ignoreStringSize: boolean;",
        [
          "/**",
          " * Variable: ignoreStringSize",
          " *",
          " * Specifies if the actual string size should be measured. If disabled the",
          " * boundingBox will not ignore the actual size of the string, otherwise",
          " * <bounds> will be used instead. Default is false.",
          " */"
        ]
      ],
      "textWidthPadding": [
        "textWidthPadding: 4 | 3;",
        [
          "/**",
          " * Variable: textWidthPadding",
          " *",
          " * Specifies the padding to be added to the text width for the bounding box.",
          " * This is needed to make sure no clipping is applied to borders. Default is 4",
          " * for IE 8 standards mode and 3 for all others.",
          " */"
        ]
      ],
      "lastValue": [
        "lastValue: string;",
        [
          "/**",
          " * Variable: lastValue",
          " *",
          " * Contains the last rendered text value. Used for caching.",
          " */"
        ]
      ],
      "cacheEnabled": [
        "cacheEnabled: boolean;",
        [
          "/**",
          " * Variable: cacheEnabled",
          " *",
          " * Specifies if caching for HTML labels should be enabled. Default is true.",
          " */"
        ]
      ],
      "isParseVml": [
        "isParseVml(): boolean;",
        [
          "/**",
          " * Function: isParseVml",
          " *",
          " * Text shapes do not contain VML markup and do not need to be parsed. This",
          " * method returns false to speed up rendering in IE8.",
          " */"
        ]
      ],
      "isHtmlAllowed": [
        "isHtmlAllowed(): boolean;",
        [
          "/**",
          " * Function: isHtmlAllowed",
          " *",
          " * Returns true if HTML is allowed for this shape. This implementation returns",
          " * true if the browser is not in IE8 standards mode.",
          " */"
        ]
      ],
      "getSvgScreenOffset": [
        "getSvgScreenOffset(): 0 | 0.5;",
        [
          "/**",
          " * Function: getSvgScreenOffset",
          " *",
          " * Disables offset in IE9 for crisper image output.",
          " */"
        ]
      ],
      "checkBounds": [
        "checkBounds(): boolean;",
        [
          "/**",
          " * Function: checkBounds",
          " *",
          " * Returns true if the bounds are not null and all of its variables are numeric.",
          " */"
        ]
      ],
      "paint": [
        "paint(c: mxAbstractCanvas2D, update?: boolean): void;",
        [
          "/**",
          " * Function: paint",
          " *",
          " * Generic rendering code.",
          " */"
        ]
      ],
      "redraw": [
        "redraw(): void;",
        [
          "/**",
          " * Function: redraw",
          " *",
          " * Renders the text using the given DOM nodes.",
          " */"
        ]
      ],
      "resetStyles": [
        "resetStyles(): void;",
        [
          "/**",
          " * Function: resetStyles",
          " *",
          " * Resets all styles.",
          " */"
        ]
      ],
      "apply": [
        "apply(state: mxCellState): void;",
        [
          "/**",
          " * Function: apply",
          " *",
          " * Extends mxShape to update the text styles.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> of the corresponding cell.",
          " */"
        ]
      ],
      "getAutoDirection": [
        "getAutoDirection(): string;",
        [
          "/**",
          " * Function: getAutoDirection",
          " *",
          " * Used to determine the automatic text direction. Returns",
          " * <mxConstants.TEXT_DIRECTION_LTR> or <mxConstants.TEXT_DIRECTION_RTL>",
          " * depending on the contents of <value>. This is not invoked for HTML, wrapped",
          " * content or if <value> is a DOM node.",
          " */"
        ]
      ],
      "updateBoundingBox": [
        "updateBoundingBox(): void;",
        [
          "/**",
          " * Function: updateBoundingBox",
          " *",
          " * Updates the <boundingBox> for this shape using the given node and position.",
          " */"
        ]
      ],
      "getShapeRotation": [
        "getShapeRotation(): 0;",
        [
          "/**",
          " * Function: getShapeRotation",
          " *",
          " * Returns 0 to avoid using rotation in the canvas via updateTransform.",
          " */"
        ]
      ],
      "getTextRotation": [
        "getTextRotation(): number;",
        [
          "/**",
          " * Function: getTextRotation",
          " *",
          " * Returns the rotation for the text label of the corresponding shape.",
          " */"
        ]
      ],
      "isPaintBoundsInverted": [
        "isPaintBoundsInverted(): boolean;",
        [
          "/**",
          " * Function: isPaintBoundsInverted",
          " *",
          " * Inverts the bounds if <mxShape.isBoundsInverted> returns true or if the",
          " * horizontal style is false.",
          " */"
        ]
      ],
      "configureCanvas": [
        "configureCanvas(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Function: configureCanvas",
          " *",
          " * Sets the state of the canvas for drawing the shape.",
          " */"
        ]
      ],
      "updateVmlContainer": [
        "updateVmlContainer(): void;",
        [
          "/**",
          " * Function: updateVmlContainer",
          " *",
          " * Sets the width and height of the container to 1px.",
          " */"
        ]
      ],
      "redrawHtmlShape": [
        "redrawHtmlShape(): void;",
        [
          "/**",
          " * Function: redrawHtmlShape",
          " *",
          " * Updates the HTML node(s) to reflect the latest bounds and scale.",
          " */"
        ]
      ],
      "updateHtmlTransform": [
        "updateHtmlTransform(): void;",
        [
          "/**",
          " * Function: updateHtmlTransform",
          " *",
          " * Returns the spacing as an <mxPoint>.",
          " */"
        ]
      ],
      "updateInnerHtml": [
        "updateInnerHtml(elt: HTMLElement): void;",
        [
          "/**",
          " * Function: setInnerHtml",
          " *",
          " * Sets the inner HTML of the given element to the <value>.",
          " */"
        ]
      ],
      "updateHtmlFilter": [
        "updateHtmlFilter(): void;",
        [
          "/**",
          " * Function: updateHtmlFilter",
          " *",
          " * Rotated text rendering quality is bad for IE9 quirks/IE8 standards",
          " */"
        ]
      ],
      "updateValue": [
        "updateValue(): void;",
        [
          "/**",
          " * Function: updateValue",
          " *",
          " * Updates the HTML node(s) to reflect the latest bounds and scale.",
          " */"
        ]
      ],
      "updateFont": [
        "updateFont(node: HTMLElement): void;",
        [
          "/**",
          " * Function: updateFont",
          " *",
          " * Updates the HTML node(s) to reflect the latest bounds and scale.",
          " */"
        ]
      ],
      "updateSize": [
        "updateSize(node: HTMLElement, enableWrap: boolean): void;",
        [
          "/**",
          " * Function: updateSize",
          " *",
          " * Updates the HTML node(s) to reflect the latest bounds and scale.",
          " */"
        ]
      ],
      "updateMargin": [
        "updateMargin(): void;",
        [
          "/**",
          " * Function: getMargin",
          " *",
          " * Returns the spacing as an <mxPoint>.",
          " */"
        ]
      ],
      "getSpacing": [
        "getSpacing(): mxPoint;",
        [
          "/**",
          " * Function: getSpacing",
          " *",
          " * Returns the spacing as an <mxPoint>.",
          " */"
        ]
      ]
    }
  ],
  "mxArrowConnector": [
    [
      "/**",
      " * Extends {@link mxShape} to implement an new rounded arrow shape with support for waypoints and double arrows. The",
      " * shape is used to represent edges, not vertices.",
      " *",
      " * This shape is registered under {@link mxConstants.SHAPE_ARROW_CONNECTOR} in {@link mxCellRenderer}.",
      " */"
    ],
    {
      ");": [
        ");",
        [
          "/**",
          " * Constructs a new arrow shape.",
          " *",
          " * @param points         Array of {@link mxPoint} that define the points. This is stored in {@link mxShape.points}.",
          " * @param fill           String that defines the fill color. This is stored in {@link mxShape.fill}.",
          " * @param stroke         String that defines the stroke color. This is stored in {@link mxShape.stroke}.",
          " * @param strokewidth    Optional integer that defines the stroke width. Default is 1. This is stored in {@link mxShape.strokewidth}.",
          " * @param arrowWidth     Optional integer that defines the arrow width. Default is {@link mxConstants.ARROW_WIDTH}. This is stored in {@link mxShape.arrowWidth}.",
          " * @param spacing        Optional integer that defines the spacing between the arrow shape and its endpoints. Default is {@link mxConstants.ARROW_SPACING}. This is stored in {@link mxShape.spacing}.",
          " * @param endSize        Optional integer that defines the size of the arrowhead. Default is {@link mxConstants.ARROW_SIZE}. This is stored in {@link mxShape.endSize}.",
          " */"
        ]
      ],
      "useSvgBoundingBox": [
        "useSvgBoundingBox: boolean;",
        [
          "/**",
          " * Allows to use the SVG bounding box in SVG.",
          " * @defaultValue `false` for performance reasons.",
          " */"
        ]
      ],
      "resetStyles": [
        "resetStyles(): void;",
        [
          "/**",
          " * Overrides mxShape to reset spacing.",
          " */"
        ]
      ],
      "apply": [
        "apply(state: mxCellState): void;",
        [
          "/**",
          " * Overrides apply to get smooth transition from default start- and endsize.",
          " */"
        ]
      ],
      "augmentBoundingBox": [
        "augmentBoundingBox(bbox: mxRectangle): void;",
        [
          "/**",
          " * Augments the bounding box with the edge width and markers.",
          " */"
        ]
      ],
      "paintEdgeShape": [
        "paintEdgeShape(c: mxAbstractCanvas2D, pts: mxPoint[]): void;",
        [
          "/**",
          " * Paints the line shape.",
          " */"
        ]
      ],
      ")": [
        "): void;",
        [
          "/**",
          " * Paints the line shape.",
          " */"
        ]
      ],
      "isArrowRounded": [
        "isArrowRounded(): boolean;",
        [
          "/**",
          " * @returns whether the arrow is rounded",
          " */"
        ]
      ],
      "getStartArrowWidth": [
        "getStartArrowWidth(): number;",
        [
          "/**",
          " * @returns the width of the start arrow",
          " */"
        ]
      ],
      "getEndArrowWidth": [
        "getEndArrowWidth(): number;",
        [
          "/**",
          " * @returns the width of the end arrow",
          " */"
        ]
      ],
      "getEdgeWidth": [
        "getEdgeWidth(): number;",
        [
          "/**",
          " * @returns the width of the body of the edge",
          " */"
        ]
      ],
      "isOpenEnded": [
        "isOpenEnded(): boolean;",
        [
          "/**",
          " * @returns whether the ends of the shape are drawn",
          " */"
        ]
      ],
      "isMarkerStart": [
        "isMarkerStart(): boolean;",
        [
          "/**",
          " * @returns whether the start marker is drawn",
          " */"
        ]
      ],
      "isMarkerEnd": [
        "isMarkerEnd(): boolean;",
        [
          "/**",
          " * @returns whether the end marker is drawn",
          " */"
        ]
      ]
    }
  ],
  "mxEllipse": [
    [
      "/**",
      " * Extends mxShape to implement an ellipse shape.",
      " * This shape is registered under mxConstants.SHAPE_ELLIPSE in mxCellRenderer.",
      " */"
    ],
    {
      "constructor": [
        "constructor(bounds: mxRectangle, fill: string, stroke: string, strokewidth?: number);",
        [
          "/**",
          " *",
          " * @param bounds         mxRectangle that defines the bounds.  This is stored in mxShape.bounds.",
          " * @param fill           String that defines the fill color.  This is stored in <fill>.",
          " * @param stroke         String that defines the stroke color.  This is stored in <stroke>.",
          " * @param strokewidth    Optional integer that defines the stroke width.  Default is 1.  This is stored in <strokewidth>.",
          " */"
        ]
      ],
      "paintVertexShape": [
        "paintVertexShape(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Paints the ellipse shape.",
          " */"
        ]
      ]
    }
  ],
  "mxLabel": [
    null,
    {
      "constructor": [
        "constructor(bounds: mxRectangle, fill: string, stroke: string, strokewidth?: number);",
        [
          "/**",
          " * Constructs a new label shape.",
          " *",
          " * @param {mxRectangle} bounds    {@link mxRectangle} that defines the bounds. This is stored in {@link mxShape.bounds}.",
          " * @param {string} fill           String that defines the fill color.  This is stored in <fill>.",
          " * @param {string} stroke         String that defines the stroke color.  This is stored in <stroke>.",
          " * @param {number} [strokewidth]  Optional integer that defines the stroke width.  Default is 1.  This is stored in <strokewidth>.",
          " */"
        ]
      ],
      "imageSize": [
        "imageSize: number;",
        [
          "/**",
          " * Default width and height for the image.",
          " * @default mxConstants.DEFAULT_IMAGESIZE",
          " */"
        ]
      ],
      "spacing": [
        "spacing: number;",
        [
          "/**",
          " * Default value for image spacing",
          " * @type {number}",
          " * @default 2",
          " */"
        ]
      ],
      "indicatorSize": [
        "indicatorSize: number;",
        [
          "/**",
          " * Default width and height for the indicicator.",
          " * @type {number}",
          " * @default 10",
          " */"
        ]
      ],
      "indicatorSpacing": [
        "indicatorSpacing: number;",
        [
          "/**",
          " * Default spacing between image and indicator",
          " * @default 2",
          " * @type {number}",
          " */"
        ]
      ],
      "init": [
        "init(container: HTMLElement): void;",
        [
          "/**",
          " * Initializes the shape and the <indicator>.",
          " */"
        ]
      ],
      "redraw": [
        "redraw(): void;",
        [
          "/**",
          " * Reconfigures this shape. This will update the colors of the indicator",
          " * and reconfigure it if required.",
          " */"
        ]
      ],
      "isHtmlAllowed": [
        "isHtmlAllowed(): boolean;",
        [
          "/**",
          " * Returns true for non-rounded, non-rotated shapes with no glass gradient and",
          " * no indicator shape.",
          " */"
        ]
      ],
      "paintForeground": [
        "paintForeground(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Generic background painting implementation.",
          " * @param {mxAbstractCanvas2D} c",
          " * @param {number} x",
          " * @param {number} y",
          " * @param {number} w",
          " * @param {number} h",
          " */"
        ]
      ],
      "paintImage": [
        "paintImage(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Generic background painting implementation.",
          " * @param {mxAbstractCanvas2D} c",
          " * @param {number} x",
          " * @param {number} y",
          " * @param {number} w",
          " * @param {number} h",
          " */"
        ]
      ],
      "getImageBounds": [
        "getImageBounds(x: number, y: number, w: number, h: number): mxRectangle;",
        [
          "/**",
          " * Generic background painting implementation.",
          " * @param {number} x",
          " * @param {number} y",
          " * @param {number} w",
          " * @param {number} h",
          " */"
        ]
      ],
      "paintIndicator": [
        "paintIndicator(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Generic background painting implementation.",
          " * @param {mxAbstractCanvas2D} c",
          " * @param {number} x",
          " * @param {number} y",
          " * @param {number} w",
          " * @param {number} h",
          " */"
        ]
      ],
      "getIndicatorBounds": [
        "getIndicatorBounds(x: number, y: number, w: number, h: number): mxRectangle;",
        [
          "/**",
          " * Generic background painting implementation.",
          " * @param {number} x",
          " * @param {number} y",
          " * @param {number} w",
          " * @param {number} h",
          " * @returns {mxRectangle}",
          " */"
        ]
      ],
      "redrawHtmlShape": [
        "redrawHtmlShape(): void;",
        [
          "/**",
          " * Generic background painting implementation.",
          " */"
        ]
      ]
    }
  ],
  "mxMarker": [
    [
      "/**",
      " * A static class that implements all markers for VML and SVG using a registry.",
      " * NOTE: The signatures in this class will change.",
      " * @class mxMarker",
      " */"
    ],
    {
      "static markers": [
        "static markers: object;",
        [
          "/**",
          " * Maps from markers names to functions to paint the markers.",
          " *",
          " * Mapping: the attribute name on the object is the marker type, the associated value is the function to paint the marker",
          " */"
        ]
      ],
      "static addMarker": [
        "static addMarker(type: string, funct: Function): void;",
        [
          "/**",
          " * Adds a factory method that updates a given endpoint and returns a",
          " * function to paint the marker onto the given canvas.",
          " */"
        ]
      ],
      ")": [
        "): () => void;",
        [
          "/**",
          " * Returns a function to paint the given marker.",
          " * TODO: need check",
          " */"
        ]
      ]
    }
  ],
  "mxImageShape": [
    [
      "/**",
      " * Extends {@link mxShape} to implement an image shape.",
      " * This shape is registered under {@link mxConstants.SHAPE_IMAGE} in {@link mxCellRenderer}.",
      " *",
      " * @class mxImageShape",
      " * @extends {mxRectangleShape}",
      " */"
    ],
    {
      "constructor": [
        "constructor(bounds: mxRectangle, image: string, fill?: string, stroke?: string, strokewidth?: number);",
        [
          "/**",
          " * Constructs a new image shape.",
          " * @param {mxRectangle} bounds     {@link mxRectangle} that defines the bounds.  This is stored in {@link mxShape.bounds}.",
          " * @param {string} image           String that specifies the URL of the image.  This is stored in <image>.",
          " * @param {string} [fill]          String that defines the fill color.  This is stored in <fill>.",
          " * @param {string} [stroke]        String that defines the stroke color.  This is stored in <stroke>.",
          " * @param {number} [strokewidth]   Optional integer that defines the stroke width.  Default is 0.  This is stored in <strokewidth>.",
          " */"
        ]
      ],
      "preserveImageAspect": [
        "preserveImageAspect: boolean;",
        [
          "/**",
          " * Switch to preserve image aspect. Default is true.",
          " * @default true",
          " */"
        ]
      ],
      "getSvgScreenOffset": [
        "getSvgScreenOffset(): number;",
        [
          "/**",
          " * Disables offset in IE9 for crisper image output.",
          " */"
        ]
      ],
      "apply": [
        "apply(state: mxCellState): void;",
        [
          "/**",
          " * Overrides {@link mxShape.apply} to replace the fill and stroke colors with the",
          " * respective values from {@link 'imageBackground'} and",
          " * {@link 'imageBorder'}.",
          " *",
          " * Applies the style of the given {@link mxCellState} to the shape. This",
          " * implementation assigns the following styles to local fields:",
          " *",
          " * - {@link 'imageBackground'} => fill",
          " * - {@link 'imageBorder'} => stroke",
          " *",
          " * @param {mxCellState} state   {@link mxCellState} of the corresponding cell.",
          " */"
        ]
      ],
      "isHtmlAllowed": [
        "isHtmlAllowed(): boolean;",
        [
          "/**",
          " * Returns true if HTML is allowed for this shape. This implementation always",
          " * returns false.",
          " */"
        ]
      ],
      "createHtml": [
        "createHtml(): HTMLElement;",
        [
          "/**",
          " * Creates and returns the HTML DOM node(s) to represent",
          " * this shape. This implementation falls back to <createVml>",
          " * so that the HTML creation is optional.",
          " */"
        ]
      ],
      "isRoundable": [
        "isRoundable(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): boolean;",
        [
          "/**",
          " * Disables inherited roundable support.",
          " */"
        ]
      ],
      "paintVertexShape": [
        "paintVertexShape(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Generic background painting implementation.",
          " */"
        ]
      ],
      "redrawHtmlShape": [
        "redrawHtmlShape(): void;",
        [
          "/**",
          " * Overrides <mxShape.redraw> to preserve the aspect ratio of images.",
          " */"
        ]
      ]
    }
  ],
  "mxRhombus": [
    [
      "/**",
      " * Extends {@link mxShape} to implement a rhombus (aka diamond) shape.",
      " * This shape is registered under {@link mxConstants.SHAPE_RHOMBUS} in {@link mxCellRenderer}.",
      " * @class mxRhombus",
      " * @extends {mxShape}",
      " */"
    ],
    {
      "constructor": [
        "constructor(bounds: mxRectangle, fill: string, stroke: string, strokewidth?: number);",
        [
          "/**",
          " * @param {mxRectangle} bounds",
          " * @param {string} fill",
          " * @param {string} stroke",
          " * @param {number} [strokewidth]",
          " */"
        ]
      ],
      "isRoundable": [
        "isRoundable(): boolean;",
        [
          "/**",
          " * Adds roundable support.",
          " */"
        ]
      ],
      "paintVertexShape": [
        "paintVertexShape(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Generic painting implementation.",
          " * @param {mxAbstractCanvas2D} c",
          " * @param {number} x",
          " * @param {number} y",
          " * @param {number} w",
          " * @param {number} h",
          " */"
        ]
      ]
    }
  ],
  "mxDoubleEllipse": [
    [
      "/**",
      " * Extends {@link mxShape} to implement a double ellipse shape.",
      " *",
      " * This shape is registered under {@link mxConstants.SHAPE_DOUBLE_ELLIPSE} in {@link mxCellRenderer}.",
      " *",
      " * Use the following override to only fill the inner ellipse in this shape:",
      " * @example",
      " * ```javascript",
      " * mxDoubleEllipse.prototype.paintVertexShape = function(c, x, y, w, h)",
      " * {",
      " *   c.ellipse(x, y, w, h);",
      " *   c.stroke();",
      " *",
      " *   var inset = mxUtils.getValue(this.style, 'margin', Math.min(3 + this.strokewidth, Math.min(w / 5, h / 5)));",
      " *   x += inset;",
      " *   y += inset;",
      " *   w -= 2 * inset;",
      " *   h -= 2 * inset;",
      " *",
      " *   if (w > 0 && h > 0)",
      " *   {",
      " *     c.ellipse(x, y, w, h);",
      " *   }",
      " *",
      " *   c.fillAndStroke();",
      " * };",
      " * ```",
      " */"
    ],
    {
      "constructor": [
        "constructor(bounds: mxRectangle, fill: string, stroke: string, strokewidth?: number);",
        [
          "/**",
          " * Constructs a new ellipse shape.",
          " *",
          " * @param bounds         {@link mxRectangle} that defines the bounds. This is stored in {@link mxShape.bounds}.",
          " * @param fill           String that defines the fill color. This is stored in {@link mxShape.fill}.",
          " * @param stroke         String that defines the stroke color. This is stored in {@link mxShape.stroke}.",
          " * @param strokewidth    Optional integer that defines the stroke width. Default is 1. This is stored in {@link mxShape.strokewidth}.",
          " */"
        ]
      ],
      "mxDoubleEllipse": [
        "mxDoubleEllipse: number;",
        [
          "/**",
          " * Scale for improving the precision of VML rendering.",
          " * @default `10`",
          " */"
        ]
      ],
      "paintBackground": [
        "paintBackground(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Paints the background.",
          " */"
        ]
      ],
      "paintForeground": [
        "paintForeground(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Paints the foreground.",
          " */"
        ]
      ],
      "getLabelBounds": [
        "getLabelBounds(rect: mxRectangle): mxRectangle;",
        [
          "/**",
          " * @returns the bounds for the label.",
          " */"
        ]
      ]
    }
  ],
  "mxStencilRegistry": [
    [
      "/**",
      " * A singleton class that provides a registry for stencils and the methods",
      " * for painting those stencils onto a canvas or into a DOM.",
      " *",
      " * @class mxStencilRegistry",
      " */"
    ],
    {
      "static stencils": [
        "static stencils: { [key: string]: mxStencil };",
        null
      ],
      "static addStencil": [
        "static addStencil(name: string, stencil: mxStencil): void;",
        [
          "/**",
          " * Adds the given <mxStencil>.",
          " * @static",
          " * @param {string} name",
          " * @param {mxStencil} stencil",
          " */"
        ]
      ],
      "static getStencil": [
        "static getStencil(name: string): mxStencil;",
        [
          "/**",
          " * Returns the <mxStencil> for the given name.",
          " * @static",
          " * @param {string} name",
          " * @returns {mxStencil}",
          " */"
        ]
      ]
    }
  ],
  "mxStencil": [
    [
      "/**",
      " * Implements a generic shape which is based on a XML node as a description.",
      " *",
      " * @class mxStencil",
      " */"
    ],
    {
      "constructor": [
        "constructor(desc: Element);",
        null
      ],
      "defaultLocalized": [
        "defaultLocalized: boolean;",
        [
          "/**",
          " * Variable: defaultLocalized",
          " *",
          " * Static global variable that specifies the default value for the localized",
          " * attribute of the text element. Default is false.",
          " */"
        ]
      ],
      "allowEval": [
        "allowEval: boolean;",
        [
          "/**",
          " * Function: allowEval",
          " *",
          " * Static global switch that specifies if the use of eval is allowed for",
          " * evaluating text content and images. Default is false. Set this to true",
          " * if stencils can not contain user input.",
          " */"
        ]
      ],
      "desc": [
        "desc: Element;",
        [
          "/**",
          " * Variable: desc",
          " *",
          " * Holds the XML node with the stencil description.",
          " */"
        ]
      ],
      "constraints": [
        "constraints: mxConnectionConstraint[];",
        [
          "/**",
          " * Variable: constraints",
          " *",
          " * Holds an array of <mxConnectionConstraints> as defined in the shape.",
          " */"
        ]
      ],
      "aspect": [
        "aspect: string;",
        [
          "/**",
          " * Variable: aspect",
          " *",
          " * Holds the aspect of the shape. Default is 'auto'.",
          " */"
        ]
      ],
      "w0": [
        "w0: number;",
        [
          "/**",
          " * Variable: w0",
          " *",
          " * Holds the width of the shape. Default is 100.",
          " */"
        ]
      ],
      "h0": [
        "h0: number;",
        [
          "/**",
          " * Variable: h0",
          " *",
          " * Holds the height of the shape. Default is 100.",
          " */"
        ]
      ],
      "bgNode": [
        "bgNode: Element;",
        [
          "/**",
          " * Variable: bgNodes",
          " *",
          " * Holds the XML node with the stencil description.",
          " */"
        ]
      ],
      "fgNode": [
        "fgNode: Element;",
        [
          "/**",
          " * Variable: fgNodes",
          " *",
          " * Holds the XML node with the stencil description.",
          " */"
        ]
      ],
      "strokewidth": [
        "strokewidth: number;",
        [
          "/**",
          " * Variable: strokewidth",
          " *",
          " * Holds the strokewidth direction from the description.",
          " */"
        ]
      ],
      "parseDescription": [
        "parseDescription(): void;",
        [
          "/**",
          " * Function: parseDescription",
          " *",
          " * Reads <w0>, <h0>, <aspect>, <bgNodes> and <fgNodes> from <desc>.",
          " */"
        ]
      ],
      "parseConstraints": [
        "parseConstraints(): void;",
        [
          "/**",
          " * Function: parseConstraints",
          " *",
          " * Reads the constraints from <desc> into <constraints> using",
          " * <parseConstraint>.",
          " */"
        ]
      ],
      "parseConstraint": [
        "parseConstraint(node: Element): void;",
        [
          "/**",
          " * Function: parseConstraint",
          " *",
          " * Parses the given XML node and returns its <mxConnectionConstraint>.",
          " */"
        ]
      ],
      "evaluateTextAttribute": [
        "evaluateTextAttribute(node: string, attribute: string, shape: string): string;",
        [
          "/**",
          " * Function: evaluateTextAttribute",
          " *",
          " * Gets the given attribute as a text. The return value from <evaluateAttribute>",
          " * is used as a key to <mxResources.get> if the localized attribute in the text",
          " * node is 1 or if <defaultLocalized> is true.",
          " */"
        ]
      ],
      "evaluateAttribute": [
        "evaluateAttribute(node: string, attribute: string, shape: string): string;",
        [
          "/**",
          " * Function: evaluateAttribute",
          " *",
          " * Gets the attribute for the given name from the given node. If the attribute",
          " * does not exist then the text content of the node is evaluated and if it is",
          " * a function it is invoked with <shape> as the only argument and the return",
          " * value is used as the attribute value to be returned.",
          " */"
        ]
      ],
      "drawShape": [
        "drawShape(canvas: mxAbstractCanvas2D, shape: string, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Function: drawShape",
          " *",
          " * Draws this stencil inside the given bounds.",
          " */"
        ]
      ],
      ")": [
        "): void;",
        [
          "/**",
          " * Function: drawNode",
          " *",
          " * Draws this stencil inside the given bounds.",
          " */"
        ]
      ],
      "computeAspect": [
        "computeAspect(shape: string, x: number, y: number, w: number, h: number, direction?: string): mxRectangle;",
        [
          "/**",
          " * Function: computeAspect",
          " *",
          " * Returns a rectangle that contains the offset in x and y and the horizontal",
          " * and vertical scale in width and height used to draw this shape inside the",
          " * given <mxRectangle>.",
          " *",
          " * Parameters:",
          " *",
          " * shape - <mxShape> to be drawn.",
          " * bounds - <mxRectangle> that should contain the stencil.",
          " * direction - Optional direction of the shape to be darwn.",
          " */"
        ]
      ]
    }
  ],
  "mxLine": [
    [
      "/**",
      " * Extends {@link mxShape} to implement a horizontal line shape.",
      " * This shape is registered under {@link mxConstants.SHAPE_LINE} in {@link mxCellRenderer}.",
      " * @class mxLine",
      " * @extends {mxShape}",
      " */"
    ],
    {
      "constructor": [
        "constructor(bounds: mxRectangle, stroke: string, strokewidth: number);",
        [
          "/**",
          " * Constructs a new line shape.",
          " * @param {mxRectangle} bounds    {@link mxRectangle} that defines the bounds.  This is stored in {@link mxShape.bounds}.",
          " * @param {string} stroke         String that defines the stroke color.  Default is black.  This is stored in <stroke>.",
          " * @param {number} strokewidth    Optional integer that defines the stroke width.  Default is 1.  This is stored in <strokewidth>.",
          " */"
        ]
      ],
      "paintVertexShape": [
        "paintVertexShape(c: mxAbstractCanvas2D, x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Redirects to redrawPath for subclasses to work.",
          " * @param {mxAbstractCanvas2D} c",
          " * @param {number} x",
          " * @param {number} y",
          " * @param {number} w",
          " * @param {number} h",
          " */"
        ]
      ]
    }
  ],
  "mxDragSource": [
    [
      "/**",
      " * @class mxDragSource",
      " *",
      " * Wrapper to create a drag source from a DOM element so that the element can",
      " * be dragged over a graph and dropped into the graph as a new cell.",
      " *",
      " * Problem is that in the dropHandler the current preview location is not",
      " * available, so the preview and the dropHandler must match.",
      " *",
      " */"
    ],
    {
      "constructor": [
        "constructor(element: HTMLElement, dropHandler?: Function);",
        [
          "/**",
          " * Constructs a new drag source for the given element.",
          " *",
          " * @param {HTMLElement} element",
          " * @param {Function} dropHandler",
          " */"
        ]
      ],
      "element": [
        "element: HTMLElement;",
        [
          "/**",
          " * Reference to the DOM node which was made draggable.",
          " */"
        ]
      ],
      "dropHandler": [
        "dropHandler: Function;",
        [
          "/**",
          " * Holds the DOM node that is used to represent the drag preview. If this is",
          " * null then the source element will be cloned and used for the drag preview.",
          " */"
        ]
      ],
      "dragOffset": [
        "dragOffset: mxPoint;",
        [
          "/**",
          " * {@link mxPoint} that specifies the offset of the {@link dragElement}. Default is null.",
          " */"
        ]
      ],
      "dragElement": [
        "dragElement: HTMLElement;",
        [
          "/**",
          " * Holds the DOM node that is used to represent the drag preview. If this is",
          " * null then the source element will be cloned and used for the drag preview.",
          " */"
        ]
      ],
      "previewElement": [
        "previewElement: mxRectangle;",
        [
          "/**",
          " * Optional {@link mxRectangle} that specifies the unscaled size of the preview.",
          " */"
        ]
      ],
      "enabled": [
        "enabled: boolean;",
        [
          "/**",
          " * Specifies if this drag source is enabled. Default is true.",
          " */"
        ]
      ],
      "currentGraph": [
        "currentGraph: mxGraph;",
        [
          "/**",
          " * Reference to the {@link mxGraph} that is the current drop target.",
          " */"
        ]
      ],
      "currentDropTarget": [
        "currentDropTarget: mxCell;",
        [
          "/**",
          " * Holds the current drop target under the mouse.",
          " */"
        ]
      ],
      "currentPoint": [
        "currentPoint: mxPoint;",
        [
          "/**",
          " * Holds the current drop location.",
          " */"
        ]
      ],
      "currentGuide": [
        "currentGuide: mxGuide;",
        [
          "/**",
          " * Holds an {@link mxGuide} for the {@link currentGraph} if {@link dragPreview} is not null.",
          " */"
        ]
      ],
      "currentHighlight": [
        "currentHighlight: mxCellHighlight;",
        [
          "/**",
          " * Holds an {@link mxGuide} for the {@link currentGraph} if {@link dragPreview} is not null.",
          " * @note wrong doc",
          " */"
        ]
      ],
      "autoscroll": [
        "autoscroll: boolean;",
        [
          "/**",
          " * Specifies if the graph should scroll automatically. Default is true.",
          " */"
        ]
      ],
      "guidesEnabled": [
        "guidesEnabled: boolean;",
        [
          "/**",
          " * Specifies if {@link mxGuide} should be enabled. Default is true.",
          " */"
        ]
      ],
      "gridEnabled": [
        "gridEnabled: boolean;",
        [
          "/**",
          " * Specifies if the grid should be allowed. Default is true.",
          " */"
        ]
      ],
      "highlightDropTargets": [
        "highlightDropTargets: boolean;",
        [
          "/**",
          " * Specifies if drop targets should be highlighted. Default is true.",
          " */"
        ]
      ],
      "dragElementZIndex": [
        "dragElementZIndex: number;",
        [
          "/**",
          " * ZIndex for the drag element. Default is 100.",
          " */"
        ]
      ],
      "dragElementOpacity": [
        "dragElementOpacity: number;",
        [
          "/**",
          " * Opacity of the drag element in %. Default is 70.",
          " */"
        ]
      ],
      "checkEventSource": [
        "checkEventSource: boolean;",
        [
          "/**",
          " * Whether the event source should be checked in {@link graphContainerEvent}. Default",
          " * is true.",
          " */"
        ]
      ],
      "isEnabled": [
        "isEnabled(): boolean;",
        [
          "/**",
          " * Returns {@link enabled}.",
          " */"
        ]
      ],
      "setEnabled": [
        "setEnabled(value: boolean): void;",
        [
          "/**",
          " * Sets {@link enabled}.",
          " */"
        ]
      ],
      "isGuidesEnabled": [
        "isGuidesEnabled(): boolean;",
        [
          "/**",
          " * Returns {@link guidesEnabled}.",
          " */"
        ]
      ],
      "setGuidesEnabled": [
        "setGuidesEnabled(value: boolean): void;",
        [
          "/**",
          " * Sets {@link guidesEnabled}.",
          " */"
        ]
      ],
      "isGridEnabled": [
        "isGridEnabled(): boolean;",
        [
          "/**",
          " * Returns {@link gridEnabled}.",
          " */"
        ]
      ],
      "setGridEnabled": [
        "setGridEnabled(value: boolean): void;",
        [
          "/**",
          " * Sets {@link gridEnabled}.",
          " */"
        ]
      ],
      "getGraphForEvent": [
        "getGraphForEvent(evt: MouseEvent): mxGraph;",
        [
          "/**",
          " * Returns the graph for the given mouse event. This implementation returns",
          " * null.",
          " */"
        ]
      ],
      "getDropTarget": [
        "getDropTarget(graph: mxGraph, x: number, y: number, evt: PointerEvent): mxCell;",
        [
          "/**",
          " * Returns the drop target for the given graph and coordinates. This",
          " * implementation uses {@link mxGraph.getCellAt}.",
          " */"
        ]
      ],
      "createDragElement": [
        "createDragElement(evt: Event): Node;",
        [
          "/**",
          " * Creates and returns a clone of the {@link dragElementPrototype} or the {@link element}",
          " * if the former is not defined.",
          " */"
        ]
      ],
      "createPreviewElement": [
        "createPreviewElement(graph: mxGraph): HTMLElement;",
        [
          "/**",
          " * Creates and returns an element which can be used as a preview in the given",
          " * graph.",
          " */"
        ]
      ],
      "isActive": [
        "isActive(): boolean;",
        [
          "/**",
          " * Returns true if this drag source is active.",
          " */"
        ]
      ],
      "reset": [
        "reset(): void;",
        [
          "/**",
          " * Stops and removes everything and restores the state of the object.",
          " */"
        ]
      ],
      "mouseDown": [
        "mouseDown(evt: mxMouseEvent): void;",
        [
          "/**",
          " * Returns the drop target for the given graph and coordinates. This",
          " * implementation uses {@link mxGraph.getCellAt}.",
          " *",
          " * To ignore popup menu events for a drag source, this function can be",
          " * overridden as follows.",
          " *",
          " * @example",
          " * ```javascript",
          " * var mouseDown = dragSource.mouseDown;",
          " *",
          " * dragSource.mouseDown(evt)",
          " * {",
          " *   if (!mxEvent.isPopupTrigger(evt))",
          " *   {",
          " *     mouseDown.apply(this, arguments);",
          " *   }",
          " * };",
          " * ```",
          " */"
        ]
      ],
      "startDrag": [
        "startDrag(evt: mxMouseEvent): void;",
        [
          "/**",
          " * Creates the {@link dragElement} using {@link createDragElement}.",
          " */"
        ]
      ],
      "stopDrag": [
        "stopDrag(): void;",
        [
          "/**",
          " * Invokes {@link removeDragElement}.",
          " */"
        ]
      ],
      "removeDragElement": [
        "removeDragElement(): void;",
        [
          "/**",
          " * Removes and destroys the {@link dragElement}.",
          " */"
        ]
      ],
      "getElementForEvent": [
        "getElementForEvent(evt: Event): Element;",
        [
          "/**",
          " * Returns the topmost element under the given event.",
          " */"
        ]
      ],
      "graphContainsEvent": [
        "graphContainsEvent(graph: mxGraph, evt: Event): boolean;",
        [
          "/**",
          " * Returns true if the given graph contains the given event.",
          " */"
        ]
      ],
      "mouseMove": [
        "mouseMove(evt: MouseEvent): void;",
        [
          "/**",
          " * Gets the graph for the given event using {@link getGraphForEvent}, updates the",
          " * {@link currentGraph}, calling {@link dragEnter} and {@link dragExit} on the new and old graph,",
          " * respectively, and invokes {@link dragOver} if {@link currentGraph} is not null.",
          " */"
        ]
      ],
      "mouseUp": [
        "mouseUp(evt: MouseEvent): void;",
        [
          "/**",
          " * Processes the mouse up event and invokes {@link drop}, {@link dragExit} and {@link stopDrag}",
          " * as required.",
          " */"
        ]
      ],
      "removeListeners": [
        "removeListeners(): void;",
        [
          "/**",
          " * Actives the given graph as a drop target.",
          " */"
        ]
      ],
      "dragEnter": [
        "dragEnter(graph: mxGraph, evt: Event): void;",
        [
          "/**",
          " * Actives the given graph as a drop target.",
          " */"
        ]
      ],
      "dragExit": [
        "dragExit(graph: mxGraph, evt: Event): void;",
        [
          "/**",
          " * Deactivates the given graph as a drop target.",
          " */"
        ]
      ],
      "dragOver": [
        "dragOver(graph: mxGraph, evt: Event): void;",
        [
          "/**",
          " * Implements autoscroll, updates the {@link currentPoint}, highlights any drop",
          " * targets and updates the preview.",
          " */"
        ]
      ],
      "drop": [
        "drop(graph: mxGraph, evt: Event, dropTarget: mxCell, x: number, y: number): void;",
        [
          "/**",
          " * Returns the drop target for the given graph and coordinates. This",
          " * implementation uses {@link mxGraph.getCellAt}.",
          " */"
        ]
      ]
    }
  ],
  "mxPanningManager": [
    null,
    {
      "constructor": [
        "constructor(graph: mxGraph);",
        null
      ],
      "private thread": [
        "private thread: (handler: TimerHandler, timeout?: number, ...arguments: any[]) => number;",
        null
      ],
      "private active": [
        "private active: boolean;",
        null
      ],
      "private tdx": [
        "private tdx: number;",
        null
      ],
      "private tdy": [
        "private tdy: number;",
        null
      ],
      "private t0x": [
        "private t0x: number;",
        null
      ],
      "private t0y": [
        "private t0y: number;",
        null
      ],
      "private dx": [
        "private dx: number;",
        null
      ],
      "private dy": [
        "private dy: number;",
        null
      ],
      "private scrollbars": [
        "private scrollbars: boolean;",
        null
      ],
      "private scrollLeft": [
        "private scrollLeft: number;",
        null
      ],
      "private scrollTop": [
        "private scrollTop: number;",
        null
      ],
      "mouseDown": [
        "mouseDown: (sender: any, me: mxMouseEvent) => void;",
        null
      ],
      "mouseMove": [
        "mouseMove: (sender: any, me: mxMouseEvent) => void;",
        null
      ],
      "mouseUp": [
        "mouseUp: (sender: any, me: mxMouseEvent) => void;",
        null
      ],
      "};": [
        "};",
        null
      ],
      "private mouseUpListener": [
        "private mouseUpListener: () => void;",
        null
      ],
      "private isActive": [
        "private isActive(): boolean;",
        null
      ],
      "private getDx": [
        "private getDx(): number;",
        null
      ],
      "private getDy": [
        "private getDy(): number;",
        null
      ],
      "private start": [
        "private start(): void;",
        null
      ],
      "private panTo": [
        "private panTo(x: number, y: number, w: number, h: number): void;",
        null
      ],
      "private stop": [
        "private stop(): void;",
        null
      ],
      "damper": [
        "damper: number;",
        [
          "/**",
          " * Variable: damper",
          " *",
          " * Damper value for the panning. Default is 1/6.",
          " */"
        ]
      ],
      "delay": [
        "delay: number;",
        [
          "/**",
          " * Variable: delay",
          " *",
          " * Delay in milliseconds for the panning. Default is 10.",
          " */"
        ]
      ],
      "handleMouseOut": [
        "handleMouseOut: boolean;",
        [
          "/**",
          " * Variable: handleMouseOut",
          " *",
          " * Specifies if mouse events outside of the component should be handled. Default is true.",
          " */"
        ]
      ],
      "border": [
        "border: number;",
        [
          "/**",
          " * Variable: border",
          " *",
          " * Border to handle automatic panning inside the component. Default is 0 (disabled).",
          " */"
        ]
      ]
    }
  ],
  "mxUtils": [
    null,
    {
      "static mod": [
        "static mod(n: number, m: number): number;",
        [
          "/**",
          " * Returns the remainder of division of n by m. You should use this instead",
          " * of the built-in operation as the built-in operation does not properly",
          " * handle negative numbers.",
          " *",
          " * @param {number} n",
          " * @param {number} m",
          " */"
        ]
      ],
      ")": [
        "): mxRectangle;",
        [
          "/**",
          " * Returns an {@link mxRectangle} with the size (width and height in pixels) of",
          " * the given string. The string may contain HTML markup. Newlines should be",
          " * converted to <br> before calling this method. The caller is responsible",
          " * for sanitizing the HTML markup.",
          " *",
          " * @example",
          " * ```javascript",
          " * var label = graph.getLabel(cell).replace(/\\n/g, \"<br>\");",
          " * var size = graph.getSizeForString(label);",
          " * ```",
          " *",
          " * @param {string} text String whose size should be returned.",
          " * @param {number} fontSize Integer that specifies the font size in pixels. Default is <mxConstants.DEFAULT_FONTSIZE>.",
          " * @param {string} fontFamily String that specifies the name of the font family. Default is <mxConstants.DEFAULT_FONTFAMILY>.",
          " * @param {number} [textWidth] Optional width for text wrapping.",
          " * @param {string} [fontStyle] Optional font style.",
          " */"
        ]
      ],
      "static contains": [
        "static contains(bounds: mxRectangle, x: number, y: number): boolean;",
        [
          "/**",
          " * Returns true if the specified point (x, y) is contained in the given rectangle.",
          " * @param bounds  mxRectangle that represents the area",
          " * @param x       X-coordinate of the point.",
          " * @param y       Y-coordinate of the point.",
          " */"
        ]
      ],
      "static bind<T extends Function>": [
        "static bind<T extends Function>(scope: any, func: T): T;",
        [
          "/**",
          " * Returns a wrapper function that locks the execution scope of the given function to the specified scope.  Inside funct, the this keyword becomes a reference to that scope.",
          " * @param scope",
          " * @param func",
          " */"
        ]
      ],
      "static convertPoint": [
        "static convertPoint(container: HTMLElement, x: number, y: number): mxPoint;",
        [
          "/**",
          " * Converts the specified point (x, y) using the offset of the specified container and returns a new mxPoint with the result.",
          " * @param container DOM node to use for the offset.",
          " * @param x         X-coordinate of the point to be converted.",
          " * @param y         Y-coordinate of the point to be converted.",
          " */"
        ]
      ],
      "static setOpacity": [
        "static setOpacity(node: HTMLElement, value: number): void;",
        [
          "/**",
          " * Sets the opacity of the specified DOM node to the given value in %.",
          " * @param node    DOM node to set the opacity for.",
          " * @param value   Opacity in %.  Possible values are between 0 and 100.",
          " */"
        ]
      ],
      "public static createImage": [
        "public static createImage(src: string): HTMLImageElement;",
        [
          "/**",
          " * Creates and returns an image (IMG node) or VML image (v:image) in IE6 in",
          " * quirks mode.",
          " *",
          " * @static",
          " * @param {string} src          URL that points to the image to be displayed.",
          " * @returns {HTMLImageElement}",
          " */"
        ]
      ],
      "public static sortCells": [
        "public static sortCells(cells: Array<mxCell>, ascending?: boolean): Array<mxCell>;",
        [
          "/**",
          " * Sorts the given cells according to the order in the cell hierarchy.",
          " * Ascending is optional and defaults to true.",
          " *",
          " * @static",
          " * @param {Array<mxCell>} cells",
          " * @param {boolean} [ascending]",
          " * @returns {Array<mxCell>}",
          " */"
        ]
      ],
      "public static getStylename": [
        "public static getStylename(style: string): string;",
        [
          "/**",
          " * Returns the stylename in a style of the form [(stylename|key=value);] or",
          " * an empty string if the given style does not contain a stylename.",
          " *",
          " * @author  <hungtcs@163.com>",
          " * @date 2020-07-17",
          " * @static",
          " * @param {string} style    String of the form [(stylename|key=value);]",
          " * @returns {string}",
          " */"
        ]
      ],
      "public static getStylenames": [
        "public static getStylenames(style: string): Array<string>;",
        [
          "/**",
          " * Returns the stylenames in a style of the form [(stylename|key=value);]",
          " * or an empty array if the given style does not contain any stylenames.",
          " *",
          " * @author  <hungtcs@163.com>",
          " * @date 2020-07-17",
          " * @static",
          " * @param {string} style        String of the form [(stylename|key=value);]",
          " * @returns {Array<string>}",
          " */"
        ]
      ],
      "public static indexOfStylename": [
        "public static indexOfStylename(style: string, stylename: string): number;",
        [
          "/**",
          " * Returns the index of the given stylename in the given style. This",
          " * returns -1 if the given stylename does not occur (as a stylename) in the",
          " * given style, otherwise it returns the index of the first character.",
          " *",
          " * @author  <hungtcs@163.com>",
          " * @date 2020-07-17",
          " * @static",
          " * @param {string} style",
          " * @param {string} stylename",
          " * @returns {number}",
          " */"
        ]
      ],
      "public static addStylename": [
        "public static addStylename(style: string, stylename: string): string;",
        [
          "/**",
          " * Adds the specified stylename to the given style if it does not already",
          " * contain the stylename.",
          " *",
          " * @author  <hungtcs@163.com>",
          " * @date 2020-07-17",
          " * @static",
          " * @param {string} style",
          " * @param {string} stylename",
          " * @returns {string}",
          " */"
        ]
      ],
      "public static removeStylename": [
        "public static removeStylename(style: string, stylename: string): string;",
        [
          "/**",
          " * Removes all occurrences of the specified stylename in the given style",
          " * and returns the updated style. Trailing semicolons are not preserved.",
          " *",
          " * @author  <hungtcs@163.com>",
          " * @date 2020-07-17",
          " * @static",
          " * @param {string} style",
          " * @param {string} stylename",
          " * @returns {string}",
          " */"
        ]
      ],
      "public static removeAllStylenames": [
        "public static removeAllStylenames(style: string): string;",
        [
          "/**",
          " * Removes all stylenames from the given style and returns the updated style.",
          " *",
          " * @author  <hungtcs@163.com>",
          " * @date 2020-07-17",
          " * @static",
          " * @param {string} style",
          " * @returns {string}",
          " */"
        ]
      ],
      "public static setStyle": [
        "public static setStyle(style: string, key: string, value: string | number | null): string;",
        [
          "/**",
          " * Adds or removes the given key, value pair to the style and returns the",
          " * new style. If value is null or zero length then the key is removed from",
          " * the style. This is for cell styles, not for CSS styles.",
          " *",
          " * @author  <hungtcs@163.com>",
          " * @date 2020-07-17",
          " * @static",
          " * @param {string} style                  String of the form [(stylename|key=value);].",
          " * @param {string} key                    Key of the style to be changed.",
          " * @param {(string|number|null)} value    New value for the given key.",
          " * @returns {string}",
          " */"
        ]
      ],
      "static load": [
        "static load(url: string): mxXmlRequest;",
        [
          "/**",
          " * Loads the specified URL synchronously and returns the mxXmlRequest.",
          " * Throws an exception if the file cannot be loaded.",
          " * See mxUtils.get for an asynchronous implementation.",
          " * @param url URL to get the data from.",
          " */"
        ]
      ],
      "static getAll": [
        "static getAll(urls: Array<string>, onload: (req: mxXmlRequest) => void, onerror: (err: mxXmlRequest) => void): void;",
        [
          "/**",
          " * Loads the URLs in the given array asynchronously and invokes the given function if all requests returned with a valid 2xx status.",
          " * The error handler is invoked once on the first error or invalid response.",
          " */"
        ]
      ],
      "static getXml": [
        "static getXml(node: XMLDocument, linefeed?: string): string;",
        [
          "/**",
          " * Returns the XML content of the specified node.",
          " * For Internet Explorer, all \\r\\n\\t[\\t]* are removed from the XML string and the remaining \\r\\n are replaced by \\n.",
          " * All \\n are then replaced with linefeed, or &#xa; if no linefeed is defined.",
          " *",
          " * @author  <hungtcs@163.com>",
          " * @date 2019-12-27",
          " * @static",
          " * @param {XMLDocument} node      DOM node to return the XML for.",
          " * @param {*} [linefeed]            Optional string that linefeeds are converted into.  Default is &#xa;",
          " */"
        ]
      ],
      "static parseXml": [
        "static parseXml(xml: string): XMLDocument;",
        [
          "/**",
          " * Parses the specified XML string into a new XML document and returns the new document.",
          " *",
          " * @author  <hungtcs@163.com>",
          " * @date 2019-12-27",
          " * @static",
          " * @param {string} xml",
          " * @returns {XMLDocument}",
          " */"
        ]
      ],
      "static isAncestorNode": [
        "static isAncestorNode(ancestor: Node, child: Node): boolean;",
        [
          "/**",
          " * Returns true if the given ancestor is an ancestor of the given DOM node in the DOM.",
          " * This also returns true if the child is the ancestor.",
          " *",
          " * @author  <hungtcs@163.com>",
          " * @date 2020-01-07",
          " * @static",
          " * @param {Node} ancestor DOM node that represents the ancestor.",
          " * @param {Node} child    DOM node that represents the child.",
          " * @returns {boolean}",
          " */"
        ]
      ],
      "static createXmlDocument": [
        "static createXmlDocument(): XMLDocument;",
        [
          "/**",
          " * Returns a new, empty XML document.",
          " */"
        ]
      ],
      "static getOffset": [
        "static getOffset(container: HTMLElement, scrollOffset?: boolean): mxPoint;",
        [
          "/**",
          " * Returns the offset for the specified container as an mxPoint.",
          " * The offset is the distance from the top left corner of the container to the top left corner of the document.",
          " *",
          " * @author  <hungtcs@163.com>",
          " * @date 2020-01-09",
          " * @static",
          " * @param {HTMLElement} container",
          " * @param {boolean} scrollOffset",
          " * @returns {mxPoint}",
          " */"
        ]
      ],
      "static getScrollOrigin": [
        "static getScrollOrigin(node: HTMLElement, includeAncestors?: boolean, includeDocument?: boolean): mxPoint;",
        [
          "/**",
          " * Returns the top, left corner of the viewrect as an mxPoint.",
          " *",
          " * @author  <hungtcs@163.com>",
          " * @date 2020-01-09",
          " * @static",
          " * @param {HTMLElement} node",
          " * @param {boolean} [includeAncestors]",
          " * @param {boolean} [includeDocument]",
          " * @returns {mxPoint}",
          " */"
        ]
      ],
      "static importNode": [
        "static importNode(doc: any, node: any, allChildren: any): any;",
        [
          "/**",
          " * Cross browser implementation for document.importNode. Uses document.importNode",
          " * in all browsers but IE, where the node is cloned by creating a new node and",
          " * copying all attributes and children into it using importNode, recursively.",
          " *",
          " * @param {*} doc Document to import the node into.",
          " * @param {*} node Node to be imported.",
          " * @param {*} allChildren If all children should be imported.",
          " */"
        ]
      ],
      "static removeWhitespace": [
        "static removeWhitespace(node: Node, before: boolean): void;",
        [
          "/**",
          " * Removes the sibling text nodes for the given node that only consists",
          " * of tabs, newlines and spaces.",
          " * @param {Node} node DOM node whose siblings should be removed.",
          " * @param {boolean} [before] Optional boolean that specifies the direction of the traversal.",
          " */"
        ]
      ],
      "static hasScrollbars": [
        "static hasScrollbars(node: Node): boolean;",
        [
          "/**",
          " * Returns true if the overflow CSS property of the given node is either",
          " * scroll or auto.",
          " *",
          " * @param {Node} node DOM node whose style should be checked for scrollbars.",
          " */"
        ]
      ],
      "static clone": [
        "static clone(obj: any, transients?: Array<string>, shallow?: boolean): any;",
        [
          "/**",
          " * Recursively clones the specified object ignoring all field names in the given array of transient fields.",
          " * {@link mxObjectIdentity.FIELD_NAME} is always ignored by this function.",
          " *",
          " *",
          " * @param {Object} obj Object to be cloned.",
          " * @param {Array<string>} [transients] Optional array of strings representing the field name to be ignored.",
          " * @param {boolean} [shallow=false] Optional boolean argument to specify if a shallow clone should be created, that is, one where all",
          " *                object references are not cloned or, in other words, one where only atomic (strings, numbers) values",
          " *                are cloned. Default is false.",
          " */"
        ]
      ],
      "static alert": [
        "static alert(message: string): void;",
        [
          "/**",
          " * Displays the given alert in a new dialog. This implementation uses the",
          " * built-in alert function. This is used to display validation errors when",
          " * connections cannot be changed or created.",
          " *",
          " * @param message The message to be displayed.",
          " */"
        ]
      ],
      "static error": [
        "static error(message: string, width: number, close?: boolean, icon?: string): void;",
        [
          "/**",
          " * Displays the given error message in a new <mxWindow> of the given width.",
          " * If close is true then an additional close button is added to the window.",
          " * The optional icon specifies the icon to be used for the window. Default",
          " * is {@link mxUtils.errorImage}.",
          " *",
          " * @param {string} message The message to be displayed.",
          " * @param {number} width   The width of the window.",
          " * @param {boolean} [close]   Optional boolean indicating whether to add a close button.",
          " * @param {string} [icon]    Optional icon for the window decoration (path to the icon).",
          " */"
        ]
      ],
      "static errorResource": [
        "static errorResource: 'error' | '';",
        [
          "/**",
          " * Specifies the resource key for the title of the error window. If the",
          " * resource for this key does not exist then the value is used as",
          " * the title. Default is 'error'.",
          " *",
          " * @default 'error'",
          " */"
        ]
      ],
      "static closeResource": [
        "static closeResource: 'close' | '';",
        [
          "/**",
          " * Specifies the resource key for the label of the close button. If the",
          " * resource for this key does not exist then the value is used as",
          " * the label. Default is 'close'.",
          " *",
          " * @default 'close'",
          " */"
        ]
      ],
      "static errorImage": [
        "static errorImage: string;",
        [
          "/**",
          " * Defines the image used for error dialogs.",
          " */"
        ]
      ],
      "static removeCursors": [
        "static removeCursors(element: Node): void;",
        [
          "/**",
          " * Removes the cursors from the style of the given DOM node and its",
          " * descendants.",
          " *",
          " * @param {Node} element DOM node to remove the cursor style from.",
          " */"
        ]
      ],
      "static getCurrentStyle": [
        "static getCurrentStyle(): any;",
        [
          "/**",
          " * Returns the current style of the specified element.",
          " */"
        ]
      ],
      "static parseCssNumber": [
        "static parseCssNumber(value: string): number;",
        [
          "/**",
          " * Parses the given CSS numeric value adding handling for the values thin,",
          " * medium and thick (2, 4 and 6).",
          " *",
          " * @param {string} value",
          " */"
        ]
      ],
      "static setPrefixedStyle": [
        "static setPrefixedStyle(): void;",
        [
          "/**",
          " * Adds the given style with the standard name and an optional vendor prefix for the current",
          " * browser.",
          " *",
          " * @example",
          " * ```javascript",
          " * mxUtils.setPrefixedStyle(node.style, 'transformOrigin', '0% 0%');",
          " * ```",
          " */"
        ]
      ],
      "static eval": [
        "static eval(expr: string): any;",
        [
          "/**",
          " * Evaluates the given expression using eval and returns the JavaScript",
          " * object that represents the expression result. Supports evaluation of",
          " * expressions that define functions and returns the function object for",
          " * these expressions.",
          " *",
          " * @param {string} expr A string that represents a JavaScript expression.",
          " */"
        ]
      ],
      "static findNode": [
        "static findNode(node: any, attr: any, value: any): null;",
        [
          "/**",
          " * Returns the first node where attr equals value.",
          " * This implementation does not use XPath.",
          " *",
          " * @param {*} node",
          " * @param {*} attr",
          " * @param {*} value",
          " */"
        ]
      ],
      "static getFunctionName": [
        "static getFunctionName(f: {}): string;",
        [
          "/**",
          " * Returns the name for the given function.",
          " *",
          " * @param {Object} f JavaScript object that represents a function.",
          " */"
        ]
      ],
      "static indexOf": [
        "static indexOf(array: Array<any>, obj: {}): number;",
        [
          "/**",
          " * Returns the index of obj in array or -1 if the array does not contain",
          " * the given object.",
          " *",
          " * @param {Array<any>} array Array to check for the given obj.",
          " * @param {Object} obj Object to find in the given array.",
          " */"
        ]
      ],
      "static forEach": [
        "static forEach(array: Array<any>, fn: Function): Array<any>;",
        [
          "/**",
          " * Calls the given function for each element of the given array and returns",
          " * the array.",
          " *",
          " * @param {Array<any>} array Array that contains the elements.",
          " * @param {Function} fn Function to be called for each object.",
          " */"
        ]
      ],
      "static remove": [
        "static remove(obj: {}, array: Array<any>): {};",
        [
          "/**",
          " * Removes all occurrences of the given object in the given array or",
          " * object. If there are multiple occurrences of the object, be they",
          " * associative or as an array entry, all occurrences are removed from",
          " * the array or deleted from the object. By removing the object from",
          " * the array, all elements following the removed element are shifted",
          " * by one step towards the beginning of the array.",
          " *",
          " * The length of arrays is not modified inside this function.",
          " *",
          " * @param {Object} obj Object to find in the given array.",
          " * @param {Array<any>} array Array to check for the given obj.",
          " */"
        ]
      ],
      "static isNode": [
        "static isNode(value: {}, nodeName: string, attributeName?: string, attributeValue?: any): boolean;",
        [
          "/**",
          " * Returns true if the given value is an XML node with the node name",
          " * and if the optional attribute has the specified value.",
          " *",
          " * This implementation assumes that the given value is a DOM node if the",
          " * nodeType property is numeric, that is, if isNaN returns false for",
          " * value.nodeType.",
          " *",
          " * @param {Object} value Object that should be examined as a node.",
          " * @param {string} nodeName String that specifies the node name.",
          " * @param {string} [attributeName] Optional attribute name to check.",
          " * @param {*} [attributeValue] Optional attribute value to check.",
          " */"
        ]
      ],
      "static getChildNodes": [
        "static getChildNodes(node: Node, nodeType?: any): Array<Node>;",
        [
          "/**",
          " * Returns an array of child nodes that are of the given node type.",
          " *",
          " * @param {Node} node Parent DOM node to return the children from.",
          " * @param {*} [nodeType] Optional node type to return. Default is {@link mxConstants.NODETYPE_ELEMENT}.",
          " */"
        ]
      ],
      "static importNodeImplementation": [
        "static importNodeImplementation(doc: any, node: Node, allChildren: boolean): any;",
        [
          "/**",
          " * Full DOM API implementation for importNode without using importNode API call.",
          " *",
          " * @param {*} doc Document to import the node into.",
          " * @param {Node} node Node to be imported.",
          " * @param {boolean} allChildren If all children should be imported.",
          " */"
        ]
      ],
      "static createMsXmlDocument": [
        "static createMsXmlDocument(): any;",
        [
          "/**",
          " * Returns a new, empty Microsoft.XMLDOM document using ActiveXObject.",
          " */"
        ]
      ],
      "static clearSelection": [
        "static clearSelection(): void;",
        [
          "/**",
          " * Clears the current selection in the page.",
          " */"
        ]
      ],
      "htmlEntities": [
        "htmlEntities(s: string, newline: boolean): string;",
        [
          "/**",
          " * Replaces characters (less than, greater than, newlines and quotes) with",
          " * their HTML entities in the given string and returns the result.",
          " *",
          " * @param {string} s String that contains the characters to be converted.",
          " * @param {boolean} newline If newlines should be replaced. Default is true.",
          " */"
        ]
      ],
      "static isVml": [
        "static isVml(node: any): boolean;",
        [
          "/**",
          " * Returns true if the given node is in the VML namespace.",
          " *",
          " * @param {*} node DOM node whose tag urn should be checked.",
          " */"
        ]
      ],
      "static getPrettyXml": [
        "static getPrettyXml(node: XMLDocument, tab?: string, indent?: string, newline?: string, ns?: any): string;",
        [
          "/**",
          " * Returns a pretty printed string that represents the XML tree for the",
          " * given node. This method should only be used to print XML for reading,",
          " * use {@link getXml} instead to obtain a string for processing.",
          " *",
          " * @param {XMLDocument} node DOM node to return the XML for.",
          " * @param {string} [tab='  '] Optional string that specifies the indentation for one level. Default is two spaces.",
          " * @param {string} [indent=''] Optional string that represents the current indentation. Default is an empty string.",
          " * @param {string} [newline='\\n'] Option string that represents a linefeed. Default is '\\n'.",
          " * @param ns",
          " */"
        ]
      ],
      "static extractTextWithWhitespace": [
        "static extractTextWithWhitespace(elems: any): string;",
        [
          "/**",
          " * Returns the text content of the specified node.",
          " *",
          " * @param {*} elems DOM nodes to return the text for.",
          " */"
        ]
      ],
      "static replaceTrailingNewlines": [
        "static replaceTrailingNewlines(str: string, pattern: string): string;",
        [
          "/**",
          " * Replaces each trailing newline with the given pattern.",
          " *",
          " * @param {string} str",
          " * @param {string} pattern",
          " */"
        ]
      ],
      "static getTextContent": [
        "static getTextContent(node: Node): string;",
        [
          "/**",
          " * Returns the text content of the specified node.",
          " *",
          " * @param {Node} node DOM node to return the text content for.",
          " */"
        ]
      ],
      "static setTextContent": [
        "static setTextContent(node: Node, text: string): void;",
        [
          "/**",
          " * Sets the text content of the specified node.",
          " *",
          " * @param {Node} node DOM node to set the text content for.",
          " * @param {string} text String that represents the text content.",
          " */"
        ]
      ],
      "static getInnerHtml": [
        "static getInnerHtml(): string;",
        [
          "/**",
          " * Returns the inner HTML for the given node as a string or an empty string",
          " * if no node was specified. The inner HTML is the text representing all",
          " * children of the node, but not the node itself.",
          " */"
        ]
      ],
      "static getOuterHtml": [
        "static getOuterHtml(): string;",
        [
          "/**",
          " * Returns the outer HTML for the given node as a string or an empty",
          " * string if no node was specified. The outer HTML is the text representing",
          " * all children of the node including the node itself.",
          " */"
        ]
      ],
      "static write": [
        "static write(parent: Node, text: string): Node;",
        [
          "/**",
          " * Creates a text node for the given string and appends it to the given",
          " * parent. Returns the text node.",
          " *",
          " * @param {Node} parent DOM node to append the text node to.",
          " * @param {string} text String representing the text to be added.",
          " */"
        ]
      ],
      "static writeln": [
        "static writeln(parent: Node, text: string): Node;",
        [
          "/**",
          " * Creates a text node for the given string and appends it to the given",
          " * parent with an additional linefeed. Returns the text node.",
          " *",
          " * @param {Node} parent DOM node to append the text node to.",
          " * @param {string} text String representing the text to be added.",
          " */"
        ]
      ],
      "static br": [
        "static br(parent: Node, count: number): Node;",
        [
          "/**",
          " * Appends a linebreak to the given parent and returns the linebreak.",
          " *",
          " * @param {Node} parent DOM node to append the linebreak to.",
          " * @param {number} count",
          " */"
        ]
      ],
      "static button": [
        "static button(label: string, funct: Function, doc?: Document): Element;",
        [
          "/**",
          " * Returns a new button with the given level and function as an onclick",
          " * event handler.",
          " *",
          " * @example",
          " * ```javascript",
          " * document.body.appendChild(mxUtils.button('Test', function(evt)",
          " * {",
          " *   alert('Hello, World!');",
          " * }));",
          " * ```",
          " *",
          " * @param {string} label String that represents the label of the button.",
          " * @param {Function} funct Function to be called if the button is pressed.",
          " * @param {Document} [doc] Optional document to be used for creating the button. Default is the current document.",
          " */"
        ]
      ],
      "static para": [
        "static para(parent: Node, text: string): Element;",
        [
          "/**",
          " * Appends a new paragraph with the given text to the specified parent and",
          " * returns the paragraph.",
          " *",
          " * @param {Node} parent DOM node to append the text node to.",
          " * @param {string} text String representing the text for the new paragraph.",
          " */"
        ]
      ],
      "static addTransparentBackgroundFilter": [
        "static addTransparentBackgroundFilter(node: any): void;",
        [
          "/**",
          " * Adds a transparent background to the filter of the given node. This",
          " * background can be used in IE8 standards mode (native IE8 only) to pass",
          " * events through the node.",
          " *",
          " * @param {*} node",
          " */"
        ]
      ],
      "static linkAction": [
        "static linkAction(parent: Node, text: string, editor: mxEditor, action: string, pad?: number): HTMLElement;",
        [
          "/**",
          " * Adds a hyperlink to the specified parent that invokes action on the specified editor.",
          " *",
          " * @param {Node} parent DOM node to contain the new link.",
          " * @param {string} text String that is used as the link label.",
          " * @param {mxEditor} editor {@link mxEditor} that will execute the action.",
          " * @param {string} action String that defines the name of the action to be executed.",
          " * @param {number} [pad=0] Optional left-padding for the link. Default is 0.",
          " */"
        ]
      ],
      "static link": [
        "static link(parent: Node, text: string, funct: Function, pad?: number): HTMLElement;",
        [
          "/**",
          " *",
          " * @param {Node} parent DOM node to contain the new link.",
          " * @param {string} text String that is used as the link label.",
          " * @param {Function} funct Function to execute when the link is clicked.",
          " * @param {number} [pad=0] Optional left-padding for the link. Default is 0.",
          " */"
        ]
      ],
      "static getDocumentSize": [
        "static getDocumentSize(): mxRectangle;",
        [
          "/**",
          " * Returns the client size for the current document as an {@link mxRectangle}.",
          " */"
        ]
      ],
      "static fit": [
        "static fit(node: Node): void;",
        [
          "/**",
          " * Makes sure the given node is inside the visible area of the window. This",
          " * is done by setting the left and top in the style.",
          " *",
          " * @param {Node} node",
          " */"
        ]
      ],
      "static submit": [
        "static submit(url: string, params: any, doc: Document, target: any): mxXmlRequest;",
        [
          "/**",
          " * Submits the given parameters to the specified URL using",
          " * {@link mxXmlRequest.simulate} and returns the {@link mxXmlRequest}.",
          " * Make sure to use encodeURIComponent for the parameter values.",
          " *",
          " * @param {string} url URL to get the data from.",
          " * @param {*} params Parameters for the form.",
          " * @param {Document} doc Document to create the form in.",
          " * @param {*} target Target to send the form result to.",
          " */"
        ]
      ],
      "static loadInto": [
        "static loadInto(url: string, doc: Document, onload: (req: mxXmlRequest) => void): void;",
        [
          "/**",
          " * Loads the specified URL *asynchronously* into the specified document,",
          " * invoking onload after the document has been loaded. This implementation",
          " * does not use {@link mxXmlRequest}, but the document.load method.",
          " *",
          " * @param {string} url URL to get the data from.",
          " * @param {Document} doc The document to load the URL into.",
          " * @param {Function} onload Function to execute when the URL has been loaded.",
          " */"
        ]
      ],
      "static getNumber": [
        "static getNumber(array: Array<any>, key: string, defaultValue: number): number;",
        [
          "/**",
          " * Returns the numeric value for the given key in the given associative",
          " * array or the given default value (or 0) if the value is null. The value",
          " * is converted to a numeric value using the Number function.",
          " *",
          " * @param {Array<any>} array Associative array that contains the value for the key.",
          " * @param {string} key Key whose value should be returned.",
          " * @param {number} [defaultValue=0] Value to be returned if the value for the given key is null. Default is 0.",
          " */"
        ]
      ],
      "static getColor": [
        "static getColor(array: Array<any>, key: any, defaultValue: any): any | null;",
        [
          "/**",
          " * Returns the color value for the given key in the given associative",
          " * array or the given default value if the value is null. If the value",
          " * is {@link mxConstants.NONE} then null is returned.",
          " *",
          " * @param {Array<any>} array Associative array that contains the value for the key whose value should be returned.",
          " * @param {*} key Key whose value should be returned.",
          " * @param {*} defaultValue Value to be returned if the value for the given key is null. Default is null.",
          " */"
        ]
      ],
      "static equalPoints": [
        "static equalPoints(a: Array<mxPoint>, b: Array<mxPoint>): boolean;",
        [
          "/**",
          " * Compares all mxPoints in the given lists.",
          " *",
          " * @param {Array<mxPoint>} a Array of {@link mxPoints} to be compared.",
          " * @param {Array<mxPoint>} b Array of {@link mxPoints} to be compared.",
          " */"
        ]
      ],
      "static equalEntries": [
        "static equalEntries(a: {}, b: {}): boolean;",
        [
          "/**",
          " * Returns true if all properties of the given objects are equal. Values with NaN are equal to NaN and unequal to any other value.",
          " *",
          " * @param {Object} a First object to be compared.",
          " * @param {Object} b Second object to be compared.",
          " */"
        ]
      ],
      "static removeDuplicates<T>": [
        "static removeDuplicates<T>(arr: Array<T>): Array<T>;",
        [
          "/**",
          " * Removes all duplicates from the given array.",
          " *",
          " * @param {Array<any>} arr",
          " */"
        ]
      ],
      "static isNaN": [
        "static isNaN(value: any): boolean;",
        [
          "/**",
          " * Returns true if the given value is of type number and isNaN returns true.",
          " *",
          " * @param {*} value",
          " */"
        ]
      ],
      "static extend": [
        "static extend(ctor: Function, superCtor: Function): void;",
        [
          "/**",
          " * Assigns a copy of the superclass prototype to the subclass prototype.",
          " * Note that this does not call the constructor of the superclass at this",
          " * point, the superclass constructor should be called explicitely in the",
          " * subclass constructor.",
          " *",
          " * @example",
          " * ```javascript",
          " * MyGraph = function(container, model, renderHint, stylesheet)",
          " * {",
          " *   mxGraph.call(this, container, model, renderHint, stylesheet);",
          " * }",
          " *",
          " * mxUtils.extend(MyGraph, mxGraph);",
          " * ```",
          " *",
          " * @param {Function} ctor Constructor of the subclass.",
          " * @param {Function} superCtor Constructor of the superclass.",
          " */"
        ]
      ],
      "static toString": [
        "static toString(obj: {}): string;",
        [
          "/**",
          " * Returns a textual representation of the specified object.",
          " *",
          " * @param {Object} obj Object to return the string representation for.",
          " */"
        ]
      ],
      "static toRadians": [
        "static toRadians(deg: number): number;",
        [
          "/**",
          " * Converts the given degree to radians.",
          " *",
          " * @param {number} deg",
          " */"
        ]
      ],
      "static toDegree": [
        "static toDegree(rad: number): number;",
        [
          "/**",
          " * Converts the given radians to degree.",
          " *",
          " * @param {number} rad",
          " */"
        ]
      ],
      "static getBoundingBox": [
        "static getBoundingBox(rect: mxRectangle, rotation: number, cx?: mxPoint): mxRectangle;",
        [
          "/**",
          " * Returns the bounding box for the rotated rectangle.",
          " *",
          " * @param {mxRectangle} rect {@link mxRectangle} to be rotated.",
          " * @param {number} rotation",
          " * @param {mxPoint} [cx] Optional {@link mxPoint} that represents the rotation center.",
          " * If no rotation center is given then the center of rect is used.",
          " */"
        ]
      ],
      "static getRotatedPoint": [
        "static getRotatedPoint(pt: any, cos: number, sin: number, c: any): mxPoint;",
        [
          "/**",
          " * Rotates the given point by the given cos and sin.",
          " *",
          " * @param {*} pt",
          " * @param {number} cos",
          " * @param {number} sin",
          " * @param {*} c",
          " */"
        ]
      ],
      "static getPortConstraints": [
        "static getPortConstraints(terminal: mxCellState, edge: mxCellState, source: boolean, defaultValue: any): any;",
        [
          "/**",
          " * Returns an integer mask of the port constraints of the given map",
          " *",
          " * @param {mxCellState} terminal {@link mxCellState} that represents the terminal.",
          " * @param {mxCellState} edge {@link mxCellState} that represents the edge.",
          " * @param {boolean} source Boolean that specifies if the terminal is the source terminal.",
          " * @param {*} defaultValue Default value to be returned.",
          " */"
        ]
      ],
      "static reversePortConstraints": [
        "static reversePortConstraints(constraint: any): any;",
        [
          "/**",
          " * Reverse the port constraint bitmask. For example, north | east becomes south | west",
          " *",
          " * @param {*} constraint",
          " */"
        ]
      ],
      "static findNearestSegment": [
        "static findNearestSegment(state: any, x: number, y: number): number;",
        [
          "/**",
          " * Finds the index of the nearest segment on the given cell state for the specified coordinate pair.",
          " *",
          " * @param {*} state",
          " * @param {number} x",
          " * @param {number} y",
          " */"
        ]
      ],
      "static getDirectedBounds": [
        "static getDirectedBounds(rect: any, m: any, style: any, flipH: any, flipV: any): mxRectangle;",
        [
          "/**",
          " * Adds the given margins to the given rectangle and rotates and flips the rectangle according to the respective styles in style.",
          " *",
          " * @param {*} rect",
          " * @param {*} m",
          " * @param {*} style",
          " * @param {*} flipH",
          " * @param {*} flipV",
          " */"
        ]
      ],
      "static getPerimeterPoint": [
        "static getPerimeterPoint(pts: any, center: any, point: any): any | null;",
        [
          "/**",
          " * Returns the intersection between the polygon defined by the array of points and the line between center and point.",
          " *",
          " * @param {*} pts",
          " * @param {*} center",
          " * @param {*} point",
          " */"
        ]
      ],
      "static rectangleIntersectsSegment": [
        "static rectangleIntersectsSegment(bounds: mxRectangle, p1: mxPoint, p2: mxPoint): boolean;",
        [
          "/**",
          " * Returns true if the given rectangle intersects the given segment.",
          " *",
          " * @param {mxRectangle} bounds {@link mxRectangle} that represents the rectangle.",
          " * @param {mxPoint} p1 {@link mxPoint} that represents the first point of the segment.",
          " * @param {mxPoint} p2 {@link mxPoint} that represents the second point of the segment.",
          " */"
        ]
      ],
      "static intersects": [
        "static intersects(a: mxRectangle, b: mxRectangle): boolean;",
        [
          "/**",
          " * Returns true if the two rectangles intersect.",
          " *",
          " * @param {mxRectangle} a {@link mxRectangle} to be checked for intersection.",
          " * @param {mxRectangle} b {@link mxRectangle} to be checked for intersection.",
          " */"
        ]
      ],
      "static getDocumentScrollOrigin": [
        "static getDocumentScrollOrigin(doc: Document): mxPoint;",
        [
          "/**",
          " * Returns the scroll origin of the given document or the current document if no document is given.",
          " *",
          " * @param {Document} doc",
          " */"
        ]
      ],
      "static ltrim": [
        "static ltrim(str: string, chars: string): string | null;",
        [
          "/**",
          " * Strips all whitespaces from the beginning of the string. Without the",
          " * second parameter, this will trim these characters:",
          " * - \" \" (ASCII 32 (0x20)), an ordinary space",
          " * - \"\\t\" (ASCII 9 (0x09)), a tab",
          " * - \"\\n\" (ASCII 10 (0x0A)), a new line (line feed)",
          " * - \"\\r\" (ASCII 13 (0x0D)), a carriage return",
          " * - \"\\0\" (ASCII 0 (0x00)), the NUL-byte",
          " * - \"\\x0B\" (ASCII 11 (0x0B)), a vertical tab",
          " *",
          " * @param {string} str",
          " * @param {string} chars",
          " */"
        ]
      ],
      "static rtrim": [
        "static rtrim(str: string, chars: string): string | null;",
        [
          "/**",
          " * Strips all whitespaces from the end of the string. Without the second",
          " * parameter, this will trim these characters:",
          " *",
          " * - \" \" (ASCII 32 (0x20)), an ordinary space",
          " * - \"\\t\" (ASCII 9 (0x09)), a tab",
          " * - \"\\n\" (ASCII 10 (0x0A)), a new line (line feed)",
          " * - \"\\r\" (ASCII 13 (0x0D)), a carriage return",
          " * - \"\\0\" (ASCII 0 (0x00)), the NUL-byte",
          " * - \"\\x0B\" (ASCII 11 (0x0B)), a vertical tab",
          " *",
          " * @param {string} str",
          " * @param {string} chars",
          " */"
        ]
      ],
      "static trim": [
        "static trim(str: string, chars: string): string | null;",
        [
          "/**",
          " * Strips all whitespaces from both end of the string.",
          " * Without the second parameter, Javascript function will trim these",
          " * characters:",
          " *",
          " * - \" \" (ASCII 32 (0x20)), an ordinary space",
          " * - \"\\t\" (ASCII 9 (0x09)), a tab",
          " * - \"\\n\" (ASCII 10 (0x0A)), a new line (line feed)",
          " * - \"\\r\" (ASCII 13 (0x0D)), a carriage return",
          " * - \"\\0\" (ASCII 0 (0x00)), the NUL-byte",
          " * - \"\\x0B\" (ASCII 11 (0x0B)), a vertical tab",
          " *",
          " * @param {string} str",
          " * @param {string} chars",
          " */"
        ]
      ],
      "static isNumeric": [
        "static isNumeric(n: string): boolean;",
        [
          "/**",
          " * Returns true if the specified value is numeric, that is, if it is not",
          " * null, not an empty string, not a HEX number and isNaN returns false.",
          " *",
          " * @param {string} n String representing the possibly numeric value.",
          " */"
        ]
      ],
      "static isInteger": [
        "static isInteger(n: string): boolean;",
        [
          "/**",
          " * Returns true if the given value is an valid integer number.",
          " *",
          " * @param n String representing the possibly numeric value.",
          " */"
        ]
      ],
      "static ptSegDistSq": [
        "static ptSegDistSq(x1: number, y1: number, x2: number, y2: number, px: number, py: number): number;",
        [
          "/**",
          " * Returns the square distance between a segment and a point. To get the",
          " * distance between a point and a line (with infinite length) use",
          " * {@link mxUtils.ptLineDist}.",
          " *",
          " * @param {number} x1 X-coordinate of the startpoint of the segment.",
          " * @param {number} y1 Y-coordinate of the startpoint of the segment.",
          " * @param {number} x2 X-coordinate of the endpoint of the segment.",
          " * @param {number} y2 Y-coordinate of the endpoint of the segment.",
          " * @param {number} px X-coordinate of the point.",
          " * @param {number} py Y-coordinate of the point.",
          " */"
        ]
      ],
      "static ptLineDist": [
        "static ptLineDist(x1: number, y1: number, x2: number, y2: number, px: number, py: number): number;",
        [
          "/**",
          " * Returns the distance between a line defined by two points and a point.",
          " * To get the distance between a point and a segment (with a specific",
          " * length) use {@link mxUtils.ptSeqDistSq}.",
          " *",
          " * @param {number} x1 X-coordinate of point 1 of the line.",
          " * @param {number} y1 Y-coordinate of point 1 of the line.",
          " * @param {number} x2 X-coordinate of point 1 of the line.",
          " * @param {number} y2 Y-coordinate of point 1 of the line.",
          " * @param {number} px X-coordinate of the point.",
          " * @param {number} py Y-coordinate of the point.",
          " */"
        ]
      ],
      "static relativeCcw": [
        "static relativeCcw(x1: number, y1: number, x2: number, y2: number, px: number, py: number): number;",
        [
          "/**",
          " * Returns 1 if the given point on the right side of the segment, 0 if its",
          " * on the segment, and -1 if the point is on the left side of the segment.",
          " *",
          " * @param {number} x1 X-coordinate of the startpoint of the segment.",
          " * @param {number} y1 Y-coordinate of the startpoint of the segment.",
          " * @param {number} x2 X-coordinate of the endpoint of the segment.",
          " * @param {number} y2 Y-coordinate of the endpoint of the segment.",
          " * @param {number} px X-coordinate of the point.",
          " * @param {number} py Y-coordinate of the point.",
          " */"
        ]
      ],
      "static animateChanges": [
        "static animateChanges(graph: any, changes: any): void;",
        [
          "/**",
          " * See {@link mxEffects.animateChanges}. This is for backwards compatibility and will be removed later.",
          " *",
          " * @param {*} graph",
          " * @param {*} changes",
          " */"
        ]
      ],
      "static cascadeOpacity": [
        "static cascadeOpacity(graph: any, cell: any, opacity: any): void;",
        [
          "/**",
          " * See {@link mxEffects.cascadeOpacity}. This is for backwards compatibility and will be removed later.",
          " *",
          " * @param {*} graph",
          " * @param {*} cell",
          " * @param {*} opacity",
          " */"
        ]
      ],
      "static fadeOut": [
        "static fadeOut(node: Node, from: any, remove: any, step: any, delay: any, isEnabled: boolean): void;",
        [
          "/**",
          " * See {@link mxEffects.fadeOut}. This is for backwards compatibility and will be removed later.",
          " *",
          " * @param {Node} node",
          " * @param {*} from",
          " * @param {*} remove",
          " * @param {*} step",
          " * @param {*} delay",
          " * @param {*} isEnabled",
          " */"
        ]
      ],
      "static setStyleFlag": [
        "static setStyleFlag(style: string, key: string, flag: number, value?: boolean): string;",
        [
          "/**",
          " * Sets or removes the given key from the specified style and returns the",
          " * new style. If value is null then the flag is toggled.",
          " *",
          " * @param {string} style String of the form [(stylename|key=value);].",
          " * @param {string} key Key of the style to be changed.",
          " * @param {number} flag Integer for the bit to be changed.",
          " * @param {boolean} [value] Optional boolean value for the given flag.",
          " */"
        ]
      ],
      "static getAlignmentAsPoint": [
        "static getAlignmentAsPoint(align: any, valign: any): mxPoint;",
        [
          "/**",
          " * Returns an {@link mxPoint} that represents the horizontal and vertical alignment",
          " * for numeric computations. X is -0.5 for center, -1 for right and 0 for",
          " * left alignment. Y is -0.5 for middle, -1 for bottom and 0 for top",
          " * alignment. Default values for missing arguments is top, left.",
          " *",
          " * @param {*} align",
          " * @param {*} valign",
          " */"
        ]
      ],
      "static getViewXml": [
        "static getViewXml(graph: any, scale: any, cells: any, x0: number, y0: number): any;",
        [
          "/**",
          " *",
          " * @param {*} graph",
          " * @param {*} scale",
          " * @param {*} cells",
          " * @param {number} x0",
          " * @param {number} y0",
          " */"
        ]
      ],
      "static getScaleForPageCount": [
        "static getScaleForPageCount(pageCount: number, graph: mxGraph, pageFormat: mxRectangle, border: number): number;",
        [
          "/**",
          " * Returns the scale to be used for printing the graph with the given",
          " * bounds across the specifies number of pages with the given format. The",
          " * scale is always computed such that it given the given amount or fewer",
          " * pages in the print output. See {@link mxPrintPreview} for an example.",
          " *",
          " * @param {number} pageCount Specifies the number of pages in the print output.",
          " * @param {mxGraph} graph {@link mxGraph} that should be printed.",
          " * @param {mxRectangle} pageFormat Optional {@link mxRectangle} that specifies the page format. Default is {@link mxConstants.PAGE_FORMAT_A4_PORTRAIT}.",
          " * @param {number} border The border along each side of every page.",
          " */"
        ]
      ],
      "static show": [
        "static show(graph: mxGraph, doc: Document, x0: number, y0: number, w: number, h: number): Document;",
        [
          "/**",
          " * Copies the styles and the markup from the graph's container into the",
          " * given document and removes all cursor styles. The document is returned.",
          " *",
          " * This function should be called from within the document with the graph.",
          " * If you experience problems with missing stylesheets in IE then try adding",
          " * the domain to the trusted sites.",
          " *",
          " * @param {mxGraph} graph {@link mxGraph} to be copied.",
          " * @param {Document} doc Document where the new graph is created.",
          " * @param {number} x0=0 X-coordinate of the graph view origin. Default is 0.",
          " * @param {number} y0=0 Y-coordinate of the graph view origin. Default is 0.",
          " * @param {number} [w] Optional width of the graph view.",
          " * @param {number} [h] Optional height of the graph view.",
          " */"
        ]
      ],
      "static printScreen": [
        "static printScreen(graph: mxGraph): void;",
        [
          "/**",
          " * Prints the specified graph using a new window and the built-in print",
          " * dialog. This function should be called from within the document with the graph.",
          " *",
          " * @param {mxGraph} graph {@link mxGraph} to be printed.",
          " */"
        ]
      ],
      "static popup": [
        "static popup(content: string, isInternalWindow: boolean): void;",
        [
          "/**",
          " * Shows the specified text content in a new {@link mxWindow} or a new browser",
          " * window if isInternalWindow is false.",
          " *",
          " * @param {string} content String that specifies the text to be displayed.",
          " * @param {boolean} [isInternalWindow=false] Optional boolean indicating if an mxWindow should be",
          " * used instead of a new browser window. Default is false.",
          " */"
        ]
      ],
      "static prompt": [
        "static prompt(message: string, defaultValue: string): string;",
        [
          "/**",
          " * Displays the given message in a prompt dialog. This implementation uses",
          " * the built-in prompt function.",
          " *",
          " * @param {string} message String specifying the message to be displayed.",
          " * @param {string} [defaultValue] Optional string specifying the default value.",
          " */"
        ]
      ],
      "static confirm": [
        "static confirm(message: string): boolean;",
        [
          "/**",
          " * Displays the given message in a confirm dialog. This implementation uses the built-in confirm function.",
          " *",
          " * @param {string} message String specifying the message to be displayed.",
          " */"
        ]
      ]
    }
  ],
  "mxImageExport": [
    [
      "/**",
      " * Creates a new image export instance to be used with an export canvas. Here",
      " * is an example that uses this class to create an image via a backend using",
      " * <mxXmlExportCanvas>.",
      " *",
      " * (code)",
      " * var xmlDoc = mxUtils.createXmlDocument();",
      " * var root = xmlDoc.createElement('output');",
      " * xmlDoc.appendChild(root);",
      " *",
      " * var xmlCanvas = new mxXmlCanvas2D(root);",
      " * var imgExport = new mxImageExport();",
      " * imgExport.drawState(graph.getView().getState(graph.model.root), xmlCanvas);",
      " *",
      " * var bounds = graph.getGraphBounds();",
      " * var w = Math.ceil(bounds.x + bounds.width);",
      " * var h = Math.ceil(bounds.y + bounds.height);",
      " *",
      " * var xml = mxUtils.getXml(root);",
      " * new mxXmlRequest('export', 'format=png&w=' + w +",
      " * \t\t'&h=' + h + '&bg=#F9F7ED&xml=' + encodeURIComponent(xml))",
      " * \t\t.simulate(document, '_blank');",
      " * (end)",
      " *",
      " * @class mxImageExport",
      " */"
    ],
    {
      "constructor": [
        "constructor();",
        [
          "/**",
          " * Creates an instance of mxImageExport.",
          " * @memberof mxImageExport",
          " */"
        ]
      ],
      "includeOverlays": [
        "includeOverlays: boolean;",
        [
          "/**",
          " * Specifies if overlays should be included in the export. Default is false.",
          " */"
        ]
      ],
      "drawState": [
        "drawState(state: mxCellState, canvas: mxAbstractCanvas2D): void;",
        [
          "/**",
          " * Draws the given state and all its descendants to the given canvas.",
          " */"
        ]
      ],
      ")": [
        "): void;",
        [
          "/**",
          " * Function: drawState",
          " *",
          " * Draws the given state and all its descendants to the given canvas.",
          " */"
        ]
      ],
      "getLinkForCellState": [
        "getLinkForCellState(state: mxCellState, canvas: mxAbstractCanvas2D): any;",
        [
          "/**",
          " * Returns the link for the given cell state and canvas. This returns null.",
          " */"
        ]
      ],
      "drawCellState": [
        "drawCellState(state: mxCellState, canvas: mxAbstractCanvas2D): void;",
        [
          "/**",
          " * Draws the given state to the given canvas.",
          " */"
        ]
      ],
      "drawShape": [
        "drawShape(state: mxCellState, canvas: mxAbstractCanvas2D): void;",
        [
          "/**",
          " * Function: drawShape",
          " *",
          " * Draws the shape of the given state.",
          " */"
        ]
      ],
      "drawText": [
        "drawText(state: mxCellState, canvas: mxAbstractCanvas2D): void;",
        [
          "/**",
          " * Draws the text of the given state.",
          " */"
        ]
      ],
      "drawOverlays": [
        "drawOverlays(state: mxCellState, canvas: mxAbstractCanvas2D): void;",
        [
          "/**",
          " * Function: drawOverlays",
          " *",
          " * Draws the overlays for the given state. This is called if <includeOverlays>",
          " * is true.",
          " */"
        ]
      ]
    }
  ],
  "mxWindow": [
    [
      "/**",
      " * Basic window inside a document.",
      " *",
      " * Creating a simple window.",
      " * @example",
      " *",
      " * ```javascript",
      " * var tb = document.createElement('div');",
      " * var wnd = new mxWindow('Title', tb, 100, 100, 200, 200, true, true);",
      " * wnd.setVisible(true);",
      " * ```",
      " *",
      " * Creating a window that contains an iframe.",
      " * @example",
      " *",
      " * ```javascript",
      " * var frame = document.createElement('iframe');",
      " * frame.setAttribute('width', '192px');",
      " * frame.setAttribute('height', '172px');",
      " * frame.setAttribute('src', 'http://www.example.com/');",
      " * frame.style.backgroundColor = 'white';",
      " *",
      " * var w = document.body.clientWidth;",
      " * var h = (document.body.clientHeight || document.documentElement.clientHeight);",
      " * var wnd = new mxWindow('Title', frame, (w-200)/2, (h-200)/3, 200, 200);",
      " * wnd.setVisible(true);",
      " * ```",
      " *",
      " * To limit the movement of a window, eg. to keep it from being moved beyond",
      " * the top, left corner the following method can be overridden (recommended):",
      " *",
      " * ```javascript",
      " * wnd.setLocation(x, y)",
      " * {",
      " *   x = Math.max(0, x);",
      " *   y = Math.max(0, y);",
      " *   setLocation.apply(this, arguments);",
      " * };",
      " * ```",
      " *",
      " * Or the following event handler can be used:",
      " *",
      " * @example",
      " * ```javascript",
      " * wnd.addListener(mxEvent.MOVE, function(e)",
      " * {",
      " *   wnd.setLocation(Math.max(0, wnd.getX()), Math.max(0, wnd.getY()));",
      " * });",
      " * ```",
      " *",
      " * To keep a window inside the current window:",
      " *",
      " * @example",
      " * ```javascript",
      " * mxEvent.addListener(window, 'resize', mxUtils.bind(this, function()",
      " * {",
      " *   var iw = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;",
      " *   var ih = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;",
      " *",
      " *   var x = this.window.getX();",
      " *   var y = this.window.getY();",
      " *",
      " *   if (x + this.window.table.clientWidth > iw)",
      " *   {",
      " *     x = Math.max(0, iw - this.window.table.clientWidth);",
      " *   }",
      " *",
      " *   if (y + this.window.table.clientHeight > ih)",
      " *   {",
      " *     y = Math.max(0, ih - this.window.table.clientHeight);",
      " *   }",
      " *",
      " *   if (this.window.getX() != x || this.window.getY() != y)",
      " *   {",
      " *     this.window.setLocation(x, y);",
      " *   }",
      " * }));",
      " * ```",
      " *",
      " * ### Event: mxEvent.MOVE_START",
      " *",
      " * Fires before the window is moved. The <code>event</code> property contains",
      " * the corresponding mouse event.",
      " *",
      " * ### Event: mxEvent.MOVE",
      " *",
      " * Fires while the window is being moved. The <code>event</code> property",
      " * contains the corresponding mouse event.",
      " *",
      " * ### Event: mxEvent.MOVE_END",
      " *",
      " * Fires after the window is moved. The <code>event</code> property contains",
      " * the corresponding mouse event.",
      " *",
      " * ### Event: mxEvent.RESIZE_START",
      " *",
      " * Fires before the window is resized. The <code>event</code> property contains",
      " * the corresponding mouse event.",
      " *",
      " * ### Event: mxEvent.RESIZE",
      " *",
      " * Fires while the window is being resized. The <code>event</code> property",
      " * contains the corresponding mouse event.",
      " *",
      " * ### Event: mxEvent.RESIZE_END",
      " *",
      " * Fires after the window is resized. The <code>event</code> property contains",
      " * the corresponding mouse event.",
      " *",
      " * ### Event: mxEvent.MAXIMIZE",
      " *",
      " * Fires after the window is maximized. The <code>event</code> property",
      " * contains the corresponding mouse event.",
      " *",
      " * ### Event: mxEvent.MINIMIZE",
      " *",
      " * Fires after the window is minimized. The <code>event</code> property",
      " * contains the corresponding mouse event.",
      " *",
      " * ### Event: mxEvent.NORMALIZE",
      " *",
      " * Fires after the window is normalized, that is, it returned from",
      " * maximized or minimized state. The <code>event</code> property contains the",
      " * corresponding mouse event.",
      " *",
      " * ### Event: mxEvent.ACTIVATE",
      " *",
      " * Fires after a window is activated. The <code>previousWindow</code> property",
      " * contains the previous window. The event sender is the active window.",
      " *",
      " * ### Event: mxEvent.SHOW",
      " *",
      " * Fires after the window is shown. This event has no properties.",
      " *",
      " * ### Event: mxEvent.HIDE",
      " *",
      " * Fires after the window is hidden. This event has no properties.",
      " *",
      " * ### Event: mxEvent.CLOSE",
      " *",
      " * Fires before the window is closed. The <code>event</code> property contains",
      " * the corresponding mouse event.",
      " *",
      " * ### Event: mxEvent.DESTROY",
      " *",
      " * Fires before the window is destroyed. This event has no properties.",
      " *",
      " * @class mxWindow",
      " * @extends mxEventSource",
      " */"
    ],
    {
      ");": [
        ");",
        [
          "/**",
          " * Constructs a new window with the given dimension and title to display",
          " * the specified content. The window elements use the given style as a",
          " * prefix for the classnames of the respective window elements, namely,",
          " * the window title and window pane. The respective postfixes are appended",
          " * to the given stylename as follows:",
          " *",
          " *   style - Base style for the window.",
          " *   style+Title - Style for the window title.",
          " *   style+Pane - Style for the window pane.",
          " *",
          " * The default value for style is mxWindow, resulting in the following",
          " * classnames for the window elements: mxWindow, mxWindowTitle and",
          " * mxWindowPane.",
          " *",
          " * If replaceNode is given then the window replaces the given DOM node in",
          " * the document.",
          " *",
          " *",
          " * @param title - String that represents the title of the new window.",
          " * @param content - DOM node that is used as the window content.",
          " * @param x - X-coordinate of the window location.",
          " * @param y - Y-coordinate of the window location.",
          " * @param width - Width of the window.",
          " * @param height - Optional height of the window. Default is to match the height",
          " * of the content at the specified width.",
          " * @param minimizable - Optional boolean indicating if the window is minimizable.",
          " * Default is true.",
          " * @param movable - Optional boolean indicating if the window is movable. Default",
          " * is true.",
          " * @param replaceNode - Optional DOM node that the window should replace.",
          " * @param style - Optional base classname for the window elements. Default is",
          " * mxWindow.",
          " */"
        ]
      ],
      "closeImage": [
        "closeImage: string; //  = mxClient.imageBasePath + '/close.gif';",
        [
          "/**",
          " * URL of the image to be used for the close icon in the titlebar.",
          " */"
        ]
      ],
      "minimizeImage": [
        "minimizeImage: string; // = mxClient.imageBasePath + '/minimize.gif';",
        [
          "/**",
          " * URL of the image to be used for the minimize icon in the titlebar.",
          " */"
        ]
      ],
      "normalizeImage": [
        "normalizeImage: string; // = mxClient.imageBasePath + '/normalize.gif';",
        [
          "/**",
          " * URL of the image to be used for the normalize icon in the titlebar.",
          " */"
        ]
      ],
      "maximizeImage": [
        "maximizeImage: string; // = mxClient.imageBasePath + '/maximize.gif';",
        [
          "/**",
          " * URL of the image to be used for the maximize icon in the titlebar.",
          " */"
        ]
      ],
      "resizeImage": [
        "resizeImage: string; // = mxClient.imageBasePath + '/resize.gif';",
        [
          "/**",
          " * URL of the image to be used for the resize icon.",
          " */"
        ]
      ],
      "visible": [
        "visible: boolean; // = false;",
        [
          "/**",
          " * Boolean flag that represents the visible state of the window.",
          " */"
        ]
      ],
      "minimumSize": [
        "minimumSize: mxRectangle; // = new mxRectangle(0, 0, 50, 40);",
        [
          "/**",
          " * <mxRectangle> that specifies the minimum width and height of the window.",
          " * Default is (50, 40).",
          " */"
        ]
      ],
      "destroyOnClose": [
        "destroyOnClose: boolean; // = true;",
        [
          "/**",
          " * Specifies if the window should be destroyed when it is closed. If this",
          " * is false then the window is hidden using <setVisible>. Default is true.",
          " */"
        ]
      ],
      "contentHeightCorrection": [
        "contentHeightCorrection: number; //  = (document.documentMode == 8 || document.documentMode == 7) ? 6 : 2;",
        [
          "/**",
          " * Defines the correction factor for computing the height of the contentWrapper.",
          " * Default is 6 for IE 7/8 standards mode and 2 for all other browsers and modes.",
          " */"
        ]
      ],
      "title": [
        "title: HTMLElement;",
        [
          "/**",
          " * Reference to the DOM node (TD) that contains the title.",
          " */"
        ]
      ],
      "content": [
        "content: HTMLElement;",
        [
          "/**",
          " * Reference to the DOM node that represents the window content.",
          " */"
        ]
      ],
      "init": [
        "init(x: number, y: number, width: number, height: number, style: string): void;",
        [
          "/**",
          " * Initializes the DOM tree that represents the window.",
          " */"
        ]
      ],
      "setTitle": [
        "setTitle(title: HTMLElement): void;",
        [
          "/**",
          " * Sets the window title to the given string. HTML markup inside the title",
          " * will be escaped.",
          " */"
        ]
      ],
      "setScrollable": [
        "setScrollable(scrollable: boolean): void;",
        [
          "/**",
          " * Sets if the window contents should be scrollable.",
          " */"
        ]
      ],
      "activate": [
        "activate(): void;",
        [
          "/**",
          " * Puts the window on top of all other windows.",
          " */"
        ]
      ],
      "getElement": [
        "getElement(): HTMLElement;",
        [
          "/**",
          " * Returuns the outermost DOM node that makes up the window.",
          " */"
        ]
      ],
      "fit": [
        "fit(): void;",
        [
          "/**",
          " * Makes sure the window is inside the client area of the window.",
          " */"
        ]
      ],
      "isResizable": [
        "isResizable(): boolean;",
        [
          "/**",
          " * Returns true if the window is resizable.",
          " */"
        ]
      ],
      "setResizable": [
        "setResizable(resizable: boolean): void;",
        [
          "/**",
          " * Sets if the window should be resizable. To avoid interference with some",
          " * built-in features of IE10 and later, the use of the following code is",
          " * recommended if there are resizable <mxWindow>s in the page:",
          " *",
          " * ```javascript",
          " * if (mxClient.IS_POINTER)",
          " * {",
          " *   document.body.style.msTouchAction = 'none';",
          " * }",
          " * ```",
          " */"
        ]
      ],
      "setSize": [
        "setSize(width: number, height: number): void;",
        [
          "/**",
          " * Sets the size of the window.",
          " */"
        ]
      ],
      "setMinimizable": [
        "setMinimizable(minimizable: boolean): void;",
        [
          "/**",
          " * Sets if the window is minimizable.",
          " */"
        ]
      ],
      "getMinimumSize": [
        "getMinimumSize(): mxRectangle;",
        [
          "/**",
          " * Returns an <mxRectangle> that specifies the size for the minimized window.",
          " * A width or height of 0 means keep the existing width or height. This",
          " * implementation returns the height of the window title and keeps the width.",
          " */"
        ]
      ],
      "installMinimizeHandler": [
        "installMinimizeHandler(): void;",
        [
          "/**",
          " * Installs the event listeners required for minimizing the window.",
          " */"
        ]
      ],
      "setMaximizable": [
        "setMaximizable(maximizable: boolean): void;",
        [
          "/**",
          " * Sets if the window is maximizable.",
          " */"
        ]
      ],
      "installMaximizeHandler": [
        "installMaximizeHandler(): void;",
        [
          "/**",
          " * Installs the event listeners required for maximizing the window.",
          " */"
        ]
      ],
      "installMoveHandler": [
        "installMoveHandler(): void;",
        [
          "/**",
          " * Installs the event listeners required for moving the window.",
          " */"
        ]
      ],
      "setLocation": [
        "setLocation(x: number, y: number): void;",
        [
          "/**",
          " * Sets the upper, left corner of the window.",
          " */"
        ]
      ],
      "getX": [
        "getX(): number;",
        [
          "/**",
          " * Returns the current position on the x-axis.",
          " */"
        ]
      ],
      "getY": [
        "getY(): number;",
        [
          "/**",
          " * Returns the current position on the y-axis.",
          " */"
        ]
      ],
      "installCloseHandler": [
        "installCloseHandler(): void;",
        [
          "/**",
          " * Adds the <closeImage> as a new image node in <closeImg> and installs the",
          " * <close> event.",
          " */"
        ]
      ],
      "setImage": [
        "setImage(image: string): void;",
        [
          "/**",
          " * Sets the image associated with the window.",
          " *",
          " *",
          " * @param image - URL of the image to be used.",
          " */"
        ]
      ],
      "setClosable": [
        "setClosable(closable: boolean): void;",
        [
          "/**",
          " * Sets the image associated with the window.",
          " *",
          " *",
          " * @param closable - Boolean specifying if the window should be closable.",
          " */"
        ]
      ],
      "isVisible": [
        "isVisible(): boolean;",
        [
          "/**",
          " * Returns true if the window is visible.",
          " */"
        ]
      ],
      "setVisible": [
        "setVisible(visible: boolean): void;",
        [
          "/**",
          " * Shows or hides the window depending on the given flag.",
          " *",
          " *",
          " * @param visible - Boolean indicating if the window should be made visible.",
          " */"
        ]
      ],
      "show": [
        "show(): void;",
        [
          "/**",
          " * Shows the window.",
          " */"
        ]
      ],
      "hide": [
        "hide(): void;",
        [
          "/**",
          " * Hides the window.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Destroys the window and removes all associated resources. Fires a",
          " * <destroy> event prior to destroying the window.",
          " */"
        ]
      ]
    }
  ],
  "mxEventObject": [
    null,
    {
      "constructor": [
        "constructor(name: string, ...args: any[]);",
        null
      ],
      "name": [
        "name: string;",
        [
          "/**",
          " * Variable: name",
          " *",
          " * Holds the name.",
          " */"
        ]
      ],
      "properties": [
        "properties: any[];",
        [
          "/**",
          " * Variable: properties",
          " *",
          " * Holds the properties as an associative array.",
          " */"
        ]
      ],
      "consumed": [
        "consumed: boolean;",
        [
          "/**",
          " * Variable: consumed",
          " *",
          " * Holds the consumed state. Default is false.",
          " */"
        ]
      ],
      "getName": [
        "getName(): string;",
        [
          "/**",
          " * Function: getName",
          " *",
          " * Returns <name>.",
          " */"
        ]
      ],
      "getProperties": [
        "getProperties(): any[];",
        [
          "/**",
          " * Function: getProperties",
          " *",
          " * Returns <properties>.",
          " */"
        ]
      ],
      "getProperty": [
        "getProperty(key: string): any;",
        [
          "/**",
          " * Function: getProperty",
          " *",
          " * Returns the property for the given key.",
          " */"
        ]
      ],
      "isConsumed": [
        "isConsumed(): boolean;",
        [
          "/**",
          " * Function: isConsumed",
          " *",
          " * Returns true if the event has been consumed.",
          " */"
        ]
      ],
      "consume": [
        "consume(): void;",
        [
          "/**",
          " * Function: consume",
          " *",
          " * Consumes the event.",
          " */"
        ]
      ]
    }
  ],
  "mxForm": [
    [
      "/**",
      " * A simple class for creating HTML forms.",
      " *",
      " * @class mxForm",
      " */"
    ],
    {
      "constructor": [
        "constructor(className: string);",
        [
          "/**",
          " * Creates a HTML table using the specified classname.",
          " * @constructor",
          " */"
        ]
      ],
      "table": [
        "table: HTMLTableElement;",
        [
          "/**",
          " * Holds the DOM node that represents the table.",
          " */"
        ]
      ],
      "body": [
        "body: boolean;",
        [
          "/**",
          " * Holds the DOM node that represents the tbody (table body). New rows",
          " * can be added to this object using DOM API.",
          " */"
        ]
      ],
      "getTable": [
        "getTable(): HTMLTableElement;",
        [
          "/**",
          " * Returns the table that contains this form.",
          " */"
        ]
      ],
      "addButtons": [
        "addButtons(okFunct: Function, cancelFunct: Function): void;",
        [
          "/**",
          " * Helper method to add an OK and Cancel button using the respective",
          " * functions.",
          " */"
        ]
      ],
      "addText": [
        "addText(name: string, value: any, type: string): HTMLInputElement;",
        [
          "/**",
          " * Adds an input for the given name, type and value and returns it.",
          " */"
        ]
      ],
      "addCheckbox": [
        "addCheckbox(name: string, value: boolean): HTMLInputElement;",
        [
          "/**",
          " * Adds a checkbox for the given name and value and returns the textfield.",
          " */"
        ]
      ],
      "addTextarea": [
        "addTextarea(name: string, value: string, rows: number): HTMLTextAreaElement;",
        [
          "/**",
          " * Adds a textarea for the given name and value and returns the textarea.",
          " */"
        ]
      ],
      "addCombo": [
        "addCombo(name: string, isMultiSelect: boolean, size?: number): HTMLSelectElement;",
        [
          "/**",
          " * Adds a combo for the given name and returns the combo.",
          " */"
        ]
      ],
      "addOption": [
        "addOption(combo: HTMLElement, label: string, value: any, isSelected?: boolean): void;",
        [
          "/**",
          " * Adds an option for the given label to the specified combo.",
          " */"
        ]
      ],
      "addField": [
        "addField(name: string, input: FormFieldType): FormFieldType;",
        [
          "/**",
          " * Adds a new row with the name and the input field in two columns and",
          " * returns the given input.",
          " */"
        ]
      ]
    }
  ],
  "mxDivResizer": [
    [
      "/**",
      " * Maintains the size of a div element in Internet Explorer. This is a",
      " * workaround for the right and bottom style being ignored in IE.",
      " *",
      " * If you need a div to cover the scrollwidth and -height of a document,",
      " * then you can use this class as follows:",
      " *",
      " * @example",
      " * ```javascript",
      " * var resizer = new mxDivResizer(background);",
      " * resizer.getDocumentHeight()",
      " * {",
      " *   return document.body.scrollHeight;",
      " * }",
      " * resizer.getDocumentWidth()",
      " * {",
      " *   return document.body.scrollWidth;",
      " * }",
      " * resizer.resize();",
      " * ```",
      " *",
      " * @class mxDivResizer",
      " */"
    ],
    {
      "constructor": [
        "constructor(div: HTMLElement, container?: HTMLElement | Window);",
        [
          "/**",
          " *",
          " * Constructs an object that maintains the size of a div",
          " * element when the window is being resized. This is only",
          " * required for Internet Explorer as it ignores the respective",
          " * stylesheet information for DIV elements.",
          " *",
          " * @param div - Reference to the DOM node whose size should be maintained.",
          " * @param container - Optional Container that contains the div. Default is the",
          " * window.",
          " */"
        ]
      ],
      "resizeWidth": [
        "resizeWidth: boolean;",
        [
          "/**",
          " * Boolean specifying if the width should be updated.",
          " */"
        ]
      ],
      "resizeHeight": [
        "resizeHeight: boolean;",
        [
          "/**",
          " * Boolean specifying if the height should be updated.",
          " */"
        ]
      ],
      "handlingResize": [
        "handlingResize: boolean;",
        [
          "/**",
          " * Boolean specifying if the width should be updated.",
          " */"
        ]
      ],
      "resize": [
        "resize(): void;",
        [
          "/**",
          " * Updates the style of the DIV after the window has been resized.",
          " */"
        ]
      ],
      "getDocumentWidth": [
        "getDocumentWidth(): number;",
        [
          "/**",
          " * Hook for subclassers to return the width of the document (without",
          " * scrollbars).",
          " */"
        ]
      ],
      "getDocumentHeight": [
        "getDocumentHeight(): number;",
        [
          "/**",
          " * Hook for subclassers to return the height of the document (without",
          " * scrollbars).",
          " */"
        ]
      ]
    }
  ],
  "mxEventSource": [
    null,
    {
      "constructor": [
        "constructor(eventSource?: any);",
        null
      ],
      "eventListeners": [
        "eventListeners: any[];",
        [
          "/**",
          " * Variable: eventListeners",
          " *",
          " * Holds the event names and associated listeners in an array. The array",
          " * contains the event name followed by the respective listener for each",
          " * registered listener.",
          " */"
        ]
      ],
      "eventsEnabled": [
        "eventsEnabled: boolean;",
        [
          "/**",
          " * Variable: eventsEnabled",
          " *",
          " * Specifies if events can be fired. Default is true.",
          " */"
        ]
      ],
      "eventSource": [
        "eventSource: any;",
        [
          "/**",
          " * Variable: eventSource",
          " *",
          " * Optional source for events. Default is null.",
          " */"
        ]
      ],
      "isEventsEnabled": [
        "isEventsEnabled(): boolean;",
        [
          "/**",
          " * Function: isEventsEnabled",
          " *",
          " * Returns <eventsEnabled>.",
          " */"
        ]
      ],
      "setEventsEnabled": [
        "setEventsEnabled(value: boolean): void;",
        [
          "/**",
          " * Function: setEventsEnabled",
          " *",
          " * Sets <eventsEnabled>.",
          " */"
        ]
      ],
      "getEventSource": [
        "getEventSource(): any;",
        [
          "/**",
          " * Function: getEventSource",
          " *",
          " * Returns <eventSource>.",
          " */"
        ]
      ],
      "setEventSource": [
        "setEventSource(value: any): void;",
        [
          "/**",
          " * Function: setEventSource",
          " *",
          " * Sets <eventSource>.",
          " */"
        ]
      ],
      "addListener": [
        "addListener(name: string, funct: (...args: any[]) => any): void;",
        [
          "/**",
          " * Function: addListener",
          " *",
          " * Binds the specified function to the given event name. If no event name",
          " * is given, then the listener is registered for all events.",
          " *",
          " * The parameters of the listener are the sender and an <mxEventObject>.",
          " */"
        ]
      ],
      "removeListener": [
        "removeListener(funct: (...args: any[]) => any): void;",
        [
          "/**",
          " * Function: removeListener",
          " *",
          " * Removes all occurrences of the given listener from <eventListeners>.",
          " */"
        ]
      ],
      "fireEvent": [
        "fireEvent(evt: mxEventObject, sender: any): void;",
        [
          "/**",
          " * Function: fireEvent",
          " *",
          " * Dispatches the given event to the listeners which are registered for",
          " * the event. The sender argument is optional. The current execution scope",
          " * (\"this\") is used for the listener invocation (see <mxUtils.bind>).",
          " *",
          " * Example:",
          " *",
          " * (code)",
          " * fireEvent(new mxEventObject(\"eventName\", key1, val1, .., keyN, valN))",
          " * (end)",
          " *",
          " * Parameters:",
          " *",
          " * evt - <mxEventObject> that represents the event.",
          " * sender - Optional sender to be passed to the listener. Default value is",
          " * the return value of <getEventSource>.",
          " */"
        ]
      ]
    }
  ],
  "mxUndoableEdit": [
    null,
    {
      "constructor": [
        "constructor(source: any, significant: boolean);",
        null
      ],
      "source": [
        "source: any;",
        [
          "/**",
          " * Variable: source",
          " *",
          " * Specifies the source of the edit.",
          " */"
        ]
      ],
      ">;": [
        ">;",
        [
          "/**",
          " * Variable: changes",
          " *",
          " * Array that contains the changes that make up this edit. The changes are",
          " * expected to either have an undo and redo function, or an execute",
          " * function. Default is an empty array.",
          " */"
        ]
      ],
      "significant": [
        "significant: boolean;",
        [
          "/**",
          " * Variable: significant",
          " *",
          " * Specifies if the undoable change is significant.",
          " * Default is true.",
          " */"
        ]
      ],
      "undone": [
        "undone: boolean;",
        [
          "/**",
          " * Variable: undone",
          " *",
          " * Specifies if this edit has been undone. Default is false.",
          " */"
        ]
      ],
      "redone": [
        "redone: boolean;",
        [
          "/**",
          " * Variable: redone",
          " *",
          " * Specifies if this edit has been redone. Default is false.",
          " */"
        ]
      ],
      "isEmpty": [
        "isEmpty(): boolean;",
        [
          "/**",
          " * Function: isEmpty",
          " *",
          " * Returns true if the this edit contains no changes.",
          " */"
        ]
      ],
      "isSignificant": [
        "isSignificant(): boolean;",
        [
          "/**",
          " * Function: isSignificant",
          " *",
          " * Returns <significant>.",
          " */"
        ]
      ],
      "add": [
        "add(change: mxUndoableChange): void;",
        [
          "/**",
          " * Function: add",
          " *",
          " * Adds the specified change to this edit. The change is an object that is",
          " * expected to either have an undo and redo, or an execute function.",
          " */"
        ]
      ],
      "notify": [
        "notify(): void;",
        [
          "/**",
          " * Function: notify",
          " *",
          " * Hook to notify any listeners of the changes after an <undo> or <redo>",
          " * has been carried out. This implementation is empty.",
          " */"
        ]
      ],
      "die": [
        "die(): void;",
        [
          "/**",
          " * Function: die",
          " *",
          " * Hook to free resources after the edit has been removed from the command",
          " * history. This implementation is empty.",
          " */"
        ]
      ],
      "undo": [
        "undo(): void;",
        [
          "/**",
          " * Function: undo",
          " *",
          " * Undoes all changes in this edit.",
          " */"
        ]
      ],
      "redo": [
        "redo(): void;",
        [
          "/**",
          " * Function: redo",
          " *",
          " * Redoes all changes in this edit.",
          " */"
        ]
      ],
      "execute": [
        "execute(): void;",
        [
          "/**",
          " * Function: redo",
          " *",
          " * Redoes all changes in this edit.",
          " */"
        ]
      ]
    }
  ],
  "mxObjectIdentity": [
    [
      "/**",
      " * @class",
      " *",
      " * Identity for JavaScript objects and functions. This is implemented using",
      " * a simple incrementing counter which is stored in each object under",
      " * {@link FIELD_NAME}.",
      " *",
      " * The identity for an object does not change during its lifecycle.",
      " */"
    ],
    {
      "static FIELD_NAME": [
        "static FIELD_NAME: string;",
        [
          "/**",
          " * Name of the field to be used to store the object ID. Default is",
          " * <code>mxObjectId</code>.",
          " */"
        ]
      ],
      "static counter": [
        "static counter: number;",
        [
          "/**",
          " * Current counter.",
          " */"
        ]
      ],
      "static get": [
        "static get(obj: any): any;",
        [
          "/**",
          " * Returns the ID for the given object or function or null if no object",
          " * is specified.",
          " */"
        ]
      ],
      "static clear": [
        "static clear(obj: any): void;",
        [
          "/**",
          " * Deletes the ID from the given object or function.",
          " */"
        ]
      ],
      "dx": [
        "dx: number;",
        null
      ],
      "dy": [
        "dy: number;",
        null
      ],
      "scale": [
        "scale(value: number): void;",
        [
          "/**",
          " * Scales the current state.",
          " */"
        ]
      ],
      "alpha": [
        "alpha: number;",
        null
      ],
      "fillAlpha": [
        "fillAlpha: number;",
        null
      ],
      "strokeAlpha": [
        "strokeAlpha: number;",
        null
      ],
      "fillColor": [
        "fillColor: string;",
        null
      ],
      "gradientFillAlpha": [
        "gradientFillAlpha: number;",
        null
      ],
      "gradientColor": [
        "gradientColor: string;",
        null
      ],
      "gradientAlpha": [
        "gradientAlpha: number;",
        null
      ],
      "gradientDirection": [
        "gradientDirection: string;",
        null
      ],
      "strokeColor": [
        "strokeColor: string;",
        null
      ],
      "strokeWidth": [
        "strokeWidth: number;",
        null
      ],
      "dashed": [
        "dashed: boolean;",
        null
      ],
      "dashPattern": [
        "dashPattern: string;",
        null
      ],
      "fixDash": [
        "fixDash: boolean;",
        null
      ],
      "lineCap": [
        "lineCap: string;",
        null
      ],
      "lineJoin": [
        "lineJoin: string;",
        null
      ],
      "miterLimit": [
        "miterLimit: number;",
        null
      ],
      "fontColor": [
        "fontColor: string;",
        null
      ],
      "fontBackgroundColor": [
        "fontBackgroundColor: string;",
        null
      ],
      "fontBorderColor": [
        "fontBorderColor: string;",
        null
      ],
      "fontSize": [
        "fontSize: number;",
        null
      ],
      "fontFamily": [
        "fontFamily: string;",
        null
      ],
      "fontStyle": [
        "fontStyle: number;",
        null
      ],
      "shadow": [
        "shadow: boolean;",
        null
      ],
      "shadowColor": [
        "shadowColor: string;",
        null
      ],
      "shadowAlpha": [
        "shadowAlpha: number;",
        null
      ],
      "shadowDx": [
        "shadowDx: number;",
        null
      ],
      "shadowDy": [
        "shadowDy: number;",
        null
      ],
      "rotation": [
        "rotation: number;",
        null
      ],
      "rotationCx": [
        "rotationCx: number;",
        null
      ],
      "rotationCy": [
        "rotationCy: number;",
        null
      ],
      "protected constructor": [
        "protected constructor();",
        null
      ],
      "state": [
        "state: mxCanvas2DState;",
        [
          "/**",
          " * Holds the current state.",
          " */"
        ]
      ],
      "states": [
        "states: mxCanvas2DState[];",
        [
          "/**",
          " * Stack of states.",
          " */"
        ]
      ],
      "path": [
        "path: string[];",
        [
          "/**",
          " * Holds the current path as an array.",
          " */"
        ]
      ],
      "rotateHtml": [
        "rotateHtml: boolean;",
        [
          "/**",
          " * Switch for rotation of HTML.",
          " * @default true",
          " */"
        ]
      ],
      "lastX": [
        "lastX: number;",
        [
          "/**",
          " * Holds the last x coordinate.",
          " * @default 0",
          " */"
        ]
      ],
      "lastY": [
        "lastY: number;",
        [
          "/**",
          " * Holds the last y coordinate.",
          " * @default 0",
          " */"
        ]
      ],
      "moveOp": [
        "moveOp: string;",
        [
          "/**",
          " * Contains the string used for moving in paths.",
          " * @default 'M'",
          " */"
        ]
      ],
      "lineOp": [
        "lineOp: string;",
        [
          "/**",
          " * Contains the string used for moving in paths.",
          " * @default 'L'",
          " */"
        ]
      ],
      "quadOp": [
        "quadOp: string;",
        [
          "/**",
          " * Contains the string used for quadratic paths.",
          " * @default 'Q'",
          " */"
        ]
      ],
      "curveOp": [
        "curveOp: string;",
        [
          "/**",
          " * Contains the string used for bezier curves.",
          " * @default 'C'",
          " */"
        ]
      ],
      "closeOp": [
        "closeOp: string;",
        [
          "/**",
          " * Holds the operator for closing curves.",
          " * @default 'Z'",
          " */"
        ]
      ],
      "pointerEvents": [
        "pointerEvents: boolean;",
        [
          "/**",
          " * Boolean value that specifies if events should be handled.",
          " * @default false",
          " */"
        ]
      ],
      "createUrlConverter": [
        "createUrlConverter(): mxUrlConverter;",
        [
          "/**",
          " * Create a new {@link mxUrlConverter} and returns it.",
          " */"
        ]
      ],
      "reset": [
        "reset(): void;",
        [
          "/**",
          " * Resets the state of this canvas.",
          " */"
        ]
      ],
      "createState": [
        "createState(): mxCanvas2DState;",
        [
          "/**",
          " * Creates the state of the this canvas.",
          " */"
        ]
      ],
      "format": [
        "format(value: string): number;",
        [
          "/**",
          " * Rounds all numbers to integers.",
          " */"
        ]
      ],
      "addOp": [
        "addOp(): void;",
        [
          "/**",
          " * Adds the given operation to the path.",
          " */"
        ]
      ],
      "rotatePoint": [
        "rotatePoint(x: number, y: number, theta: number, cx: number, cy: number): void;",
        [
          "/**",
          " * Rotates the given point and returns the result as an <mxPoint>.",
          " */"
        ]
      ],
      "save": [
        "save(): void;",
        [
          "/**",
          " * Saves the current state.",
          " */"
        ]
      ],
      "restore": [
        "restore(): void;",
        [
          "/**",
          " * Restores the current state.",
          " */"
        ]
      ],
      "setLink": [
        "setLink(link: string): void;",
        [
          "/**",
          " * Sets the current link. Hook for subclassers.",
          " */"
        ]
      ],
      "translate": [
        "translate(dx: number, dy: number): void;",
        [
          "/**",
          " * Translates the current state.",
          " */"
        ]
      ],
      "rotate": [
        "rotate(theta: number, flipH: boolean, flipV: boolean, cx: number, cy: number): void;",
        [
          "/**",
          " * Rotates the current state.",
          " */"
        ]
      ],
      "setAlpha": [
        "setAlpha(value: number): void;",
        [
          "/**",
          " * Sets the current alpha.",
          " */"
        ]
      ],
      "setFillAlpha": [
        "setFillAlpha(value: number): void;",
        [
          "/**",
          " * Sets the current solid fill alpha.",
          " */"
        ]
      ],
      "setStrokeAlpha": [
        "setStrokeAlpha(value: number): void;",
        [
          "/**",
          " * Sets the current stroke alpha.",
          " */"
        ]
      ],
      "setFillColor": [
        "setFillColor(value: string): void;",
        [
          "/**",
          " * Sets the current fill color.",
          " */"
        ]
      ],
      ")": [
        "): void;",
        [
          "/**",
          " * Fills and paints the outline of the current path.",
          " */"
        ]
      ],
      "setStrokeColor": [
        "setStrokeColor(value: string): void;",
        [
          "/**",
          " * Sets the current stroke color.",
          " */"
        ]
      ],
      "setStrokeWidth": [
        "setStrokeWidth(value: number): void;",
        [
          "/**",
          " * Sets the current stroke width.",
          " */"
        ]
      ],
      "setDashed": [
        "setDashed(value: boolean, fixDash: boolean): void;",
        [
          "/**",
          " * Enables or disables dashed lines.",
          " * @param value specifies whether or not the lines are dashed",
          " * @param fixDash specifies whether or not the lines use fix dash",
          " */"
        ]
      ],
      "setDashPattern": [
        "setDashPattern(value: string): void;",
        [
          "/**",
          " * Sets the current dash pattern.",
          " */"
        ]
      ],
      "setLineCap": [
        "setLineCap(value: string): void;",
        [
          "/**",
          " * Sets the current line cap.",
          " */"
        ]
      ],
      "setLineJoin": [
        "setLineJoin(value: string): void;",
        [
          "/**",
          " * Sets the current line join.",
          " */"
        ]
      ],
      "setMiterLimit": [
        "setMiterLimit(value: number): void;",
        [
          "/**",
          " * Sets the current miter limit.",
          " */"
        ]
      ],
      "setFontColor": [
        "setFontColor(value: string): void;",
        [
          "/**",
          " * Sets the current font color.",
          " */"
        ]
      ],
      "setFontBackgroundColor": [
        "setFontBackgroundColor(value: string): void;",
        [
          "/**",
          " * Sets the current font color.",
          " */"
        ]
      ],
      "setFontBorderColor": [
        "setFontBorderColor(value: string): void;",
        [
          "/**",
          " * Sets the current font color.",
          " */"
        ]
      ],
      "setFontSize": [
        "setFontSize(value: number): void;",
        [
          "/**",
          " * Sets the current font size.",
          " */"
        ]
      ],
      "setFontFamily": [
        "setFontFamily(value: string): void;",
        [
          "/**",
          " * Sets the current font family.",
          " */"
        ]
      ],
      "setFontStyle": [
        "setFontStyle(value: string): void;",
        [
          "/**",
          " * Sets the current font style.",
          " */"
        ]
      ],
      "setShadow": [
        "setShadow(enabled: boolean): void;",
        [
          "/**",
          " * Enables or disables and configures the current shadow.",
          " */"
        ]
      ],
      "setShadowColor": [
        "setShadowColor(value: string): void;",
        [
          "/**",
          " * Enables or disables and configures the current shadow.",
          " */"
        ]
      ],
      "setShadowAlpha": [
        "setShadowAlpha(value: number): void;",
        [
          "/**",
          " * Enables or disables and configures the current shadow.",
          " */"
        ]
      ],
      "setShadowOffset": [
        "setShadowOffset(dx: number, dy: number): void;",
        [
          "/**",
          " * Enables or disables and configures the current shadow.",
          " */"
        ]
      ],
      "begin": [
        "begin(): void;",
        [
          "/**",
          " * Starts a new path.",
          " */"
        ]
      ],
      "moveTo": [
        "moveTo(x: number, y: number): void;",
        [
          "/**",
          " * Moves the current path the given coordinates.",
          " */"
        ]
      ],
      "lineTo": [
        "lineTo(x: number, y: number): void;",
        [
          "/**",
          " * Draws a line to the given coordinates. Uses moveTo with the op argument.",
          " */"
        ]
      ],
      "quadTo": [
        "quadTo(x1: number, y1: number, x2: number, y2: number): void;",
        [
          "/**",
          " * Adds a quadratic curve to the current path.",
          " */"
        ]
      ],
      "curveTo": [
        "curveTo(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): void;",
        [
          "/**",
          " * Adds a bezier curve to the current path.",
          " */"
        ]
      ],
      "arcTo": [
        "arcTo(rx: number, ry: number, angle: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): void;",
        [
          "/**",
          " * Adds the given arc to the current path. This is a synthetic operation that",
          " * is broken down into curves.",
          " */"
        ]
      ],
      "close": [
        "close(): void;",
        [
          "/**",
          " * Closes the current path.",
          " *",
          " * Note: the mxGraph JS code declares arguments (x1: number, y1: number, x2: number, y2: number, x3: number, y3: number)",
          " * which are not used in the abstract implementation. The mxXmlCanvas2D JS implementation overrides this method without arguments.",
          " * Decision is then taken to remove them here.",
          " */"
        ]
      ],
      "end": [
        "end(): void;",
        [
          "/**",
          " * Empty implementation for backwards compatibility. This will be removed.",
          " */"
        ]
      ],
      "stroke": [
        "stroke(): void;",
        [
          "/**",
          " * Paints the outline of the current path.",
          " */"
        ]
      ],
      "fill": [
        "fill(): void;",
        [
          "/**",
          " * Fills the current path.",
          " */"
        ]
      ],
      "fillAndStroke": [
        "fillAndStroke(): void;",
        [
          "/**",
          " * Fills and paints the outline of the current path.",
          " */"
        ]
      ],
      "rect": [
        "rect(x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Fills and paints the outline of the current path.",
          " */"
        ]
      ],
      "roundrect": [
        "roundrect(x: number, y: number, w: number, h: number, dx: number, dy: number): void;",
        [
          "/**",
          " * Fills and paints the outline of the current path.",
          " */"
        ]
      ],
      "ellipse": [
        "ellipse(x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Fills and paints the outline of the current path.",
          " */"
        ]
      ]
    }
  ],
  "mxUrlConverter": [
    null,
    {
      "constructor": [
        "constructor();",
        null
      ],
      "enabled": [
        "enabled: boolean;",
        [
          "/**",
          " * Variable: enabled",
          " *",
          " * Specifies if the converter is enabled. Default is true.",
          " */"
        ]
      ],
      "baseUrl": [
        "baseUrl: string;",
        [
          "/**",
          " * Variable: baseUrl",
          " *",
          " * Specifies the base URL to be used as a prefix for relative URLs.",
          " */"
        ]
      ],
      "baseDomain": [
        "baseDomain: string;",
        [
          "/**",
          " * Variable: baseDomain",
          " *",
          " * Specifies the base domain to be used as a prefix for absolute URLs.",
          " */"
        ]
      ],
      "updateBaseUrl": [
        "updateBaseUrl(): void;",
        [
          "/**",
          " * Function: updateBaseUrl",
          " *",
          " * Private helper function to update the base URL.",
          " */"
        ]
      ],
      "isEnabled": [
        "isEnabled(): boolean;",
        [
          "/**",
          " * Function: isEnabled",
          " *",
          " * Returns <enabled>.",
          " */"
        ]
      ],
      "setEnabled": [
        "setEnabled(value: boolean): void;",
        [
          "/**",
          " * Function: setEnabled",
          " *",
          " * Sets <enabled>.",
          " */"
        ]
      ],
      "getBaseUrl": [
        "getBaseUrl(): string;",
        [
          "/**",
          " * Function: getBaseUrl",
          " *",
          " * Returns <baseUrl>.",
          " */"
        ]
      ],
      "setBaseUrl": [
        "setBaseUrl(value: string): void;",
        [
          "/**",
          " * Function: setBaseUrl",
          " *",
          " * Sets <baseUrl>.",
          " */"
        ]
      ],
      "getBaseDomain": [
        "getBaseDomain(): string;",
        [
          "/**",
          " * Function: getBaseDomain",
          " *",
          " * Returns <baseDomain>.",
          " */"
        ]
      ],
      "setBaseDomain": [
        "setBaseDomain(value: string): void;",
        [
          "/**",
          " * Function: setBaseDomain",
          " *",
          " * Sets <baseDomain>.",
          " */"
        ]
      ],
      "isRelativeUrl": [
        "isRelativeUrl(url: string): boolean;",
        [
          "/**",
          " * Function: isRelativeUrl",
          " *",
          " * Returns true if the given URL is relative.",
          " */"
        ]
      ],
      "convert": [
        "convert(url: string): string;",
        [
          "/**",
          " * Function: convert",
          " *",
          " * Converts the given URL to an absolute URL with protol and domain.",
          " * Relative URLs are first converted to absolute URLs.",
          " */"
        ]
      ]
    }
  ],
  "mxAutoSaveManager": [
    [
      "/**",
      " * Manager for automatically saving diagrams. The <save> hook must be",
      " * implemented.",
      " *",
      " * @example",
      " * ```javascript",
      " * var mgr = new mxAutoSaveManager(editor.graph);",
      " * mgr.save()",
      " * {",
      " *   mxLog.show();",
      " *   mxLog.debug('save');",
      " * };",
      " * ```",
      " *",
      " * @class mxAutoSaveManager",
      " * @extends mxEventSource",
      " */"
    ],
    {
      "constructor": [
        "constructor(graph: mxGraph);",
        [
          "/**",
          " * Constructs a new automatic layout for the given graph.",
          " *",
          " * @param graph - Reference to the enclosing graph.",
          " */"
        ]
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Reference to the enclosing <mxGraph>.",
          " */"
        ]
      ],
      "autoSaveDelay": [
        "autoSaveDelay: number;",
        [
          "/**",
          " * Minimum amount of seconds between two consecutive autosaves. Eg. a",
          " * value of 1 (s) means the graph is not stored more than once per second.",
          " * Default is 10.",
          " */"
        ]
      ],
      "autoSaveThrottle": [
        "autoSaveThrottle: number;",
        [
          "/**",
          " * Minimum amount of seconds between two consecutive autosaves triggered by",
          " * more than <autoSaveThreshhold> changes within a timespan of less than",
          " * <autoSaveDelay> seconds. Eg. a value of 1 (s) means the graph is not",
          " * stored more than once per second even if there are more than",
          " * <autoSaveThreshold> changes within that timespan. Default is 2.",
          " */"
        ]
      ],
      "autoSaveThreshold": [
        "autoSaveThreshold: number;",
        [
          "/**",
          " * Minimum amount of ignored changes before an autosave. Eg. a value of 2",
          " * means after 2 change of the graph model the autosave will trigger if the",
          " * condition below is true. Default is 5.",
          " */"
        ]
      ],
      "ignoredChanges": [
        "ignoredChanges: number;",
        [
          "/**",
          " * Counter for ignored changes in autosave.",
          " */"
        ]
      ],
      "lastSnapshot": [
        "lastSnapshot: number;",
        [
          "/**",
          " * Used for autosaving. See <autosave>.",
          " */"
        ]
      ],
      "enabled": [
        "enabled: boolean;",
        [
          "/**",
          " * Specifies if event handling is enabled. Default is true.",
          " */"
        ]
      ],
      "changeHandler": [
        "changeHandler: Function;",
        [
          "/**",
          " * Holds the function that handles graph model changes.",
          " */"
        ]
      ],
      "isEnabled": [
        "isEnabled(): boolean;",
        [
          "/**",
          " * Returns true if events are handled. This implementation",
          " * returns <enabled>.",
          " */"
        ]
      ],
      "setEnabled": [
        "setEnabled(value: boolean): void;",
        [
          "/**",
          " * Enables or disables event handling. This implementation",
          " * updates <enabled>.",
          " *",
          " * @param enabled - Boolean that specifies the new enabled state.",
          " */"
        ]
      ],
      "setGraph": [
        "setGraph(graph: mxGraph): void;",
        [
          "/**",
          " * Sets the graph that the layouts operate on.",
          " */"
        ]
      ],
      "save": [
        "save(): void;",
        [
          "/**",
          " * Empty hook that is called if the graph should be saved.",
          " */"
        ]
      ],
      "graphModelChanged": [
        "graphModelChanged(changes: any): void;",
        [
          "/**",
          " * Invoked when the graph model has changed.",
          " */"
        ]
      ],
      "reset": [
        "reset(): void;",
        [
          "/**",
          " * Resets all counters.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Removes all handlers from the <graph> and deletes the reference to it.",
          " */"
        ]
      ]
    }
  ],
  "mxLog": [
    null,
    {
      "consoleName": [
        "consoleName: 'Console';",
        [
          "/**",
          " * Specifies the name of the console window.",
          " */"
        ]
      ],
      "TRACE": [
        "TRACE: boolean;",
        [
          "/**",
          " * Specified if the output for enter and leave should be visible in the console.",
          " */"
        ]
      ],
      "DEBUG": [
        "DEBUG: boolean;",
        [
          "/**",
          " * Specifies if the output for debug should be visible in the console.",
          " */"
        ]
      ],
      "WARN": [
        "WARN: boolean;",
        [
          "/**",
          " * Specifies if the output for warn should be visible in the console.",
          " */"
        ]
      ],
      "buffer": [
        "buffer: string;",
        [
          "/**",
          " * Buffer for pre-initialized content.",
          " */"
        ]
      ],
      "static init": [
        "static init(): void;",
        [
          "/**",
          " * Initializes the DOM node for the console.",
          " * This requires document.body to point to a non-null value.",
          " * This is called from within setVisible if the log has not yet been initialized.",
          " */"
        ]
      ],
      "static info": [
        "static info(): void;",
        [
          "/**",
          " * Writes the current navigator information to the console.",
          " */"
        ]
      ],
      "static addButton": [
        "static addButton(lab: string, funct: Function): void;",
        [
          "/**",
          " * Adds a button to the console using the given label and function.",
          " */"
        ]
      ],
      "static isVisible": [
        "static isVisible(): boolean;",
        [
          "/**",
          " * Returns true if the console is visible.",
          " */"
        ]
      ],
      "static show": [
        "static show(): void;",
        [
          "/**",
          " * Shows the console.",
          " */"
        ]
      ],
      "static setVisible": [
        "static setVisible(visible: boolean): void;",
        [
          "/**",
          " * Shows or hides the console.",
          " */"
        ]
      ],
      "static enter": [
        "static enter(string: string): void;",
        [
          "/**",
          " * Writes the specified string to the console if TRACE is true and returns the current time in milliseconds.",
          " */"
        ]
      ],
      "static debug": [
        "static debug(message: string): void;",
        [
          "/**",
          " * Adds all arguments to the console if DEBUG is enabled.",
          " */"
        ]
      ],
      "static warn": [
        "static warn(message: string): void;",
        [
          "/**",
          " * Adds all arguments to the console if WARN is enabled.",
          " */"
        ]
      ],
      "static write": [
        "static write(): void;",
        [
          "/**",
          " * Adds the specified strings to the console.",
          " */"
        ]
      ],
      "static writeln": [
        "static writeln(): void;",
        [
          "/**",
          " * Adds the specified strings to the console, appending a linefeed at the end of each string.",
          " */"
        ]
      ]
    }
  ],
  "mxRectangle": [
    null,
    {
      "constructor": [
        "constructor(x: number, y: number, width: number, height: number);",
        null
      ],
      "width": [
        "width: number;",
        [
          "/**",
          " * Variable: width",
          " *",
          " * Holds the width of the rectangle. Default is 0.",
          " */"
        ]
      ],
      "height": [
        "height: number;",
        [
          "/**",
          " * Variable: height",
          " *",
          " * Holds the height of the rectangle. Default is 0.",
          " */"
        ]
      ],
      "setRect": [
        "setRect(x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Function: setRect",
          " *",
          " * Sets this rectangle to the specified values",
          " */"
        ]
      ],
      "getCenterX": [
        "getCenterX(): number;",
        [
          "/**",
          " * Function: getCenterX",
          " *",
          " * Returns the x-coordinate of the center point.",
          " */"
        ]
      ],
      "getCenterY": [
        "getCenterY(): number;",
        [
          "/**",
          " * Function: getCenterY",
          " *",
          " * Returns the y-coordinate of the center point.",
          " */"
        ]
      ],
      "add": [
        "add(rect: mxRectangle): void;",
        [
          "/**",
          " * Function: add",
          " *",
          " * Adds the given rectangle to this rectangle.",
          " */"
        ]
      ],
      "intersect": [
        "intersect(rect: mxRectangle): void;",
        [
          "/**",
          " * Function: intersect",
          " *",
          " * Changes this rectangle to where it overlaps with the given rectangle.",
          " */"
        ]
      ],
      "grow": [
        "grow(amount: number): void;",
        [
          "/**",
          " * Function: grow",
          " *",
          " * Grows the rectangle by the given amount, that is, this method subtracts",
          " * the given amount from the x- and y-coordinates and adds twice the amount",
          " * to the width and height.",
          " */"
        ]
      ],
      "getPoint": [
        "getPoint(): mxPoint;",
        [
          "/**",
          " * Function: getPoint",
          " *",
          " * Returns the top, left corner as a new <mxPoint>.",
          " */"
        ]
      ],
      "rotate90": [
        "rotate90(): void;",
        [
          "/**",
          " * Function: rotate90",
          " *",
          " * Rotates this rectangle by 90 degree around its center point.",
          " */"
        ]
      ],
      "equals": [
        "equals(obj: mxRectangle): boolean;",
        [
          "/**",
          " * Function: equals",
          " *",
          " * Returns true if the given object equals this rectangle.",
          " */"
        ]
      ],
      "fromRectangle": [
        "fromRectangle(rect: mxRectangle): mxRectangle;",
        [
          "/**",
          " * Function: fromRectangle",
          " *",
          " * Returns a new <mxRectangle> which is a copy of the given rectangle.",
          " */"
        ]
      ],
      "clone": [
        "clone(): mxRectangle;",
        [
          "/**",
          " * Function: fromRectangle",
          " *",
          " * Returns a new <mxRectangle> which is a copy of the given rectangle.",
          " */"
        ]
      ],
      "static fromRectangle": [
        "static fromRectangle(rect: mxRectangle): mxRectangle;",
        [
          "/**",
          " * Function: fromRectangle",
          " *",
          " * Returns a new <mxRectangle> which is a copy of the given rectangle.",
          " */"
        ]
      ]
    }
  ],
  "mxPoint": [
    null,
    {
      "constructor": [
        "constructor(x?: number, y?: number);",
        null
      ],
      "x": [
        "x: number;",
        [
          "/**",
          " * Variable: x",
          " *",
          " * Holds the x-coordinate of the point. Default is 0.",
          " */"
        ]
      ],
      "y": [
        "y: number;",
        [
          "/**",
          " * Variable: y",
          " *",
          " * Holds the y-coordinate of the point. Default is 0.",
          " */"
        ]
      ],
      "equals": [
        "equals(obj: mxPoint): boolean;",
        [
          "/**",
          " * Function: equals",
          " *",
          " * Returns true if the given object equals this point.",
          " */"
        ]
      ],
      "clone": [
        "clone(): mxPoint;",
        [
          "/**",
          " * Function: clone",
          " *",
          " * Returns a clone of this <mxPoint>.",
          " */"
        ]
      ]
    }
  ],
  "mxToolbar": [
    [
      "/**",
      " * Creates a toolbar inside a given DOM node. The toolbar may contain icons,",
      " * buttons and combo boxes.",
      " *",
      " * ### Event: mxEvent.SELECT",
      " *",
      " * Fires when an item was selected in the toolbar. The <code>function</code>",
      " * property contains the function that was selected in <selectMode>.",
      " *",
      " * @class mxToolbar",
      " * @extends {mxEventSource}",
      " */"
    ],
    {
      "constructor": [
        "constructor(container: HTMLElement);",
        [
          "/**",
          " * Constructs a toolbar in the specified container.",
          " *",
          " * @param {HTMLElement} container - DOM node that contains the toolbar.",
          " */"
        ]
      ],
      "container": [
        "container: HTMLElement | null;",
        [
          "/**",
          " * Reference to the DOM nodes that contains the toolbar.",
          " */"
        ]
      ],
      "enabled": [
        "enabled: boolean;",
        [
          "/**",
          " * Specifies if events are handled. Default is true.",
          " */"
        ]
      ],
      "noReset": [
        "noReset: boolean;",
        [
          "/**",
          " * Specifies if <resetMode> requires a forced flag of true for resetting",
          " * the current mode in the toolbar. Default is false. This is set to true",
          " * if the toolbar item is double clicked to avoid a reset after a single",
          " * use of the item.",
          " */"
        ]
      ],
      "updateDefaultMode": [
        "updateDefaultMode: boolean;",
        [
          "/**",
          " * Boolean indicating if the default mode should be the last selected",
          " * switch mode or the first inserted switch mode. Default is true, that",
          " * is the last selected switch mode is the default mode. The default mode",
          " * is the mode to be selected after a reset of the toolbar. If this is",
          " * false, then the default mode is the first inserted mode item regardless",
          " * of what was last selected. Otherwise, the selected item after a reset is",
          " * the previously selected item.",
          " */"
        ]
      ],
      ")": [
        "): HTMLImageElement | HTMLButtonElement;",
        [
          "/**",
          " * Adds a new item to the toolbar. The selection is typically reset after",
          " * the item has been consumed, for example by adding a new vertex to the",
          " * graph. The reset is not carried out if the item is double clicked.",
          " *",
          " * The function argument uses the following signature: funct(evt, cell) where",
          " * evt is the native mouse event and cell is the cell under the mouse.",
          " */"
        ]
      ],
      "addCombo": [
        "addCombo(style?: string): HTMLSelectElement;",
        [
          "/**",
          " * Adds and returns a new SELECT element using the given style. The element",
          " * is placed inside a DIV with the mxToolbarComboContainer style classname.",
          " *",
          " * @param style - Optional style classname. Default is mxToolbarCombo.",
          " */"
        ]
      ],
      "addActionCombo": [
        "addActionCombo(title: string, style?: string): HTMLSelectElement;",
        [
          "/**",
          " * Adds and returns a new SELECT element using the given title as the",
          " * default element. The selection is reset to this element after each",
          " * change.",
          " *",
          " * @param title - String that specifies the title of the default element.",
          " * @param style - Optional style classname. Default is mxToolbarCombo.",
          " */"
        ]
      ],
      "addOption": [
        "addOption(combo: HTMLSelectElement, title: string, value: string): HTMLOptionElement;",
        [
          "/**",
          " * Adds and returns a new OPTION element inside the given SELECT element.",
          " * If the given value is a function then it is stored in the option's funct",
          " * field.",
          " *",
          " * @param combo - SELECT element that will contain the new entry.",
          " * @param title - String that specifies the title of the option.",
          " * @param value - Specifies the value associated with this option.",
          " */"
        ]
      ],
      "selectMode": [
        "selectMode(domNode: HTMLImageElement, funct: Function): void;",
        [
          "/**",
          " * Resets the state of the previously selected mode and displays the given",
          " * DOM node as selected. This function fires a select event with the given",
          " * function as a parameter.",
          " */"
        ]
      ],
      "resetMode": [
        "resetMode(forced: boolean): void;",
        [
          "/**",
          " * Selects the default mode and resets the state of the previously selected",
          " * mode.",
          " */"
        ]
      ],
      "addSeparator": [
        "addSeparator(icon: string): HTMLImageElement;",
        [
          "/**",
          " * Adds the specifies image as a separator.",
          " *",
          " * Parameters:",
          " *",
          " * @param icon - URL of the separator icon.",
          " */"
        ]
      ],
      "addBreak": [
        "addBreak(): void;",
        [
          "/**",
          " * Adds a break to the container.",
          " */"
        ]
      ],
      "addLine": [
        "addLine(): void;",
        [
          "/**",
          " * Adds a horizontal line to the container.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Removes the toolbar and all its associated resources.",
          " */"
        ]
      ]
    }
  ],
  "mxMouseEvent": [
    null,
    {
      "constructor": [
        "constructor(evt: Event, state?: mxCellState);",
        null
      ],
      "consumed": [
        "consumed: boolean;",
        [
          "/**",
          " * Variable: consumed",
          " *",
          " * Holds the consumed state of this event.",
          " */"
        ]
      ],
      "evt": [
        "evt: Event;",
        [
          "/**",
          " * Variable: evt",
          " *",
          " * Holds the inner event object.",
          " */"
        ]
      ],
      "graphX": [
        "graphX: number;",
        [
          "/**",
          " * Variable: graphX",
          " *",
          " * Holds the x-coordinate of the event in the graph. This value is set in",
          " * <mxGraph.fireMouseEvent>.",
          " */"
        ]
      ],
      "graphY": [
        "graphY: number;",
        [
          "/**",
          " * Variable: graphY",
          " *",
          " * Holds the y-coordinate of the event in the graph. This value is set in",
          " * <mxGraph.fireMouseEvent>.",
          " */"
        ]
      ],
      "state": [
        "state: mxCellState;",
        [
          "/**",
          " * Variable: state",
          " *",
          " * Holds the optional <mxCellState> associated with this event.",
          " */"
        ]
      ],
      "sourceState": [
        "sourceState: mxCellState;",
        [
          "/**",
          " * Variable: sourceState",
          " *",
          " * Holds the <mxCellState> that was passed to the constructor. This can be",
          " * different from <state> depending on the result of <mxGraph.getEventState>.",
          " */"
        ]
      ],
      "getEvent": [
        "getEvent(): MouseEvent;",
        [
          "/**",
          " * Function: getEvent",
          " *",
          " * Returns <evt>.",
          " */"
        ]
      ],
      "getSource": [
        "getSource(): Element;",
        [
          "/**",
          " * Function: getSource",
          " *",
          " * Returns the target DOM element using <mxEvent.getSource> for <evt>.",
          " */"
        ]
      ],
      "isSource": [
        "isSource(shape: mxShape): boolean;",
        [
          "/**",
          " * Function: isSource",
          " *",
          " * Returns true if the given <mxShape> is the source of <evt>.",
          " */"
        ]
      ],
      "getX": [
        "getX(): number;",
        [
          "/**",
          " * Function: getX",
          " *",
          " * Returns <evt.clientX>.",
          " */"
        ]
      ],
      "getY": [
        "getY(): number;",
        [
          "/**",
          " * Function: getY",
          " *",
          " * Returns <evt.clientY>.",
          " */"
        ]
      ],
      "getGraphX": [
        "getGraphX(): number;",
        [
          "/**",
          " * Function: getGraphX",
          " *",
          " * Returns <graphX>.",
          " */"
        ]
      ],
      "getGraphY": [
        "getGraphY(): number;",
        [
          "/**",
          " * Function: getGraphY",
          " *",
          " * Returns <graphY>.",
          " */"
        ]
      ],
      "getState": [
        "getState(): mxCellState;",
        [
          "/**",
          " * Function: getState",
          " *",
          " * Returns <state>.",
          " */"
        ]
      ],
      "getCell": [
        "getCell(): mxCell;",
        [
          "/**",
          " * Function: getCell",
          " *",
          " * Returns the <mxCell> in <state> is not null.",
          " */"
        ]
      ],
      "isPopupTrigger": [
        "isPopupTrigger(): boolean;",
        [
          "/**",
          " * Function: isPopupTrigger",
          " *",
          " * Returns true if the event is a popup trigger.",
          " */"
        ]
      ],
      "isConsumed": [
        "isConsumed(): boolean;",
        [
          "/**",
          " * Function: isConsumed",
          " *",
          " * Returns <consumed>.",
          " */"
        ]
      ],
      "consume": [
        "consume(preventDefault?: boolean): void;",
        [
          "/**",
          " * Function: consume",
          " *",
          " * Sets <consumed> to true and invokes preventDefault on the native event",
          " * if such a method is defined. This is used mainly to avoid the cursor from",
          " * being changed to a text cursor in Webkit. You can use the preventDefault",
          " * flag to disable this functionality.",
          " *",
          " * Parameters:",
          " *",
          " * preventDefault - Specifies if the native event should be canceled. Default",
          " * is true.",
          " */"
        ]
      ]
    }
  ],
  "mxGuide": [
    null,
    {
      "constructor": [
        "constructor(graph: mxGraph, states: Array<mxCellState | mxPoint>);",
        null
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Variable: graph",
          " *",
          " * Reference to the enclosing <mxGraph> instance.",
          " */"
        ]
      ],
      "states": [
        "states: mxCellState[];",
        [
          "/**",
          " * Variable: states",
          " *",
          " * Contains the <mxCellStates> that are used for alignment.",
          " */"
        ]
      ],
      "horizontal": [
        "horizontal: boolean;",
        [
          "/**",
          " * Variable: horizontal",
          " *",
          " * Specifies if horizontal guides are enabled. Default is true.",
          " */"
        ]
      ],
      "vertical": [
        "vertical: boolean;",
        [
          "/**",
          " * Variable: vertical",
          " *",
          " * Specifies if vertical guides are enabled. Default is true.",
          " */"
        ]
      ],
      "guideX": [
        "guideX: mxShape;",
        [
          "/**",
          " * Variable: vertical",
          " *",
          " * Holds the <mxShape> for the horizontal guide.",
          " */"
        ]
      ],
      "guideY": [
        "guideY: mxShape;",
        [
          "/**",
          " * Variable: vertical",
          " *",
          " * Holds the <mxShape> for the vertical guide.",
          " */"
        ]
      ],
      "setStates": [
        "setStates(states: mxCellState[]): void;",
        [
          "/**",
          " * Function: setStates",
          " *",
          " * Sets the <mxCellStates> that should be used for alignment.",
          " */"
        ]
      ],
      "isEnabledForEvent": [
        "isEnabledForEvent(evt: Event): boolean;",
        [
          "/**",
          " * Function: isEnabledForEvent",
          " *",
          " * Returns true if the guide should be enabled for the given native event. This",
          " * implementation always returns true.",
          " */"
        ]
      ],
      "getGuideTolerance": [
        "getGuideTolerance(): number;",
        [
          "/**",
          " * Function: getGuideTolerance",
          " *",
          " * Returns the tolerance for the guides. Default value is gridSize / 2.",
          " */"
        ]
      ],
      "createGuideShape": [
        "createGuideShape(horizontal: boolean): mxPolyline;",
        [
          "/**",
          " * Function: createGuideShape",
          " *",
          " * Returns the mxShape to be used for painting the respective guide. This",
          " * implementation returns a new, dashed and crisp <mxPolyline> using",
          " * <mxConstants.GUIDE_COLOR> and <mxConstants.GUIDE_STROKEWIDTH> as the format.",
          " *",
          " * Parameters:",
          " *",
          " * horizontal - Boolean that specifies which guide should be created.",
          " */"
        ]
      ],
      "move": [
        "move(bounds: mxRectangle, delta: mxPoint, gridEnabled: boolean, clone: boolean): mxPoint;",
        [
          "/**",
          " * Function: move",
          " *",
          " * Moves the <bounds> by the given <mxPoint> and returnt the snapped point.",
          " */"
        ]
      ],
      "getGuideColor": [
        "getGuideColor(state: mxCellState, horizontal: any): string;",
        [
          "/**",
          " * Function: hide",
          " *",
          " * Hides all current guides.",
          " */"
        ]
      ],
      "hide": [
        "hide(): void;",
        [
          "/**",
          " * Function: hide",
          " *",
          " * Hides all current guides.",
          " */"
        ]
      ],
      "setVisible": [
        "setVisible(visible: boolean): void;",
        [
          "/**",
          " * Function: setVisible",
          " *",
          " * Shows or hides the current guides.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Function: destroy",
          " *",
          " * Destroys all resources that this object uses.",
          " */"
        ]
      ],
      "isStateIgnored": [
        "isStateIgnored(state: mxCellState): boolean;",
        [
          "/**",
          " * Returns true if the given state should be ignored.",
          " * @param state",
          " */"
        ]
      ]
    }
  ],
  "mxClipboard": [
    [
      "/**",
      " * @class",
      " *",
      " * Singleton that implements a clipboard for graph cells.",
      " *",
      " * ### Example:",
      " *",
      " * @example",
      " * ```javascript",
      " * mxClipboard.copy(graph);",
      " * mxClipboard.paste(graph2);",
      " * ```",
      " *",
      " * This copies the selection cells from the graph to the clipboard and",
      " * pastes them into graph2.",
      " *",
      " * For fine-grained control of the clipboard data the {@link mxGraph.canExportCell}",
      " * and {@link mxGraph.canImportCell} functions can be overridden.",
      " *",
      " * To restore previous parents for pasted cells, the implementation for",
      " * {@link copy} and {@link paste} can be changed as follows.",
      " *",
      " * @example",
      " * ```javascript",
      " * mxClipboard.copy = function(graph, cells)",
      " * {",
      " *   cells = cells || graph.getSelectionCells();",
      " *   var result = graph.getExportableCells(cells);",
      " *",
      " *   mxClipboard.parents = new Object();",
      " *",
      " *   for (var i = 0; i < result.length; i++)",
      " *   {",
      " *     mxClipboard.parents[i] = graph.model.getParent(cells[i]);",
      " *   }",
      " *",
      " *   mxClipboard.insertCount = 1;",
      " *   mxClipboard.setCells(graph.cloneCells(result));",
      " *",
      " *   return result;",
      " * };",
      " *",
      " * mxClipboard.paste = function(graph)",
      " * {",
      " *   if (!mxClipboard.isEmpty())",
      " *   {",
      " *     var cells = graph.getImportableCells(mxClipboard.getCells());",
      " *     var delta = mxClipboard.insertCount * mxClipboard.STEPSIZE;",
      " *     var parent = graph.getDefaultParent();",
      " *",
      " *     graph.model.beginUpdate();",
      " *     try",
      " *     {",
      " *       for (var i = 0; i < cells.length; i++)",
      " *       {",
      " *         var tmp = (mxClipboard.parents != null && graph.model.contains(mxClipboard.parents[i])) ?",
      " *              mxClipboard.parents[i] : parent;",
      " *         cells[i] = graph.importCells([cells[i]], delta, delta, tmp)[0];",
      " *       }",
      " *     }",
      " *     finally",
      " *     {",
      " *       graph.model.endUpdate();",
      " *     }",
      " *",
      " *     // Increments the counter and selects the inserted cells",
      " *     mxClipboard.insertCount++;",
      " *     graph.setSelectionCells(cells);",
      " *   }",
      " * };",
      " * ```",
      " */"
    ],
    {
      "static STEPSIZE": [
        "static STEPSIZE: number;",
        [
          "/**",
          " * Defines the step size to offset the cells after each paste operation.",
          " * Default is 10.",
          " */"
        ]
      ],
      "static insertCount": [
        "static insertCount: number;",
        [
          "/**",
          " * Counts the number of times the clipboard data has been inserted.",
          " */"
        ]
      ],
      "static cells": [
        "static cells: Array<mxCell>;",
        [
          "/**",
          " * Holds the array of {@link mxCell} currently in the clipboard.",
          " */"
        ]
      ],
      "static setCells": [
        "static setCells(cells: Array<mxCell>): void;",
        [
          "/**",
          " * Sets the cells in the clipboard. Fires a {@link mxEvent.CHANGE} event.",
          " */"
        ]
      ],
      "static getCells": [
        "static getCells(): Array<mxCell>;",
        [
          "/**",
          " * Returns  the cells in the clipboard.",
          " */"
        ]
      ],
      "static isEmpty": [
        "static isEmpty(): boolean;",
        [
          "/**",
          " * Returns true if the clipboard currently has not data stored.",
          " */"
        ]
      ],
      "static cut": [
        "static cut(graph: mxGraph, cells?: Array<mxCell>): Array<mxCell>;",
        [
          "/**",
          " * Cuts the given array of {@link mxCell} from the specified graph.",
          " * If cells is null then the selection cells of the graph will",
          " * be used. Returns the cells that have been cut from the graph.",
          " *",
          " * @param graph - {@link mxGraph} that contains the cells to be cut.",
          " * @param cells - Optional array of {@link mxCell} to be cut.",
          " */"
        ]
      ],
      "static removeCells": [
        "static removeCells(graph: mxGraph, cells: Array<mxCell>): void;",
        [
          "/**",
          " * Hook to remove the given cells from the given graph after",
          " * a cut operation.",
          " *",
          " * @param graph - {@link mxGraph} that contains the cells to be cut.",
          " * @param cells - Array of {@link mxCell} to be cut.",
          " */"
        ]
      ],
      "static copy": [
        "static copy(graph: mxGraph, cells?: Array<mxCell>): Array<mxCell>;",
        [
          "/**",
          " * Copies the given array of {@link mxCell} from the specified",
          " * graph to {@link cells}. Returns the original array of cells that has",
          " * been cloned. Descendants of cells in the array are ignored.",
          " *",
          " * @param graph - {@link mxGraph} that contains the cells to be copied.",
          " * @param cells - Optional array of {@link mxCell} to be copied.",
          " */"
        ]
      ],
      "static paste": [
        "static paste(graph: mxGraph): Array<mxCell>;",
        [
          "/**",
          " * Pastes the {@link cells} into the specified graph restoring",
          " * the relation to {@link parents}, if possible. If the parents",
          " * are no longer in the graph or invisible then the",
          " * cells are added to the graph's default or into the",
          " * swimlane under the cell's new location if one exists.",
          " * The cells are added to the graph using {@link mxGraph.importCells}",
          " * and returned.",
          " *",
          " * @param graph - {@link mxGraph} to paste the {@link cells} into.",
          " */"
        ]
      ]
    }
  ],
  "mxXmlRequest": [
    [
      "/**",
      " * XML HTTP request wrapper. See also: {@link mxUtils.get}, {@link mxUtils.post} and",
      " * {@link mxUtils.load}. This class provides a cross-browser abstraction for Ajax",
      " * requests.",
      " *",
      " * ### Encoding:",
      " *",
      " * For encoding parameter values, the built-in encodeURIComponent JavaScript",
      " * method must be used. For automatic encoding of post data in {@link mxEditor} the",
      " * {@link mxEditor.escapePostData} switch can be set to true (default). The encoding",
      " * will be carried out using the conte type of the page. That is, the page",
      " * containting the editor should contain a meta tag in the header, eg.",
      " * <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">",
      " *",
      " * @example",
      " * ```JavaScript",
      " * var onload = function(req)",
      " * {",
      " *   mxUtils.alert(req.getDocumentElement());",
      " * }",
      " *",
      " * var onerror = function(req)",
      " * {",
      " *   mxUtils.alert('Error');",
      " * }",
      " * new mxXmlRequest(url, 'key=value').send(onload, onerror);",
      " * ```",
      " *",
      " * Sends an asynchronous POST request to the specified URL.",
      " *",
      " * @example",
      " * ```JavaScript",
      " * var req = new mxXmlRequest(url, 'key=value', 'POST', false);",
      " * req.send();",
      " * mxUtils.alert(req.getDocumentElement());",
      " * ```",
      " *",
      " * Sends a synchronous POST request to the specified URL.",
      " *",
      " * @example",
      " * ```JavaScript",
      " * var encoder = new mxCodec();",
      " * var result = encoder.encode(graph.getModel());",
      " * var xml = encodeURIComponent(mxUtils.getXml(result));",
      " * new mxXmlRequest(url, 'xml='+xml).send();",
      " * ```",
      " *",
      " * Sends an encoded graph model to the specified URL using xml as the",
      " * parameter name. The parameter can then be retrieved in C# as follows:",
      " *",
      " * (code)",
      " * string xml = HttpUtility.UrlDecode(context.Request.Params[\"xml\"]);",
      " * (end)",
      " *",
      " * Or in Java as follows:",
      " *",
      " * (code)",
      " * String xml = URLDecoder.decode(request.getParameter(\"xml\"), \"UTF-8\").replace(\"\\n\", \"&#xa;\");",
      " * (end)",
      " *",
      " * Note that the linefeeds should only be replaced if the XML is",
      " * processed in Java, for example when creating an image.",
      " */"
    ],
    {
      "constructor": [
        "constructor(url: string, params: any, method: 'POST' | 'GET', async: boolean, username: string, password: string);",
        [
          "/**",
          " * Constructs an XML HTTP request.",
          " * @param url Target URL of the request.",
          " * @param params Form encoded parameters to send with a POST request.",
          " *",
          " * @param method String that specifies the request method. Possible values are POST and GET. Default is POST.",
          " * @default 'POST'",
          " *",
          " * @param async Boolean specifying if an asynchronous request should be used. Default is true.",
          " * @default true",
          " *",
          " * @param username String specifying the username to be used for the request.",
          " * @param password String specifying the password to be used for the request.",
          " */"
        ]
      ],
      "binary": [
        "binary: boolean;",
        [
          "/**",
          " * Boolean indicating if the request is binary. This option is ignored in IE.",
          " * In all other browsers the requested mime type is set to",
          " * text/plain; charset=x-user-defined. Default is false.",
          " *",
          " * @default false",
          " */"
        ]
      ],
      "withCredentials": [
        "withCredentials: boolean;",
        [
          "/**",
          " * Specifies if withCredentials should be used in HTML5-compliant browsers. Default is false.",
          " *",
          " * @default false",
          " */"
        ]
      ],
      "request": [
        "request: any;",
        [
          "/**",
          " * Holds the inner, browser-specific request object.",
          " */"
        ]
      ],
      "decodeSimulateValues": [
        "decodeSimulateValues: boolean;",
        [
          "/**",
          " * Specifies if request values should be decoded as URIs before setting the",
          " * textarea value in {@link simulate}. Defaults to false for backwards compatibility,",
          " * to avoid another decode on the server this should be set to true.",
          " */"
        ]
      ],
      "isBinary": [
        "isBinary(): boolean;",
        [
          "/**",
          " * Returns {@link binary}.",
          " */"
        ]
      ],
      "setBinary": [
        "setBinary(value: boolean): void;",
        [
          "/**",
          " * Sets {@link binary}.",
          " *",
          " * @param value",
          " */"
        ]
      ],
      "getText": [
        "getText(): string;",
        [
          "/**",
          " * Returns the response as a string.",
          " */"
        ]
      ],
      "isReady": [
        "isReady(): boolean;",
        [
          "/**",
          " * Returns true if the response is ready.",
          " */"
        ]
      ],
      "getDocumentElement": [
        "getDocumentElement(): XMLDocument;",
        [
          "/**",
          " * Returns the document element of the response XML document.",
          " */"
        ]
      ],
      "getXml": [
        "getXml(): XMLDocument;",
        [
          "/**",
          " * Returns the response as an XML document. Use {@link getDocumentElement} to get",
          " * the document element of the XML document.",
          " */"
        ]
      ],
      "getStatus": [
        "getStatus(): number;",
        [
          "/**",
          " * Returns the status as a number, eg. 404 for \"Not found\" or 200 for \"OK\".",
          " * Note: The NS_ERROR_NOT_AVAILABLE for invalid responses cannot be cought.",
          " */"
        ]
      ],
      "create": [
        "create(): any;",
        [
          "/**",
          " * Creates and returns the inner {@link request} object.",
          " */"
        ]
      ],
      "send": [
        "send(onload: Function, onerror: Function, timeout?: number, ontimeout?: Function): void;",
        [
          "/**",
          " * Send the <request> to the target URL using the specified functions to",
          " * process the response asychronously.",
          " *",
          " * Note: Due to technical limitations, onerror is currently ignored.",
          " *",
          " * @param onload Function to be invoked if a successful response was received.",
          " * @param onerror Function to be called on any error. Unused in this implementation, intended for overriden function.",
          " * @param timeout Optional timeout in ms before calling ontimeout.",
          " * @param ontimeout Optional function to execute on timeout.",
          " */"
        ]
      ],
      "setRequestHeaders": [
        "setRequestHeaders(request: any, params: any): void;",
        [
          "/**",
          " * Sets the headers for the given request and parameters. This sets the",
          " * content-type to application/x-www-form-urlencoded if any params exist.",
          " *",
          " * @example",
          " * ```JavaScript",
          " * request.setRequestHeaders = function(request, params)",
          " * {",
          " *   if (params != null)",
          " *   {",
          " *     request.setRequestHeader('Content-Type',",
          " *             'multipart/form-data');",
          " *     request.setRequestHeader('Content-Length',",
          " *             params.length);",
          " *   }",
          " * };",
          " * ```",
          " *",
          " * Use the code above before calling {@link send} if you require a",
          " * multipart/form-data request.",
          " *",
          " * @param request",
          " * @param params",
          " */"
        ]
      ],
      "simulate": [
        "simulate(doc: any, target: any): void;",
        [
          "/**",
          " * Creates and posts a request to the given target URL using a dynamically",
          " * created form inside the given document.",
          " *",
          " * @param doc Document that contains the form element.",
          " * @param target Target to send the form result to.",
          " */"
        ]
      ]
    }
  ],
  "mxMorphing": [
    null,
    {
      "steps": [
        "steps: number;",
        null
      ],
      "step": [
        "step: number;",
        null
      ],
      "ease": [
        "ease: number;",
        null
      ],
      "delay": [
        "delay: number;",
        null
      ],
      "constructor": [
        "constructor(graph: mxGraph, steps?: number, ease?: number, delay?: number);",
        null
      ],
      "startAnimation": [
        "startAnimation(): void;",
        null
      ],
      "updateAnimation": [
        "updateAnimation(): void;",
        null
      ],
      "show": [
        "show(move: any): void;",
        null
      ],
      "animateCell": [
        "animateCell(cell: mxCell, move: any, recurse: any): void;",
        null
      ],
      "stopRecursion": [
        "stopRecursion(state: any, delta: any): boolean;",
        null
      ],
      "getDelta": [
        "getDelta(state: any): any;",
        null
      ],
      "getOriginForCell": [
        "getOriginForCell(cell: mxCell): any;",
        null
      ]
    }
  ],
  "mxXmlCanvas2D": [
    null,
    {
      "constructor": [
        "constructor(root: Element);",
        null
      ],
      "root": [
        "root: Element;",
        [
          "/**",
          " * Reference to the container for the SVG content.",
          " */"
        ]
      ],
      "textEnabled": [
        "textEnabled: boolean;",
        [
          "/**",
          " * Specifies if text output should be enabled.",
          " * @default true",
          " */"
        ]
      ],
      "compressed": [
        "compressed: boolean;",
        [
          "/**",
          " * Specifies if the output should be compressed by removing redundant calls.",
          " * @default true",
          " */"
        ]
      ],
      "writeDefaults": [
        "writeDefaults(): void;",
        [
          "/**",
          " * Writes the rendering defaults to {@link root}:",
          " */"
        ]
      ],
      "format": [
        "format(value: string): number;",
        [
          "/**",
          " * Returns a formatted number with 2 decimal places.",
          " */"
        ]
      ],
      "createElement": [
        "createElement(name: string): Element;",
        [
          "/**",
          " * Creates the given element using the owner document of {@link root}.",
          " */"
        ]
      ],
      "save": [
        "save(): void;",
        [
          "/**",
          " * Saves the drawing state.",
          " */"
        ]
      ],
      "restore": [
        "restore(): void;",
        [
          "/**",
          " * Restores the drawing state.",
          " */"
        ]
      ],
      "scale": [
        "scale(value: number): void;",
        [
          "/**",
          " * Scales the output.",
          " *",
          " * @param scale Number that represents the scale where 1 is equal to 100%.",
          " */"
        ]
      ],
      "translate": [
        "translate(dx: number, dy: number): void;",
        [
          "/**",
          " * Translates the output.",
          " *",
          " * @param dx Number that specifies the horizontal translation.",
          " * @param dy Number that specifies the vertical translation.",
          " */"
        ]
      ],
      "rotate": [
        "rotate(theta: number, flipH: boolean, flipV: boolean, cx: number, cy: number): void;",
        [
          "/**",
          " * Rotates and/or flips the output around a given center. (Note: Due to",
          " * limitations in VML, the rotation cannot be concatenated.)",
          " *",
          " * @param theta Number that represents the angle of the rotation (in degrees).",
          " * @param flipH Boolean indicating if the output should be flipped horizontally.",
          " * @param flipV Boolean indicating if the output should be flipped vertically.",
          " * @param cx Number that represents the x-coordinate of the rotation center.",
          " * @param cy Number that represents the y-coordinate of the rotation center.",
          " */"
        ]
      ],
      "setAlpha": [
        "setAlpha(value: number): void;",
        [
          "/**",
          " * Sets the current alpha.",
          " *",
          " * @param value Number that represents the new alpha. Possible values are between",
          " * 1 (opaque) and 0 (transparent).",
          " */"
        ]
      ],
      "setFillAlpha": [
        "setFillAlpha(value: number): void;",
        [
          "/**",
          " * Sets the current fill alpha.",
          " *",
          " * @param value Number that represents the new fill alpha. Possible values are between",
          " * 1 (opaque) and 0 (transparent).",
          " */"
        ]
      ],
      "setStrokeAlpha": [
        "setStrokeAlpha(value: number): void;",
        [
          "/**",
          " * Sets the current stroke alpha.",
          " *",
          " * @param value Number that represents the new stroke alpha. Possible values are between",
          " * 1 (opaque) and 0 (transparent).",
          " */"
        ]
      ],
      "setFillColor": [
        "setFillColor(value: string): void;",
        [
          "/**",
          " * Sets the current fill color.",
          " *",
          " * @param value Hexadecimal representation of the color or 'none'.",
          " */"
        ]
      ],
      ")": [
        "): void;",
        [
          "/**",
          " * Paints the given text. Possible values for format are empty string for",
          " * plain text and html for HTML markup. Background and border color as well",
          " * as clipping is not available in plain text labels for VML. HTML labels",
          " * are not available as part of shapes with no foreignObject support in SVG",
          " * (eg. IE9, IE10).",
          " *",
          " * @param x Number that represents the x-coordinate of the text.",
          " * @param y Number that represents the y-coordinate of the text.",
          " * @param w Number that represents the available width for the text or 0 for automatic width.",
          " * @param h Number that represents the available height for the text or 0 for automatic height.",
          " * @param str String that specifies the text to be painted.",
          " * @param align String that represents the horizontal alignment.",
          " * @param valign String that represents the vertical alignment.",
          " * @param wrap Boolean that specifies if word-wrapping is enabled. Requires w > 0.",
          " * @param format Empty string for plain text or 'html' for HTML markup.",
          " * @param overflow Specifies the overflow behaviour of the label. Requires w > 0 and/or h > 0.",
          " * @param clip Boolean that specifies if the label should be clipped. Requires w > 0 and/or h > 0.",
          " * @param rotation Number that specifies the angle of the rotation around the anchor point of the text.",
          " * @param dir Optional string that specifies the text direction. Possible values are rtl and lrt.",
          " */"
        ]
      ],
      "setStrokeColor": [
        "setStrokeColor(value: string): void;",
        [
          "/**",
          " * Sets the current stroke color.",
          " *",
          " * @param value Hexadecimal representation of the color or 'none'.",
          " */"
        ]
      ],
      "setStrokeWidth": [
        "setStrokeWidth(value: number): void;",
        [
          "/**",
          " * Sets the current stroke width.",
          " *",
          " * @param value Numeric representation of the stroke width.",
          " */"
        ]
      ],
      "setDashed": [
        "setDashed(value: boolean, fixDash: boolean): void;",
        [
          "/**",
          " * Enables or disables dashed lines.",
          " *",
          " * @param value Boolean that specifies if dashed lines should be enabled.",
          " * @param value Boolean that specifies if the stroke width should be ignored",
          " * for the dash pattern.",
          " * @default false",
          " */"
        ]
      ],
      "setDashPattern": [
        "setDashPattern(value: string): void;",
        [
          "/**",
          " * Sets the current dash pattern.",
          " * @default '3 3'",
          " *",
          " * @param value String that represents the dash pattern, which is a sequence of",
          " * numbers defining the length of the dashes and the length of the spaces",
          " * between the dashes. The lengths are relative to the line width - a length",
          " * of 1 is equals to the line width.",
          " */"
        ]
      ],
      "setLineCap": [
        "setLineCap(value: string): void;",
        [
          "/**",
          " * Sets the line cap.",
          " * @default 'flat' which corresponds to 'butt' in SVG",
          " *",
          " * @param value String that represents the line cap. Possible values are flat, round",
          " * and square.",
          " */"
        ]
      ],
      "setLineJoin": [
        "setLineJoin(value: string): void;",
        [
          "/**",
          " * Sets the line join.",
          " * @default 'miter'",
          " *",
          " * @param value String that represents the line join. Possible values are miter,",
          " * round and bevel.",
          " */"
        ]
      ],
      "setMiterLimit": [
        "setMiterLimit(value: number): void;",
        [
          "/**",
          " * Sets the miter limit.",
          " * @default 10",
          " *",
          " * @param value Number that represents the miter limit.",
          " */"
        ]
      ],
      "setFontColor": [
        "setFontColor(value: string): void;",
        [
          "/**",
          " * Sets the current font color.",
          " * @default '#000000'",
          " *",
          " * @param value Hexadecimal representation of the color or 'none'.",
          " */"
        ]
      ],
      "setFontBackgroundColor": [
        "setFontBackgroundColor(value: string): void;",
        [
          "/**",
          " * Sets the current font background color.",
          " *",
          " * @param value Hexadecimal representation of the color or 'none'.",
          " */"
        ]
      ],
      "setFontBorderColor": [
        "setFontBorderColor(value: string): void;",
        [
          "/**",
          " * Sets the current font border color.",
          " *",
          " * @param value Hexadecimal representation of the color or 'none'.",
          " */"
        ]
      ],
      "setFontSize": [
        "setFontSize(value: number): void;",
        [
          "/**",
          " * Sets the current font size.",
          " * @default {@link mxConstants.DEFAULT_FONTSIZE}",
          " *",
          " * @param value Numeric representation of the font size.",
          " */"
        ]
      ],
      "setFontFamily": [
        "setFontFamily(value: string): void;",
        [
          "/**",
          " * Sets the current font family.",
          " * @default {@link mxConstants.DEFAULT_FONTFAMILY}",
          " *",
          " * @param value String representation of the font family. This handles the same",
          " * values as the CSS font-family property.",
          " */"
        ]
      ],
      "setFontStyle": [
        "setFontStyle(value: string): void;",
        [
          "/**",
          " * Sets the current font style.",
          " *",
          " * @param value Numeric representation of the font family. This is the sum of the",
          " * font styles from {@link mxConstants}.",
          " */"
        ]
      ],
      "setShadow": [
        "setShadow(value: boolean): void;",
        [
          "/**",
          " * Enables or disables shadows.",
          " *",
          " * @param value Boolean that specifies if shadows should be enabled.",
          " */"
        ]
      ],
      "setShadowColor": [
        "setShadowColor(value: string): void;",
        [
          "/**",
          " * Sets the current shadow color. Default {@link mxConstants.SHADOWCOLOR}",
          " *",
          " *",
          " * @param value Hexadecimal representation of the color or 'none'.",
          " */"
        ]
      ],
      "setShadowAlpha": [
        "setShadowAlpha(value: number): void;",
        [
          "/**",
          " * Sets the current shadows alpha. Default is {@link mxConstants.SHADOW_OPACITY}",
          " *",
          " * @param value Number that represents the new alpha. Possible values are between 1 (opaque) and 0 (transparent).",
          " */"
        ]
      ],
      "setShadowOffset": [
        "setShadowOffset(dx: number, dy: number): void;",
        [
          "/**",
          " * Sets the current shadow offset.",
          " *",
          " * @param dx Number that represents the horizontal offset of the shadow.",
          " * @param dy Number that represents the vertical offset of the shadow.",
          " */"
        ]
      ],
      "rect": [
        "rect(x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Puts a rectangle into the drawing buffer.",
          " *",
          " * @param x Number that represents the x-coordinate of the rectangle.",
          " * @param y Number that represents the y-coordinate of the rectangle.",
          " * @param w Number that represents the width of the rectangle.",
          " * @param h Number that represents the height of the rectangle.",
          " */"
        ]
      ],
      "roundrect": [
        "roundrect(x: number, y: number, w: number, h: number, dx: number, dy: number): void;",
        [
          "/**",
          " * Puts a rounded rectangle into the drawing buffer.",
          " *",
          " * @param x Number that represents the x-coordinate of the rectangle.",
          " * @param y Number that represents the y-coordinate of the rectangle.",
          " * @param w Number that represents the width of the rectangle.",
          " * @param h Number that represents the height of the rectangle.",
          " * @param dx Number that represents the horizontal rounding.",
          " * @param dy Number that represents the vertical rounding.",
          " */"
        ]
      ],
      "ellipse": [
        "ellipse(x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Puts an ellipse into the drawing buffer.",
          " *",
          " * @param x Number that represents the x-coordinate of the ellipse.",
          " * @param y Number that represents the y-coordinate of the ellipse.",
          " * @param w Number that represents the width of the ellipse.",
          " * @param h Number that represents the height of the ellipse.",
          " */"
        ]
      ],
      "begin": [
        "begin(): void;",
        [
          "/**",
          " * Starts a new path and puts it into the drawing buffer.",
          " */"
        ]
      ],
      "moveTo": [
        "moveTo(x: number, y: number): void;",
        [
          "/**",
          " * Moves the current path the given point.",
          " *",
          " * @param x Number that represents the x-coordinate of the point.",
          " * @param y Number that represents the y-coordinate of the point.",
          " */"
        ]
      ],
      "lineTo": [
        "lineTo(x: number, y: number): void;",
        [
          "/**",
          " * Draws a line to the given coordinates.",
          " *",
          " * @param x Number that represents the x-coordinate of the endpoint.",
          " * @param y Number that represents the y-coordinate of the endpoint.",
          " */"
        ]
      ],
      "quadTo": [
        "quadTo(x1: number, y1: number, x2: number, y2: number): void;",
        [
          "/**",
          " * Adds a quadratic curve to the current path.",
          " *",
          " * @param x1 Number that represents the x-coordinate of the control point.",
          " * @param y1 Number that represents the y-coordinate of the control point.",
          " * @param x2 Number that represents the x-coordinate of the endpoint.",
          " * @param y2 Number that represents the y-coordinate of the endpoint.",
          " */"
        ]
      ],
      "curveTo": [
        "curveTo(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): void;",
        [
          "/**",
          " * Adds a bezier curve to the current path.",
          " *",
          " * @param x1 Number that represents the x-coordinate of the first control point.",
          " * @param y1 Number that represents the y-coordinate of the first control point.",
          " * @param x2 Number that represents the x-coordinate of the second control point.",
          " * @param y2 Number that represents the y-coordinate of the second control point.",
          " * @param x3 Number that represents the x-coordinate of the endpoint.",
          " * @param y3 Number that represents the y-coordinate of the endpoint.",
          " */"
        ]
      ],
      "close": [
        "close(): void;",
        [
          "/**",
          " * Closes the current path.",
          " */"
        ]
      ],
      "stroke": [
        "stroke(): void;",
        [
          "/**",
          " * Paints the outline of the current drawing buffer.",
          " */"
        ]
      ],
      "fill": [
        "fill(): void;",
        [
          "/**",
          " * Fills the current drawing buffer.",
          " */"
        ]
      ],
      "fillAndStroke": [
        "fillAndStroke(): void;",
        [
          "/**",
          " * Fills the current drawing buffer and its outline.",
          " */"
        ]
      ]
    }
  ],
  "mxImageBundle": [
    null,
    {
      "constructor": [
        "constructor(alt: boolean);",
        null
      ],
      "images": [
        "images: { [key: string]: { value: string; fallback: Function } };",
        [
          "/**",
          " * Variable: images",
          " *",
          " * Maps from keys to images.",
          " */"
        ]
      ],
      "alt": [
        "alt: boolean;",
        [
          "/**",
          " * Variable: alt",
          " *",
          " * Specifies if the fallback representation should be returned.",
          " */"
        ]
      ],
      "putImage": [
        "putImage(key: string, value: string, fallback: Function): void;",
        [
          "/**",
          " * Function: putImage",
          " *",
          " * Adds the specified entry to the map. The entry is an object with a value and",
          " * fallback property as specified in the arguments.",
          " */"
        ]
      ],
      "getImage": [
        "getImage(key: string): string;",
        [
          "/**",
          " * Function: getImage",
          " *",
          " * Returns the value for the given key. This returns the value",
          " * or fallback, depending on <alt>. The fallback is returned if",
          " * <alt> is true, the value is returned otherwise.",
          " */"
        ]
      ]
    }
  ],
  "mxEvent": [
    [
      "/**",
      " * @class mxEvent",
      " *",
      " * Cross-browser DOM event support. For internal event handling,",
      " * {@link mxEventSource} and the graph event dispatch loop in {@link mxGraph} are used.",
      " *",
      " * ### Memory Leaks:",
      " *",
      " * Use this class for adding and removing listeners to/from DOM nodes. The",
      " * {@link removeAllListeners} function is provided to remove all listeners that",
      " * have been added using {@link addListener}. The function should be invoked when",
      " * the last reference is removed in the JavaScript code, typically when the",
      " * referenced DOM node is removed from the DOM.",
      " */"
    ],
    {
      "static addListener": [
        "static addListener(element: Node | Window, eventName: string, funct: Function): void;",
        [
          "/**",
          " * Binds the function to the specified event on the given element. Use",
          " * {@link mxUtils.bind} in order to bind the \"this\" keyword inside the function",
          " * to a given execution scope.",
          " */"
        ]
      ],
      "static removeListener": [
        "static removeListener(element: Node | Window, eventName: string, funct: Function): void;",
        [
          "/**",
          " * Removes the specified listener from the given element.",
          " */"
        ]
      ],
      "static removeAllListeners": [
        "static removeAllListeners(element: Node | Window): void;",
        [
          "/**",
          " * Removes all listeners from the given element.",
          " */"
        ]
      ],
      ")": [
        "): void;",
        [
          "/**",
          " * Redirects the mouse events from the given DOM node to the graph dispatch",
          " * loop using the event and given state as event arguments. State can",
          " * either be an instance of {@link mxCellState} or a function that returns an",
          " * {@link mxCellState}. The down, move, up and dblClick arguments are optional",
          " * functions that take the trigger event as arguments and replace the",
          " * default behaviour.",
          " */"
        ]
      ],
      "static release": [
        "static release(element: Node | Window): void;",
        [
          "/**",
          " * Removes the known listeners from the given DOM node and its descendants.",
          " *",
          " * @param element DOM node to remove the listeners from.",
          " */"
        ]
      ],
      "static addMouseWheelListener": [
        "static addMouseWheelListener(funct: (event: Event, up: boolean) => void, target?: Node | Window): void;",
        [
          "/**",
          " * Installs the given function as a handler for mouse wheel events. The",
          " * function has two arguments: the mouse event and a boolean that specifies",
          " * if the wheel was moved up or down.",
          " *",
          " * This has been tested with IE 6 and 7, Firefox (all versions), Opera and",
          " * Safari. It does currently not work on Safari for Mac.",
          " *",
          " * ### Example",
          " *",
          " * @example",
          " * ```javascript",
          " * mxEvent.addMouseWheelListener(function (evt, up)",
          " * {",
          " *   mxLog.show();",
          " *   mxLog.debug('mouseWheel: up='+up);",
          " * });",
          " * ```",
          " *",
          " * @param funct Handler function that takes the event argument and a boolean up",
          " * argument for the mousewheel direction.",
          " * @param target Target for installing the listener in Google Chrome. See",
          " * https://www.chromestatus.com/features/6662647093133312.",
          " */"
        ]
      ],
      "static disableContextMenu": [
        "static disableContextMenu(element: Node): void;",
        [
          "/**",
          " * Disables the context menu for the given element.",
          " */"
        ]
      ],
      "static getSource<T extends EventTarget = any>": [
        "static getSource<T extends EventTarget = any>(evt: Event): T;",
        [
          "/**",
          " * Returns the event's target or srcElement depending on the browser.",
          " */"
        ]
      ],
      "static isConsumed": [
        "static isConsumed(evt: mxEventObject | mxMouseEvent | Event): boolean;",
        [
          "/**",
          " * Returns true if the event has been consumed using {@link consume}.",
          " */"
        ]
      ],
      "static isTouchEvent": [
        "static isTouchEvent(evt: Event): boolean;",
        [
          "/**",
          " * Returns true if the event was generated using a touch device (not a pen or mouse).",
          " */"
        ]
      ],
      "static isPenEvent": [
        "static isPenEvent(evt: Event): boolean;",
        [
          "/**",
          " * Returns true if the event was generated using a pen (not a touch device or mouse).",
          " */"
        ]
      ],
      "static isMultiTouchEvent": [
        "static isMultiTouchEvent(evt: Event): boolean;",
        [
          "/**",
          " * Returns true if the event was generated using a touch device (not a pen or mouse).",
          " */"
        ]
      ],
      "static isMouseEvent": [
        "static isMouseEvent(evt: Event): boolean;",
        [
          "/**",
          " * Returns true if the event was generated using a mouse (not a pen or touch device).",
          " */"
        ]
      ],
      "static isLeftMouseButton": [
        "static isLeftMouseButton(evt: MouseEvent): boolean;",
        [
          "/**",
          " * Returns true if the left mouse button is pressed for the given event.",
          " * To check if a button is pressed during a mouseMove you should use the",
          " * {@link mxGraph.isMouseDown} property. Note that this returns true in Firefox",
          " * for control+left-click on the Mac.",
          " */"
        ]
      ],
      "static isMiddleMouseButton": [
        "static isMiddleMouseButton(evt: MouseEvent): boolean;",
        [
          "/**",
          " * Returns true if the middle mouse button is pressed for the given event.",
          " * To check if a button is pressed during a mouseMove you should use the",
          " * {@link mxGraph.isMouseDown} property.",
          " */"
        ]
      ],
      "static isRightMouseButton": [
        "static isRightMouseButton(evt: MouseEvent): boolean;",
        [
          "/**",
          " * Returns true if the right mouse button was pressed. Note that this",
          " * button might not be available on some systems. For handling a popup",
          " * trigger {@link isPopupTrigger} should be used.",
          " */"
        ]
      ],
      "static isPopupTrigger": [
        "static isPopupTrigger(evt: Event): boolean;",
        [
          "/**",
          " * Returns true if the event is a popup trigger. This implementation",
          " * returns true if the right button or the left button and control was",
          " * pressed on a Mac.",
          " */"
        ]
      ],
      "static isShiftDown": [
        "static isShiftDown(evt: MouseEvent): boolean;",
        [
          "/**",
          " * Returns true if the shift key is pressed for the given event.",
          " */"
        ]
      ],
      "static isAltDown": [
        "static isAltDown(evt: MouseEvent): boolean;",
        [
          "/**",
          " * Returns true if the alt key is pressed for the given event.",
          " */"
        ]
      ],
      "static isControlDown": [
        "static isControlDown(evt: MouseEvent): boolean;",
        [
          "/**",
          " * Returns true if the control key is pressed for the given event.",
          " */"
        ]
      ],
      "static isMetaDown": [
        "static isMetaDown(evt: MouseEvent): boolean;",
        [
          "/**",
          " * Returns true if the meta key is pressed for the given event.",
          " */"
        ]
      ],
      "static getMainEvent": [
        "static getMainEvent(e: MouseEvent): MouseEvent;",
        [
          "/**",
          " * Returns the touch or mouse event that contains the mouse coordinates.",
          " */"
        ]
      ],
      "static getClientX": [
        "static getClientX(e: TouchEvent | MouseEvent): number;",
        [
          "/**",
          " * Returns true if the meta key is pressed for the given event.",
          " */"
        ]
      ],
      "static getClientY": [
        "static getClientY(e: TouchEvent | MouseEvent): number;",
        [
          "/**",
          " * Returns true if the meta key is pressed for the given event.",
          " */"
        ]
      ],
      "static consume": [
        "static consume(evt: Event, preventDefault?: boolean, stopPropagation?: boolean): void;",
        [
          "/**",
          " * Consumes the given event.",
          " *",
          " * @param evt Native event to be consumed.",
          " * @param preventDefault Optional boolean to prevent the default for the event.",
          " * Default is true.",
          " * @param stopPropagation Option boolean to stop event propagation. Default is",
          " * true.",
          " */"
        ]
      ],
      "static LABEL_HANDLE": [
        "static LABEL_HANDLE: -1;",
        [
          "/**",
          " * Index for the label handle in an mxMouseEvent. This should be a negative",
          " * value that does not interfere with any possible handle indices.",
          " * @default -1",
          " */"
        ]
      ],
      "static ROTATION_HANDLE": [
        "static ROTATION_HANDLE: -2;",
        [
          "/**",
          " * Index for the rotation handle in an mxMouseEvent. This should be a",
          " * negative value that does not interfere with any possible handle indices.",
          " * @default -2",
          " */"
        ]
      ],
      "static CUSTOM_HANDLE": [
        "static CUSTOM_HANDLE: -100;",
        [
          "/**",
          " * Start index for the custom handles in an mxMouseEvent. This should be a",
          " * negative value and is the start index which is decremented for each",
          " * custom handle.",
          " * @default -100",
          " */"
        ]
      ],
      "static VIRTUAL_HANDLE": [
        "static VIRTUAL_HANDLE: -100000;",
        [
          "/**",
          " * Start index for the virtual handles in an mxMouseEvent. This should be a",
          " * negative value and is the start index which is decremented for each",
          " * virtual handle.",
          " * This assumes that there are no more",
          " * than VIRTUAL_HANDLE - CUSTOM_HANDLE custom handles.",
          " *",
          " * @default -100000",
          " */"
        ]
      ],
      "static MOUSE_DOWN": [
        "static MOUSE_DOWN: 'mouseDown';",
        [
          "/**",
          " * Specifies the event name for mouseDown.",
          " */"
        ]
      ],
      "static MOUSE_MOVE": [
        "static MOUSE_MOVE: 'mouseMove';",
        [
          "/**",
          " * Specifies the event name for mouseMove.",
          " */"
        ]
      ],
      "static MOUSE_UP": [
        "static MOUSE_UP: 'mouseUp';",
        [
          "/**",
          " * Specifies the event name for mouseUp.",
          " */"
        ]
      ],
      "static ACTIVATE": [
        "static ACTIVATE: 'activate';",
        [
          "/**",
          " * Specifies the event name for activate.",
          " */"
        ]
      ],
      "static RESIZE_START": [
        "static RESIZE_START: 'resizeStart';",
        [
          "/**",
          " * Specifies the event name for resizeStart.",
          " */"
        ]
      ],
      "static RESIZE": [
        "static RESIZE: 'resize';",
        [
          "/**",
          " * Specifies the event name for resize.",
          " */"
        ]
      ],
      "static RESIZE_END": [
        "static RESIZE_END: 'resizeEnd';",
        [
          "/**",
          " * Specifies the event name for resizeEnd.",
          " */"
        ]
      ],
      "static MOVE_START": [
        "static MOVE_START: 'moveStart';",
        [
          "/**",
          " * Specifies the event name for moveStart.",
          " */"
        ]
      ],
      "static MOVE": [
        "static MOVE: 'move';",
        [
          "/**",
          " * Specifies the event name for move.",
          " */"
        ]
      ],
      "static MOVE_END": [
        "static MOVE_END: 'moveEnd';",
        [
          "/**",
          " * Specifies the event name for moveEnd.",
          " */"
        ]
      ],
      "static PAN_START": [
        "static PAN_START: 'panStart';",
        [
          "/**",
          " * Specifies the event name for panStart.",
          " */"
        ]
      ],
      "static PAN": [
        "static PAN: 'pan';",
        [
          "/**",
          " * Specifies the event name for pan.",
          " */"
        ]
      ],
      "static PAN_END": [
        "static PAN_END: 'panEnd';",
        [
          "/**",
          " * Specifies the event name for panEnd.",
          " */"
        ]
      ],
      "static MINIMIZE": [
        "static MINIMIZE: 'minimize';",
        [
          "/**",
          " * Specifies the event name for minimize.",
          " */"
        ]
      ],
      "static NORMALIZE": [
        "static NORMALIZE: 'normalize';",
        [
          "/**",
          " * Specifies the event name for normalize.",
          " */"
        ]
      ],
      "static MAXIMIZE": [
        "static MAXIMIZE: 'maximize';",
        [
          "/**",
          " * Specifies the event name for maximize.",
          " */"
        ]
      ],
      "static HIDE": [
        "static HIDE: 'hide';",
        [
          "/**",
          " * Specifies the event name for hide.",
          " */"
        ]
      ],
      "static SHOW": [
        "static SHOW: 'show';",
        [
          "/**",
          " * Specifies the event name for show.",
          " */"
        ]
      ],
      "static CLOSE": [
        "static CLOSE: 'close';",
        [
          "/**",
          " * Specifies the event name for close.",
          " */"
        ]
      ],
      "static DESTROY": [
        "static DESTROY: 'destroy';",
        [
          "/**",
          " * Specifies the event name for destroy.",
          " */"
        ]
      ],
      "static REFRESH": [
        "static REFRESH: 'refresh';",
        [
          "/**",
          " * Specifies the event name for refresh.",
          " */"
        ]
      ],
      "static SIZE": [
        "static SIZE: 'size';",
        [
          "/**",
          " * Specifies the event name for size.",
          " */"
        ]
      ],
      "static SELECT": [
        "static SELECT: 'select';",
        [
          "/**",
          " * Specifies the event name for select.",
          " */"
        ]
      ],
      "static FIRED": [
        "static FIRED: 'fired';",
        [
          "/**",
          " * Specifies the event name for fired.",
          " */"
        ]
      ],
      "static FIRE_MOUSE_EVENT": [
        "static FIRE_MOUSE_EVENT: 'fireMouseEvent';",
        [
          "/**",
          " * Specifies the event name for fireMouseEvent.",
          " */"
        ]
      ],
      "static GESTURE": [
        "static GESTURE: 'gesture';",
        [
          "/**",
          " * Specifies the event name for gesture.",
          " */"
        ]
      ],
      "static TAP_AND_HOLD": [
        "static TAP_AND_HOLD: 'tapAndHold';",
        [
          "/**",
          " * Specifies the event name for tapAndHold.",
          " */"
        ]
      ],
      "static GET": [
        "static GET: 'get';",
        [
          "/**",
          " * Specifies the event name for get.",
          " */"
        ]
      ],
      "static RECEIVE": [
        "static RECEIVE: 'receive';",
        [
          "/**",
          " * Specifies the event name for receive.",
          " */"
        ]
      ],
      "static CONNECT": [
        "static CONNECT: 'connect';",
        [
          "/**",
          " * Specifies the event name for connect.",
          " */"
        ]
      ],
      "static DISCONNECT": [
        "static DISCONNECT: 'disconnect';",
        [
          "/**",
          " * Specifies the event name for disconnect.",
          " */"
        ]
      ],
      "static SUSPEND": [
        "static SUSPEND: 'suspend';",
        [
          "/**",
          " * Specifies the event name for suspend.",
          " */"
        ]
      ],
      "static RESUME": [
        "static RESUME: 'resume';",
        [
          "/**",
          " * Specifies the event name for suspend.",
          " */"
        ]
      ],
      "static MARK": [
        "static MARK: 'mark';",
        [
          "/**",
          " * Specifies the event name for mark.",
          " */"
        ]
      ],
      "static ROOT": [
        "static ROOT: 'root';",
        [
          "/**",
          " * Specifies the event name for root.",
          " */"
        ]
      ],
      "static POST": [
        "static POST: 'post';",
        [
          "/**",
          " * Specifies the event name for post.",
          " */"
        ]
      ],
      "static OPEN": [
        "static OPEN: 'open';",
        [
          "/**",
          " * Specifies the event name for open.",
          " */"
        ]
      ],
      "static SAVE": [
        "static SAVE: 'save';",
        [
          "/**",
          " * Specifies the event name for open.",
          " */"
        ]
      ],
      "static BEFORE_ADD_VERTEX": [
        "static BEFORE_ADD_VERTEX: 'beforeAddVertex';",
        [
          "/**",
          " * Specifies the event name for beforeAddVertex.",
          " */"
        ]
      ],
      "static ADD_VERTEX": [
        "static ADD_VERTEX: 'addVertex';",
        [
          "/**",
          " * Specifies the event name for addVertex.",
          " */"
        ]
      ],
      "static AFTER_ADD_VERTEX": [
        "static AFTER_ADD_VERTEX: 'afterAddVertex';",
        [
          "/**",
          " * Specifies the event name for afterAddVertex.",
          " */"
        ]
      ],
      "static DONE": [
        "static DONE: 'done';",
        [
          "/**",
          " * Specifies the event name for done.",
          " */"
        ]
      ],
      "static EXECUTE": [
        "static EXECUTE: 'execute';",
        [
          "/**",
          " * Specifies the event name for execute.",
          " */"
        ]
      ],
      "static EXECUTED": [
        "static EXECUTED: 'executed';",
        [
          "/**",
          " * Specifies the event name for executed.",
          " */"
        ]
      ],
      "static BEGIN_UPDATE": [
        "static BEGIN_UPDATE: 'beginUpdate';",
        [
          "/**",
          " * Specifies the event name for beginUpdate.",
          " */"
        ]
      ],
      "static START_EDIT": [
        "static START_EDIT: 'startEdit';",
        [
          "/**",
          " * Specifies the event name for startEdit.",
          " */"
        ]
      ],
      "static END_UPDATE": [
        "static END_UPDATE: 'endUpdate';",
        [
          "/**",
          " * Specifies the event name for endUpdate.",
          " */"
        ]
      ],
      "static END_EDIT": [
        "static END_EDIT: 'endEdit';",
        [
          "/**",
          " * Specifies the event name for endEdit.",
          " */"
        ]
      ],
      "static BEFORE_UNDO": [
        "static BEFORE_UNDO: 'beforeUndo';",
        [
          "/**",
          " * Specifies the event name for beforeUndo.",
          " */"
        ]
      ],
      "static UNDO": [
        "static UNDO: 'undo';",
        [
          "/**",
          " * Specifies the event name for undo.",
          " */"
        ]
      ],
      "static REDO": [
        "static REDO: 'redo';",
        [
          "/**",
          " * Specifies the event name for redo.",
          " */"
        ]
      ],
      "static CHANGE": [
        "static CHANGE: 'change';",
        [
          "/**",
          " * Specifies the event name for change.",
          " */"
        ]
      ],
      "static NOTIFY": [
        "static NOTIFY: 'notify';",
        [
          "/**",
          " * Specifies the event name for notify.",
          " */"
        ]
      ],
      "static LAYOUT_CELLS": [
        "static LAYOUT_CELLS: 'layoutCells';",
        [
          "/**",
          " * Specifies the event name for layoutCells.",
          " */"
        ]
      ],
      "static CLICK": [
        "static CLICK: 'click';",
        [
          "/**",
          " * Specifies the event name for click.",
          " */"
        ]
      ],
      "static SCALE": [
        "static SCALE: 'scale';",
        [
          "/**",
          " * Specifies the event name for scale.",
          " */"
        ]
      ],
      "static TRANSLATE": [
        "static TRANSLATE: 'translate';",
        [
          "/**",
          " * Specifies the event name for translate.",
          " */"
        ]
      ],
      "static SCALE_AND_TRANSLATE": [
        "static SCALE_AND_TRANSLATE: 'scaleAndTranslate';",
        [
          "/**",
          " * Specifies the event name for scaleAndTranslate.",
          " */"
        ]
      ],
      "static UP": [
        "static UP: 'up';",
        [
          "/**",
          " * Specifies the event name for up.",
          " */"
        ]
      ],
      "static DOWN": [
        "static DOWN: 'down';",
        [
          "/**",
          " * Specifies the event name for down.",
          " */"
        ]
      ],
      "static ADD": [
        "static ADD: 'add';",
        [
          "/**",
          " * Specifies the event name for add.",
          " */"
        ]
      ],
      "static REMOVE": [
        "static REMOVE: 'remove';",
        [
          "/**",
          " * Specifies the event name for remove.",
          " */"
        ]
      ],
      "static CLEAR": [
        "static CLEAR: 'clear';",
        [
          "/**",
          " * Specifies the event name for clear.",
          " */"
        ]
      ],
      "static ADD_CELLS": [
        "static ADD_CELLS: 'addCells';",
        [
          "/**",
          " * Specifies the event name for addCells.",
          " */"
        ]
      ],
      "static CELLS_ADDED": [
        "static CELLS_ADDED: 'cellsAdded';",
        [
          "/**",
          " * Specifies the event name for cellsAdded.",
          " */"
        ]
      ],
      "static MOVE_CELLS": [
        "static MOVE_CELLS: 'moveCells';",
        [
          "/**",
          " * Specifies the event name for moveCells.",
          " */"
        ]
      ],
      "static CELLS_MOVED": [
        "static CELLS_MOVED: 'cellsMoved';",
        [
          "/**",
          " * Specifies the event name for cellsMoved.",
          " */"
        ]
      ],
      "static RESIZE_CELLS": [
        "static RESIZE_CELLS: 'resizeCells';",
        [
          "/**",
          " * Specifies the event name for resizeCells.",
          " */"
        ]
      ],
      "static CELLS_RESIZED": [
        "static CELLS_RESIZED: 'cellsResized';",
        [
          "/**",
          " * Specifies the event name for cellsResized.",
          " */"
        ]
      ],
      "static TOGGLE_CELLS": [
        "static TOGGLE_CELLS: 'toggleCells';",
        [
          "/**",
          " * Specifies the event name for toggleCells.",
          " */"
        ]
      ],
      "static CELLS_TOGGLED": [
        "static CELLS_TOGGLED: 'cellsToggled';",
        [
          "/**",
          " * Specifies the event name for cellsToggled.",
          " */"
        ]
      ],
      "static ORDER_CELLS": [
        "static ORDER_CELLS: 'orderCells';",
        [
          "/**",
          " * Specifies the event name for orderCells.",
          " */"
        ]
      ],
      "static CELLS_ORDERED": [
        "static CELLS_ORDERED: 'cellsOrdered';",
        [
          "/**",
          " * Specifies the event name for cellsOrdered.",
          " */"
        ]
      ],
      "static REMOVE_CELLS": [
        "static REMOVE_CELLS: 'removeCells';",
        [
          "/**",
          " * Specifies the event name for removeCells.",
          " */"
        ]
      ],
      "static CELLS_REMOVED": [
        "static CELLS_REMOVED: 'cellsRemoved';",
        [
          "/**",
          " * Specifies the event name for cellsRemoved.",
          " */"
        ]
      ],
      "static GROUP_CELLS": [
        "static GROUP_CELLS: 'groupCells';",
        [
          "/**",
          " * Specifies the event name for groupCells.",
          " */"
        ]
      ],
      "static UNGROUP_CELLS": [
        "static UNGROUP_CELLS: 'ungroupCells';",
        [
          "/**",
          " * Specifies the event name for ungroupCells.",
          " */"
        ]
      ],
      "static REMOVE_CELLS_FROM_PARENT": [
        "static REMOVE_CELLS_FROM_PARENT: 'removeCellsFromParent';",
        [
          "/**",
          " * Specifies the event name for removeCellsFromParent.",
          " */"
        ]
      ],
      "static FOLD_CELLS": [
        "static FOLD_CELLS: 'foldCells';",
        [
          "/**",
          " * Specifies the event name for foldCells.",
          " */"
        ]
      ],
      "static CELLS_FOLDED": [
        "static CELLS_FOLDED: 'cellsFolded';",
        [
          "/**",
          " * Specifies the event name for cellsFolded.",
          " */"
        ]
      ],
      "static ALIGN_CELLS": [
        "static ALIGN_CELLS: 'alignCells';",
        [
          "/**",
          " * Specifies the event name for alignCells.",
          " */"
        ]
      ],
      "static LABEL_CHANGED": [
        "static LABEL_CHANGED: 'labelChanged';",
        [
          "/**",
          " * Specifies the event name for labelChanged.",
          " */"
        ]
      ],
      "static CONNECT_CELL": [
        "static CONNECT_CELL: 'connectCell';",
        [
          "/**",
          " * Specifies the event name for connectCell.",
          " */"
        ]
      ],
      "static CELL_CONNECTED": [
        "static CELL_CONNECTED: 'cellConnected';",
        [
          "/**",
          " * Specifies the event name for cellConnected.",
          " */"
        ]
      ],
      "static SPLIT_EDGE": [
        "static SPLIT_EDGE: 'splitEdge';",
        [
          "/**",
          " * Specifies the event name for splitEdge.",
          " */"
        ]
      ],
      "static FLIP_EDGE": [
        "static FLIP_EDGE: 'flipEdge';",
        [
          "/**",
          " * Specifies the event name for flipEdge.",
          " */"
        ]
      ],
      "static START_EDITING": [
        "static START_EDITING: 'startEditing';",
        [
          "/**",
          " * Specifies the event name for startEditing.",
          " */"
        ]
      ],
      "static EDITING_STARTED": [
        "static EDITING_STARTED: 'editingStarted';",
        [
          "/**",
          " * Specifies the event name for editingStarted.",
          " */"
        ]
      ],
      "static EDITING_STOPPED": [
        "static EDITING_STOPPED: 'editingStopped';",
        [
          "/**",
          " * Specifies the event name for editingStopped.",
          " */"
        ]
      ],
      "static ADD_OVERLAY": [
        "static ADD_OVERLAY: 'addOverlay';",
        [
          "/**",
          " * Specifies the event name for addOverlay.",
          " */"
        ]
      ],
      "static REMOVE_OVERLAY": [
        "static REMOVE_OVERLAY: 'removeOverlay';",
        [
          "/**",
          " * Specifies the event name for removeOverlay.",
          " */"
        ]
      ],
      "static UPDATE_CELL_SIZE": [
        "static UPDATE_CELL_SIZE: 'updateCellSize';",
        [
          "/**",
          " * Specifies the event name for updateCellSize.",
          " */"
        ]
      ],
      "static ESCAPE": [
        "static ESCAPE: 'escape';",
        [
          "/**",
          " * Specifies the event name for escape.",
          " */"
        ]
      ],
      "static DOUBLE_CLICK": [
        "static DOUBLE_CLICK: 'doubleClick';",
        [
          "/**",
          " * Specifies the event name for doubleClick.",
          " */"
        ]
      ],
      "static START": [
        "static START: 'start';",
        [
          "/**",
          " * Specifies the event name for start.",
          " */"
        ]
      ],
      "static RESET": [
        "static RESET: 'reset';",
        [
          "/**",
          " * Specifies the event name for reset.",
          " */"
        ]
      ]
    }
  ],
  "mxAnimation": [
    [
      "/**",
      " * Implements a basic animation in JavaScript.",
      " *",
      " * @class mxAnimation",
      " * @extends {mxEventSource}",
      " */"
    ],
    {
      "constructor": [
        "constructor(delay: number);",
        [
          "/**",
          " * Creates an instance of mxAnimation.",
          " * @param {number} delay",
          " * @memberof mxAnimation",
          " */"
        ]
      ],
      "delay": [
        "delay: number;",
        [
          "/**",
          " * Specifies the delay between the animation steps. Defaul is 30ms.",
          " */"
        ]
      ],
      "thread": [
        "thread: number;",
        [
          "/**",
          " * Reference to the thread while the animation is running.",
          " */"
        ]
      ],
      "isRunning": [
        "isRunning(): boolean;",
        [
          "/**",
          " * Returns true if the animation is running.",
          " */"
        ]
      ],
      "startAnimation": [
        "startAnimation(): void;",
        [
          "/**",
          " * Starts the animation by repeatedly invoking updateAnimation.",
          " */"
        ]
      ],
      "updateAnimation": [
        "updateAnimation(): void;",
        [
          "/**",
          " * Hook for subclassers to implement the animation. Invoke stopAnimation",
          " * when finished, startAnimation to resume. This is called whenever the",
          " * timer fires and fires an mxEvent.EXECUTE event with no properties.",
          " */"
        ]
      ],
      "stopAnimation": [
        "stopAnimation(): void;",
        [
          "/**",
          " * Stops the animation by deleting the timer and fires an <mxEvent.DONE>.",
          " */"
        ]
      ]
    }
  ],
  "mxVmlCanvas2D": [
    [
      "/**",
      " * Implements a canvas to be used for rendering VML. Here is an example of implementing a",
      " * fallback for SVG images which are not supported in VML-based browsers.",
      " * @example",
      " * ```javascript",
      " * (code)",
      " * var mxVmlCanvas2DImage = mxVmlCanvas2D.prototype.image;",
      " * mxVmlCanvas2D.prototype.image = function(x, y, w, h, src, aspect, flipH, flipV)",
      " * {",
      " *   if (src.substring(src.length - 4, src.length) == '.svg')",
      " *   {",
      " *     src = 'http://www.jgraph.com/images/mxgraph.gif';",
      " *   }",
      " *",
      " *   mxVmlCanvas2DImage.apply(this, arguments);",
      " * };",
      " * ```",
      " *",
      " * To disable anti-aliasing in the output, use the following code.",
      " * @example",
      " * ```javascript",
      " * document.createStyleSheet().cssText = mxClient.VML_PREFIX + '\\\\:*{antialias:false;)}';",
      " * ```",
      " *",
      " * Note that there is a known issue in VML where gradients are painted using the outer",
      " * bounding box of rotated shapes, not the actual bounds of the shape. See",
      " * also {@link text} for plain text label restrictions in shapes for VML.",
      " */"
    ],
    {
      "constructor": [
        "constructor(root: Element);",
        null
      ],
      "root": [
        "root: Element;",
        [
          "/**",
          " * Reference to the container for the SVG content.",
          " */"
        ]
      ],
      "node": [
        "node: Element;",
        [
          "/**",
          " * Holds the current DOM node.",
          " */"
        ]
      ],
      "textEnabled": [
        "textEnabled: boolean;",
        [
          "/**",
          " * Specifies if text output should be enabled.",
          " * @default true",
          " */"
        ]
      ],
      "moveOp": [
        "moveOp: string;",
        [
          "/**",
          " * Contains the string used for moving in paths.",
          " * @default 'm'",
          " */"
        ]
      ],
      "lineOp": [
        "lineOp: string;",
        [
          "/**",
          " * Contains the string used for moving in paths.",
          " * @default 'l'",
          " */"
        ]
      ],
      "curveOp": [
        "curveOp: string;",
        [
          "/**",
          " * Contains the string used for bezier curves.",
          " * @default 'c'",
          " */"
        ]
      ],
      "closeOp": [
        "closeOp: string;",
        [
          "/**",
          " * Holds the operator for closing curves.",
          " * @default 'x'",
          " */"
        ]
      ],
      "rotatedHtmlBackground": [
        "rotatedHtmlBackground: string;",
        [
          "/**",
          " * Background color for rotated HTML. This can be set to eg.",
          " * white to improve rendering of rotated text in VML for IE9.",
          " * @default ''",
          " */"
        ]
      ],
      "vmlScale": [
        "vmlScale: number;",
        [
          "/**",
          " * Specifies the scale used to draw VML shapes.",
          " * @default 1",
          " */"
        ]
      ],
      "createElement": [
        "createElement(name: string): HTMLElement;",
        [
          "/**",
          " * Creates the given element using the document.",
          " */"
        ]
      ],
      "createVmlElement": [
        "createVmlElement(name: string): HTMLElement;",
        [
          "/**",
          " * Creates a new element using {@link createElement} and prefixes the given name with",
          " * {@link mxClient.VML_PREFIX}.",
          " */"
        ]
      ],
      "addNode": [
        "addNode(filled: boolean, stroked: boolean): void;",
        [
          "/**",
          " * Adds the current node to the {@link root}.",
          " */"
        ]
      ],
      "createTransparentFill": [
        "createTransparentFill(): HTMLElement;",
        [
          "/**",
          " * Creates a transparent fill.",
          " */"
        ]
      ],
      "createFill": [
        "createFill(): HTMLElement;",
        [
          "/**",
          " * Creates a fill for the current state.",
          " */"
        ]
      ],
      "createStroke": [
        "createStroke(): HTMLElement;",
        [
          "/**",
          " * Creates a fill for the current state.",
          " */"
        ]
      ],
      "getVmlDashStyle": [
        "getVmlDashStyle(): string;",
        [
          "/**",
          " * Returns a VML dash pattern for the current dashPattern.",
          " * See http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx",
          " */"
        ]
      ],
      "createShadow": [
        "createShadow(node: Element, filled: boolean, stroked: boolean): Element;",
        [
          "/**",
          " * Creates a shadow for the given node.",
          " */"
        ]
      ],
      "createShadowFill": [
        "createShadowFill(): HTMLElement;",
        [
          "/**",
          " * Creates the fill for the shadow.",
          " */"
        ]
      ],
      "createShadowStroke": [
        "createShadowStroke(): HTMLElement;",
        [
          "/**",
          " * Creates the stroke for the shadow.",
          " */"
        ]
      ],
      "rotate": [
        "rotate(theta: number, flipH: boolean, flipV: boolean, cx: number, cy: number): void;",
        [
          "/**",
          " * Sets the rotation of the canvas. Note that rotation cannot be concatenated.",
          " */"
        ]
      ],
      "begin": [
        "begin(): void;",
        [
          "/**",
          " * Extends superclass to create path.",
          " */"
        ]
      ],
      "quadTo": [
        "quadTo(x1: number, y1: number, x2: number, y2: number): void;",
        [
          "/**",
          " * Replaces quadratic curve with bezier curve in VML.",
          " */"
        ]
      ],
      "createRect": [
        "createRect(nodeName: string, x: number, y: number, w: number, h: number): HTMLElement;",
        [
          "/**",
          " * Sets the glass gradient.",
          " */"
        ]
      ],
      "rect": [
        "rect(x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Function: rect",
          " *",
          " * Sets the current path to a rectangle.",
          " */"
        ]
      ],
      "roundrect": [
        "roundrect(x: number, y: number, w: number, h: number, dx: number, dy: number): void;",
        [
          "/**",
          " * Sets the current path to a rounded rectangle.",
          " */"
        ]
      ],
      "ellipse": [
        "ellipse(x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Sets the current path to an ellipse.",
          " */"
        ]
      ],
      ")": [
        "): void;",
        [
          "/**",
          " * Paints the outline of the current path.",
          " */"
        ]
      ],
      "createDiv": [
        "createDiv(str: string, align: string, valign: string, overflow: string): HTMLElement;",
        [
          "/**",
          " * Creates the innermost element that contains the HTML text.",
          " */"
        ]
      ],
      "stroke": [
        "stroke(): void;",
        [
          "/**",
          " * Paints the outline of the current path.",
          " */"
        ]
      ],
      "fill": [
        "fill(): void;",
        [
          "/**",
          " * Fills the current path.",
          " */"
        ]
      ],
      "fillAndStroke": [
        "fillAndStroke(): void;",
        [
          "/**",
          " * Fills and paints the outline of the current path.",
          " */"
        ]
      ]
    }
  ],
  "mxPopupMenu": [
    null,
    {
      "constructor": [
        "constructor(factoryMethod: (handler: mxPopupMenuHandler, cell: mxCell, me: mxMouseEvent) => any);",
        null
      ],
      "submenuImage": [
        "submenuImage: string;",
        [
          "/**",
          " * Variable: submenuImage",
          " *",
          " * URL of the image to be used for the submenu icon.",
          " */"
        ]
      ],
      "zIndex": [
        "zIndex: number;",
        [
          "/**",
          " * Variable: zIndex",
          " *",
          " * Specifies the zIndex for the popupmenu and its shadow. Default is 1006.",
          " */"
        ]
      ],
      "factoryMethod": [
        "factoryMethod: (handler: mxPopupMenuHandler, cell: mxCell, me: mxMouseEvent) => any;",
        [
          "/**",
          " * Variable: factoryMethod",
          " *",
          " * Function that is used to create the popup menu. The function takes the",
          " * current panning handler, the <mxCell> under the mouse and the mouse",
          " * event that triggered the call as arguments.",
          " */"
        ]
      ],
      "useLeftButtonForPopup": [
        "useLeftButtonForPopup: boolean;",
        [
          "/**",
          " * Variable: useLeftButtonForPopup",
          " *",
          " * Specifies if popupmenus should be activated by clicking the left mouse",
          " * button. Default is false.",
          " */"
        ]
      ],
      "enabled": [
        "enabled: boolean;",
        [
          "/**",
          " * Variable: enabled",
          " *",
          " * Specifies if events are handled. Default is true.",
          " */"
        ]
      ],
      "itemCount": [
        "itemCount: number;",
        [
          "/**",
          " * Variable: itemCount",
          " *",
          " * Contains the number of times <addItem> has been called for a new menu.",
          " */"
        ]
      ],
      "autoExpand": [
        "autoExpand: boolean;",
        [
          "/**",
          " * Variable: autoExpand",
          " *",
          " * Specifies if submenus should be expanded on mouseover. Default is false.",
          " */"
        ]
      ],
      "smartSeparators": [
        "smartSeparators: boolean;",
        [
          "/**",
          " * Variable: smartSeparators",
          " *",
          " * Specifies if separators should only be added if a menu item follows them.",
          " * Default is false.",
          " */"
        ]
      ],
      "labels": [
        "labels: boolean;",
        [
          "/**",
          " * Variable: labels",
          " *",
          " * Specifies if any labels should be visible. Default is true.",
          " */"
        ]
      ],
      "init": [
        "init(): void;",
        [
          "/**",
          " * Function: init",
          " *",
          " * Initializes the shapes required for this vertex handler.",
          " */"
        ]
      ],
      "isEnabled": [
        "isEnabled(): boolean;",
        [
          "/**",
          " * Function: isEnabled",
          " *",
          " * Returns true if events are handled. This implementation",
          " * returns <enabled>.",
          " */"
        ]
      ],
      "setEnabled": [
        "setEnabled(enabled: boolean): void;",
        [
          "/**",
          " * Function: setEnabled",
          " *",
          " * Enables or disables event handling. This implementation",
          " * updates <enabled>.",
          " */"
        ]
      ],
      "isPopupTrigger": [
        "isPopupTrigger(me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Function: isPopupTrigger",
          " *",
          " * Returns true if the given event is a popupmenu trigger for the optional",
          " * given cell.",
          " *",
          " * Parameters:",
          " *",
          " * me - <mxMouseEvent> that represents the mouse event.",
          " */"
        ]
      ],
      ")": [
        "): Element;",
        [
          "/**",
          " * Function: addItem",
          " *",
          " * Adds the given item to the given parent item. If no parent item is specified",
          " * then the item is added to the top-level menu. The return value may be used",
          " * as the parent argument, ie. as a submenu item. The return value is the table",
          " * row that represents the item.",
          " *",
          " * Paramters:",
          " *",
          " * title - String that represents the title of the menu item.",
          " * image - Optional URL for the image icon.",
          " * funct - Function associated that takes a mouseup or touchend event.",
          " * parent - Optional item returned by <addItem>.",
          " * iconCls - Optional string that represents the CSS class for the image icon.",
          " * IconsCls is ignored if image is given.",
          " * enabled - Optional boolean indicating if the item is enabled. Default is true.",
          " * active - Optional boolean indicating if the menu should implement any event handling.",
          " * Default is true.",
          " */"
        ]
      ],
      "addCheckmark": [
        "addCheckmark(item: Element, img: string): void;",
        [
          "/**",
          " * Adds a checkmark to the given menuitem.",
          " */"
        ]
      ],
      "createSubmenu": [
        "createSubmenu(parent: Element): void;",
        [
          "/**",
          " * Function: createSubmenu",
          " *",
          " * Creates the nodes required to add submenu items inside the given parent",
          " * item. This is called in <addItem> if a parent item is used for the first",
          " * time. This adds various DOM nodes and a <submenuImage> to the parent.",
          " *",
          " * Parameters:",
          " *",
          " * parent - An item returned by <addItem>.",
          " */"
        ]
      ],
      "showSubmenu": [
        "showSubmenu(parent: Element, row: Element): void;",
        [
          "/**",
          " * Function: showSubmenu",
          " *",
          " * Shows the submenu inside the given parent row.",
          " */"
        ]
      ],
      "addSeparator": [
        "addSeparator(parent?: Element, force?: boolean): void;",
        [
          "/**",
          " * Function: addSeparator",
          " *",
          " * Adds a horizontal separator in the given parent item or the top-level menu",
          " * if no parent is specified.",
          " *",
          " * Parameters:",
          " *",
          " * parent - Optional item returned by <addItem>.",
          " * force - Optional boolean to ignore <smartSeparators>. Default is false.",
          " */"
        ]
      ],
      "popup": [
        "popup(x: number, y: number, cell: mxCell, evt: Event): void;",
        [
          "/**",
          " * Function: popup",
          " *",
          " * Shows the popup menu for the given event and cell.",
          " *",
          " * Example:",
          " *",
          " * (code)",
          " * graph.panningHandler.popup(x, y, cell, evt)",
          " * {",
          " *   mxUtils.alert('Hello, World!');",
          " * }",
          " * (end)",
          " */"
        ]
      ],
      "isMenuShowing": [
        "isMenuShowing(): boolean;",
        [
          "/**",
          " * Function: isMenuShowing",
          " *",
          " * Returns true if the menu is showing.",
          " */"
        ]
      ],
      "showMenu": [
        "showMenu(): void;",
        [
          "/**",
          " * Function: showMenu",
          " *",
          " * Shows the menu.",
          " */"
        ]
      ],
      "hideMenu": [
        "hideMenu(): void;",
        [
          "/**",
          " * Function: hideMenu",
          " *",
          " * Removes the menu and all submenus.",
          " */"
        ]
      ],
      "hideSubmenu": [
        "hideSubmenu(parent: Element): void;",
        [
          "/**",
          " * Function: hideSubmenu",
          " *",
          " * Removes all submenus inside the given parent.",
          " *",
          " * Parameters:",
          " *",
          " * parent - An item returned by <addItem>.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Function: destroy",
          " *",
          " * Destroys the handler and all its resources and DOM nodes.",
          " */"
        ]
      ]
    }
  ],
  "mxConstants": [
    [
      "/**",
      " * @class mxConstants",
      " */"
    ],
    {
      "static DEFAULT_HOTSPOT": [
        "static DEFAULT_HOTSPOT: number;",
        [
          "/**",
          " * Defines the portion of the cell which is to be used as a connectable",
          " * region. Default is 0.3. Possible values are 0 < x <= 1.",
          " * @default 0.3",
          " */"
        ]
      ],
      "static MIN_HOTSPOT_SIZE": [
        "static MIN_HOTSPOT_SIZE: number;",
        [
          "/**",
          " * Defines the minimum size in pixels of the portion of the cell which is",
          " * to be used as a connectable region. Default is 8.",
          " * @default 8",
          " */"
        ]
      ],
      "static MAX_HOTSPOT_SIZE": [
        "static MAX_HOTSPOT_SIZE: number;",
        [
          "/**",
          " * Defines the maximum size in pixels of the portion of the cell which is",
          " * to be used as a connectable region. Use 0 for no maximum. Default is 0.",
          " * @default 0",
          " */"
        ]
      ],
      "static RENDERING_HINT_EXACT": [
        "static RENDERING_HINT_EXACT: 'exact';",
        [
          "/**",
          " * Defines the exact rendering hint.",
          " */"
        ]
      ],
      "static RENDERING_HINT_FASTER": [
        "static RENDERING_HINT_FASTER: 'faster';",
        [
          "/**",
          " * Defines the faster rendering hint.",
          " */"
        ]
      ],
      "static RENDERING_HINT_FASTEST": [
        "static RENDERING_HINT_FASTEST: 'fastest';",
        [
          "/**",
          " * Defines the fastest rendering hint.",
          " */"
        ]
      ],
      "static DIALECT_SVG": [
        "static DIALECT_SVG: 'svg';",
        [
          "/**",
          " * Defines the SVG display dialect name.",
          " */"
        ]
      ],
      "static DIALECT_VML": [
        "static DIALECT_VML: 'vml';",
        [
          "/**",
          " * Defines the VML display dialect name.",
          " */"
        ]
      ],
      "static DIALECT_MIXEDHTML": [
        "static DIALECT_MIXEDHTML: 'mixedHtml';",
        [
          "/**",
          " * Defines the mixed HTML display dialect name.",
          " */"
        ]
      ],
      "static DIALECT_PREFERHTML": [
        "static DIALECT_PREFERHTML: 'preferHtml';",
        [
          "/**",
          " * Defines the preferred HTML display dialect name.",
          " */"
        ]
      ],
      "static DIALECT_STRICTHTML": [
        "static DIALECT_STRICTHTML: 'strictHtml';",
        [
          "/**",
          " * Defines the strict HTML display dialect.",
          " */"
        ]
      ],
      "static NS_SVG": [
        "static NS_SVG: 'http://www.w3.org/2000/svg';",
        [
          "/**",
          " * Defines the SVG namespace.",
          " */"
        ]
      ],
      "static NS_XHTML": [
        "static NS_XHTML: 'http://www.w3.org/1999/xhtml';",
        [
          "/**",
          " * Defines the XHTML namespace.",
          " */"
        ]
      ],
      "static NS_XLINK": [
        "static NS_XLINK: 'http://www.w3.org/1999/xlink';",
        [
          "/**",
          " * Defines the XLink namespace.",
          " */"
        ]
      ],
      "static SHADOWCOLOR": [
        "static SHADOWCOLOR: string;",
        [
          "/**",
          " * Defines the color to be used to draw shadows in shapes and windows.",
          " * @default gray",
          " */"
        ]
      ],
      "static VML_SHADOWCOLOR": [
        "static VML_SHADOWCOLOR: string;",
        [
          "/**",
          " * Used for shadow color in filters where transparency is not supported",
          " * (Microsoft Internet Explorer). Default is gray.",
          " *",
          " * @default gray",
          " */"
        ]
      ],
      "static SHADOW_OFFSET_X": [
        "static SHADOW_OFFSET_X: number;",
        [
          "/**",
          " * Specifies the x-offset of the shadow. Default is 2.",
          " * @default 2",
          " */"
        ]
      ],
      "static SHADOW_OFFSET_Y": [
        "static SHADOW_OFFSET_Y: number;",
        [
          "/**",
          " * Specifies the y-offset of the shadow. Default is 3.",
          " * @default 3",
          " */"
        ]
      ],
      "static SHADOW_OPACITY": [
        "static SHADOW_OPACITY: number;",
        [
          "/**",
          " * Defines the opacity for shadows. Default is 1.",
          " * @default 1",
          " */"
        ]
      ],
      "static NODETYPE_ELEMENT": [
        "static NODETYPE_ELEMENT: 1;",
        [
          "/**",
          " * DOM node of type ELEMENT.",
          " * @default 1",
          " */"
        ]
      ],
      "static NODETYPE_ATTRIBUTE": [
        "static NODETYPE_ATTRIBUTE: number;",
        [
          "/**",
          " * DOM node of type ATTRIBUTE.",
          " * @default 2",
          " */"
        ]
      ],
      "static NODETYPE_TEXT": [
        "static NODETYPE_TEXT: number;",
        [
          "/**",
          " * DOM node of type TEXT.",
          " * @default 3",
          " */"
        ]
      ],
      "static NODETYPE_CDATA": [
        "static NODETYPE_CDATA: number;",
        [
          "/**",
          " * DOM node of type CDATA.",
          " * @default 4",
          " */"
        ]
      ],
      "static NODETYPE_ENTITY_REFERENCE": [
        "static NODETYPE_ENTITY_REFERENCE: number;",
        [
          "/**",
          " * DOM node of type ENTITY_REFERENCE.",
          " * @default 5",
          " */"
        ]
      ],
      "static NODETYPE_ENTITY": [
        "static NODETYPE_ENTITY: number;",
        [
          "/**",
          " * DOM node of type ENTITY.",
          " * @default 6",
          " */"
        ]
      ],
      "static NODETYPE_PROCESSING_INSTRUCTION": [
        "static NODETYPE_PROCESSING_INSTRUCTION: number;",
        [
          "/**",
          " * DOM node of type PROCESSING_INSTRUCTION.",
          " * @default 7",
          " */"
        ]
      ],
      "static NODETYPE_COMMENT": [
        "static NODETYPE_COMMENT: number;",
        [
          "/**",
          " * DOM node of type COMMENT.",
          " * @default 8",
          " */"
        ]
      ],
      "static NODETYPE_DOCUMENT": [
        "static NODETYPE_DOCUMENT: number;",
        [
          "/**",
          " * DOM node of type DOCUMENT.",
          " * @default 9",
          " */"
        ]
      ],
      "static NODETYPE_DOCUMENTTYPE": [
        "static NODETYPE_DOCUMENTTYPE: number;",
        [
          "/**",
          " * DOM node of type DOCUMENTTYPE.",
          " * @default 10",
          " */"
        ]
      ],
      "static NODETYPE_DOCUMENT_FRAGMENT": [
        "static NODETYPE_DOCUMENT_FRAGMENT: number;",
        [
          "/**",
          " * DOM node of type DOCUMENT_FRAGMENT.",
          " * @default 11",
          " */"
        ]
      ],
      "static NODETYPE_NOTATION": [
        "static NODETYPE_NOTATION: number;",
        [
          "/**",
          " * DOM node of type NOTATION.",
          " * @default 12",
          " */"
        ]
      ],
      "static TOOLTIP_VERTICAL_OFFSET": [
        "static TOOLTIP_VERTICAL_OFFSET: number;",
        [
          "/**",
          " * Defines the vertical offset for the tooltip.",
          " * Default is 16.",
          " * @default 16",
          " */"
        ]
      ],
      "static DEFAULT_VALID_COLOR": [
        "static DEFAULT_VALID_COLOR: string;",
        [
          "/**",
          " * Specifies the default valid color. Default is #0000FF.",
          " * @default #00FF00",
          " */"
        ]
      ],
      "static DEFAULT_INVALID_COLOR": [
        "static DEFAULT_INVALID_COLOR: string;",
        [
          "/**",
          " * Specifies the default invalid color. Default is #FF0000.",
          " * @default #FF0000",
          " */"
        ]
      ],
      "static OUTLINE_HIGHLIGHT_COLOR": [
        "static OUTLINE_HIGHLIGHT_COLOR: string;",
        [
          "/**",
          " * Specifies the default highlight color for shape outlines.",
          " * Default is #0000FF. This is used in <mxEdgeHandler>.",
          " * @default #00FF00",
          " */"
        ]
      ],
      "static OUTLINE_HIGHLIGHT_STROKEWIDTH": [
        "static OUTLINE_HIGHLIGHT_STROKEWIDTH: number;",
        [
          "/**",
          " * Defines the strokewidth to be used for shape outlines.",
          " * Default is 5. This is used in <mxEdgeHandler>.",
          " * @default 5",
          " */"
        ]
      ],
      "static HIGHLIGHT_STROKEWIDTH": [
        "static HIGHLIGHT_STROKEWIDTH: number;",
        [
          "/**",
          " * Defines the strokewidth to be used for the highlights.",
          " * Default is 3.",
          " * @default 3",
          " */"
        ]
      ],
      "static HIGHLIGHT_SIZE": [
        "static HIGHLIGHT_SIZE: number;",
        [
          "/**",
          " * Size of the constraint highlight (in px). Default is 2.",
          " * @default 2",
          " */"
        ]
      ],
      "static HIGHLIGHT_OPACITY": [
        "static HIGHLIGHT_OPACITY: number;",
        [
          "/**",
          " * Opacity (in %) used for the highlights (including outline).",
          " * Default is 100.",
          " * @default 100",
          " */"
        ]
      ],
      "static CURSOR_MOVABLE_VERTEX": [
        "static CURSOR_MOVABLE_VERTEX: 'move';",
        [
          "/**",
          " * Defines the cursor for a movable vertex. Default is 'move'.",
          " */"
        ]
      ],
      "static CURSOR_MOVABLE_EDGE": [
        "static CURSOR_MOVABLE_EDGE: 'move';",
        [
          "/**",
          " * Defines the cursor for a movable edge. Default is 'move'.",
          " */"
        ]
      ],
      "static CURSOR_LABEL_HANDLE": [
        "static CURSOR_LABEL_HANDLE: 'default';",
        [
          "/**",
          " * Defines the cursor for a movable label. Default is 'default'.",
          " */"
        ]
      ],
      "static CURSOR_TERMINAL_HANDLE": [
        "static CURSOR_TERMINAL_HANDLE: 'pointer';",
        [
          "/**",
          " * Defines the cursor for a terminal handle. Default is 'pointer'.",
          " */"
        ]
      ],
      "static CURSOR_BEND_HANDLE": [
        "static CURSOR_BEND_HANDLE: 'crosshair';",
        [
          "/**",
          " * Defines the cursor for a movable bend. Default is 'crosshair'.",
          " */"
        ]
      ],
      "static CURSOR_VIRTUAL_BEND_HANDLE": [
        "static CURSOR_VIRTUAL_BEND_HANDLE: 'crosshair';",
        [
          "/**",
          " * Defines the cursor for a movable bend. Default is 'crosshair'.",
          " */"
        ]
      ],
      "static CURSOR_CONNECT": [
        "static CURSOR_CONNECT: 'pointer';",
        [
          "/**",
          " * Defines the cursor for a connectable state. Default is 'pointer'.",
          " */"
        ]
      ],
      "static HIGHLIGHT_COLOR": [
        "static HIGHLIGHT_COLOR: string;",
        [
          "/**",
          " * Defines the color to be used for the cell highlighting.",
          " * Use 'none' for no color. Default is #00FF00.",
          " * @default #00FF00",
          " */"
        ]
      ],
      "static CONNECT_TARGET_COLOR": [
        "static CONNECT_TARGET_COLOR: string;",
        [
          "/**",
          " * Defines the color to be used for highlighting a target cell for a new",
          " * or changed connection. Note that this may be either a source or",
          " * target terminal in the graph. Use 'none' for no color.",
          " * Default is #0000FF.",
          " * @default #0000FF",
          " */"
        ]
      ],
      "static INVALID_CONNECT_TARGET_COLOR": [
        "static INVALID_CONNECT_TARGET_COLOR: string;",
        [
          "/**",
          " * Defines the color to be used for highlighting a invalid target cells",
          " * for a new or changed connections. Note that this may be either a source",
          " * or target terminal in the graph. Use 'none' for no color. Default is",
          " * #FF0000.",
          " * @default #FF0000",
          " */"
        ]
      ],
      "static DROP_TARGET_COLOR": [
        "static DROP_TARGET_COLOR: string;",
        [
          "/**",
          " * Defines the color to be used for the highlighting target parent cells",
          " * (for drag and drop). Use 'none' for no color. Default is #0000FF.",
          " * @default #0000FF",
          " */"
        ]
      ],
      "static VALID_COLOR": [
        "static VALID_COLOR: string;",
        [
          "/**",
          " * Defines the color to be used for the coloring valid connection",
          " * previews. Use 'none' for no color. Default is #FF0000.",
          " * @default #00FF00",
          " */"
        ]
      ],
      "static INVALID_COLOR": [
        "static INVALID_COLOR: string;",
        [
          "/**",
          " * Defines the color to be used for the coloring invalid connection",
          " * previews. Use 'none' for no color. Default is #FF0000.",
          " * @default #FF0000",
          " */"
        ]
      ],
      "static EDGE_SELECTION_COLOR": [
        "static EDGE_SELECTION_COLOR: string;",
        [
          "/**",
          " * Defines the color to be used for the selection border of edges. Use",
          " * 'none' for no color. Default is #00FF00.",
          " * @default #00FF00",
          " */"
        ]
      ],
      "static VERTEX_SELECTION_COLOR": [
        "static VERTEX_SELECTION_COLOR: string;",
        [
          "/**",
          " * Defines the color to be used for the selection border of vertices. Use",
          " * 'none' for no color. Default is #00FF00.",
          " * @default #00FF00",
          " */"
        ]
      ],
      "static VERTEX_SELECTION_STROKEWIDTH": [
        "static VERTEX_SELECTION_STROKEWIDTH: number;",
        [
          "/**",
          " * Defines the strokewidth to be used for vertex selections.",
          " * Default is 1.",
          " * @default 1",
          " */"
        ]
      ],
      "static EDGE_SELECTION_STROKEWIDTH": [
        "static EDGE_SELECTION_STROKEWIDTH: number;",
        [
          "/**",
          " * Defines the strokewidth to be used for edge selections.",
          " * Default is 1.",
          " * @default 1",
          " */"
        ]
      ],
      "static VERTEX_SELECTION_DASHED": [
        "static VERTEX_SELECTION_DASHED: true;",
        [
          "/**",
          " * Defines the dashed state to be used for the vertex selection",
          " * border. Default is true.",
          " */"
        ]
      ],
      "static EDGE_SELECTION_DASHED": [
        "static EDGE_SELECTION_DASHED: true;",
        [
          "/**",
          " * Defines the dashed state to be used for the edge selection",
          " * border. Default is true.",
          " */"
        ]
      ],
      "static GUIDE_COLOR": [
        "static GUIDE_COLOR: string;",
        [
          "/**",
          " * Defines the color to be used for the guidelines in mxGraphHandler.",
          " * Default is #FF0000.",
          " * @default #FF0000",
          " */"
        ]
      ],
      "static GUIDE_STROKEWIDTH": [
        "static GUIDE_STROKEWIDTH: number;",
        [
          "/**",
          " * Defines the strokewidth to be used for the guidelines in mxGraphHandler.",
          " * Default is 1.",
          " * @default 1",
          " */"
        ]
      ],
      "static OUTLINE_COLOR": [
        "static OUTLINE_COLOR: string;",
        [
          "/**",
          " * Defines the color to be used for the outline rectangle",
          " * border.  Use 'none' for no color. Default is #0099FF.",
          " * @default #0099FF",
          " */"
        ]
      ],
      "static OUTLINE_STROKEWIDTH": [
        "static OUTLINE_STROKEWIDTH: number;",
        [
          "/**",
          " * Defines the strokewidth to be used for the outline rectangle",
          " * stroke width. Default is 3.",
          " */"
        ]
      ],
      "static HANDLE_SIZE": [
        "static HANDLE_SIZE: number;",
        [
          "/**",
          " * Defines the default size for handles. Default is 6.",
          " * @default 6",
          " */"
        ]
      ],
      "static LABEL_HANDLE_SIZE": [
        "static LABEL_HANDLE_SIZE: number;",
        [
          "/**",
          " * Defines the default size for label handles. Default is 4.",
          " * @default 4",
          " */"
        ]
      ],
      "static HANDLE_FILLCOLOR": [
        "static HANDLE_FILLCOLOR: string;",
        [
          "/**",
          " * Defines the color to be used for the handle fill color. Use 'none' for",
          " * no color. Default is #00FF00 (green).",
          " * @default #00FF00",
          " */"
        ]
      ],
      "static HANDLE_STROKECOLOR": [
        "static HANDLE_STROKECOLOR: string;",
        [
          "/**",
          " * Defines the color to be used for the handle stroke color. Use 'none' for",
          " * no color. Default is black.",
          " */"
        ]
      ],
      "static LABEL_HANDLE_FILLCOLOR": [
        "static LABEL_HANDLE_FILLCOLOR: string;",
        [
          "/**",
          " * Defines the color to be used for the label handle fill color. Use 'none'",
          " * for no color. Default is yellow.",
          " */"
        ]
      ],
      "static CONNECT_HANDLE_FILLCOLOR": [
        "static CONNECT_HANDLE_FILLCOLOR: string;",
        [
          "/**",
          " * Defines the color to be used for the connect handle fill color. Use",
          " * 'none' for no color. Default is #0000FF (blue).",
          " * @default #0000FF",
          " */"
        ]
      ],
      "static LOCKED_HANDLE_FILLCOLOR": [
        "static LOCKED_HANDLE_FILLCOLOR: string;",
        [
          "/**",
          " * Defines the color to be used for the locked handle fill color. Use",
          " * 'none' for no color. Default is #FF0000 (red).",
          " * @default #FF0000",
          " */"
        ]
      ],
      "static OUTLINE_HANDLE_FILLCOLOR": [
        "static OUTLINE_HANDLE_FILLCOLOR: string;",
        [
          "/**",
          " * Defines the color to be used for the outline sizer fill color. Use",
          " * 'none' for no color. Default is #00FFFF.",
          " * @default #00FFFF",
          " */"
        ]
      ],
      "static OUTLINE_HANDLE_STROKECOLOR": [
        "static OUTLINE_HANDLE_STROKECOLOR: string;",
        [
          "/**",
          " * Defines the color to be used for the outline sizer stroke color. Use",
          " * 'none' for no color. Default is #0033FF.",
          " * @default #0033FF",
          " */"
        ]
      ],
      "static DEFAULT_FONTFAMILY": [
        "static DEFAULT_FONTFAMILY: string;",
        [
          "/**",
          " * Defines the default family for all fonts. Default is Arial,Helvetica.",
          " * @default 'Arial,Helvetica'",
          " */"
        ]
      ],
      "static DEFAULT_FONTSIZE": [
        "static DEFAULT_FONTSIZE: number;",
        [
          "/**",
          " * Defines the default size (in px). Default is 11.",
          " * @default 11",
          " */"
        ]
      ],
      "static DEFAULT_TEXT_DIRECTION": [
        "static DEFAULT_TEXT_DIRECTION: '';",
        [
          "/**",
          " * Defines the default value for the <STYLE_TEXT_DIRECTION> if no value is",
          " * defined for it in the style. Default value is an empty string which means",
          " * the default system setting is used and no direction is set.",
          " */"
        ]
      ],
      "static LINE_HEIGHT": [
        "static LINE_HEIGHT: number;",
        [
          "/**",
          " * Defines the default line height for text labels. Default is 1.2.",
          " * @default 1.2",
          " */"
        ]
      ],
      "static WORD_WRAP": [
        "static WORD_WRAP: 'normal';",
        [
          "/**",
          " * Defines the CSS value for the word-wrap property. Default is \"normal\".",
          " * Change this to \"break-word\" to allow long words to be able to be broken",
          " * and wrap onto the next line.",
          " */"
        ]
      ],
      "static ABSOLUTE_LINE_HEIGHT": [
        "static ABSOLUTE_LINE_HEIGHT: false;",
        [
          "/**",
          " * Specifies if absolute line heights should be used (px) in CSS. Default",
          " * is false. Set this to true for backwards compatibility.",
          " */"
        ]
      ],
      "static DEFAULT_FONTSTYLE": [
        "static DEFAULT_FONTSTYLE: number;",
        [
          "/**",
          " * Defines the default style for all fonts. Default is 0. This can be set",
          " * to any combination of font styles as follows.",
          " *",
          " * (code)",
          " * mxConstants.DEFAULT_FONTSTYLE = mxConstants.FONT_BOLD | mxConstants.FONT_ITALIC;",
          " * (end)",
          " * @default 0",
          " */"
        ]
      ],
      "static DEFAULT_STARTSIZE": [
        "static DEFAULT_STARTSIZE: number;",
        [
          "/**",
          " * Defines the default start size for swimlanes. Default is 40.",
          " * @default 40",
          " */"
        ]
      ],
      "static DEFAULT_MARKERSIZE": [
        "static DEFAULT_MARKERSIZE: number;",
        [
          "/**",
          " * Defines the default size for all markers. Default is 6.",
          " * @default 6",
          " */"
        ]
      ],
      "static DEFAULT_IMAGESIZE": [
        "static DEFAULT_IMAGESIZE: number;",
        [
          "/**",
          " * Defines the default width and height for images used in the",
          " * label shape. Default is 24.",
          " * @default 24",
          " */"
        ]
      ],
      "static ENTITY_SEGMENT": [
        "static ENTITY_SEGMENT: number;",
        [
          "/**",
          " * Defines the length of the horizontal segment of an Entity Relation.",
          " * This can be overridden using <'segment'> style.",
          " * Default is 30.",
          " */"
        ]
      ],
      "static RECTANGLE_ROUNDING_FACTOR": [
        "static RECTANGLE_ROUNDING_FACTOR: number;",
        [
          "/**",
          " * Defines the rounding factor for rounded rectangles in percent between",
          " * 0 and 1. Values should be smaller than 0.5. Default is 0.15.",
          " * @default 0.15",
          " */"
        ]
      ],
      "static LINE_ARCSIZE": [
        "static LINE_ARCSIZE: number;",
        [
          "/**",
          " * Defines the size of the arcs for rounded edges. Default is 20.",
          " * @default 20",
          " */"
        ]
      ],
      "static ARROW_SPACING": [
        "static ARROW_SPACING: number;",
        [
          "/**",
          " * Defines the spacing between the arrow shape and its terminals. Default is 0.",
          " * @default 0",
          " */"
        ]
      ],
      "static ARROW_WIDTH": [
        "static ARROW_WIDTH: number;",
        [
          "/**",
          " * Defines the width of the arrow shape. Default is 30.",
          " * @default 30",
          " */"
        ]
      ],
      "static ARROW_SIZE": [
        "static ARROW_SIZE: number;",
        [
          "/**",
          " * Defines the size of the arrowhead in the arrow shape. Default is 30.",
          " * @default 30",
          " */"
        ]
      ],
      "static PAGE_FORMAT_A4_PORTRAIT": [
        "static PAGE_FORMAT_A4_PORTRAIT: mxRectangle;",
        [
          "/**",
          " * Defines the rectangle for the A4 portrait page format. The dimensions",
          " * of this page format are 826x1169 pixels.",
          " */"
        ]
      ],
      "static PAGE_FORMAT_A4_LANDSCAPE": [
        "static PAGE_FORMAT_A4_LANDSCAPE: mxRectangle;",
        [
          "/**",
          " * Defines the rectangle for the A4 portrait page format. The dimensions",
          " * of this page format are 826x1169 pixels.",
          " */"
        ]
      ],
      "static PAGE_FORMAT_LETTER_PORTRAIT": [
        "static PAGE_FORMAT_LETTER_PORTRAIT: mxRectangle;",
        [
          "/**",
          " * Defines the rectangle for the Letter portrait page format. The",
          " * dimensions of this page format are 850x1100 pixels.",
          " */"
        ]
      ],
      "static PAGE_FORMAT_LETTER_LANDSCAPE": [
        "static PAGE_FORMAT_LETTER_LANDSCAPE: mxRectangle;",
        [
          "/**",
          " * Defines the rectangle for the Letter portrait page format. The dimensions",
          " * of this page format are 850x1100 pixels.",
          " */"
        ]
      ],
      "static NONE": [
        "static NONE: 'none';",
        [
          "/**",
          " * Defines the value for none. Default is \"none\".",
          " */"
        ]
      ],
      "static STYLE_PERIMETER": [
        "static STYLE_PERIMETER: 'perimeter';",
        [
          "/**",
          " * Defines the key for the perimeter style. This is a function that defines",
          " * the perimeter around a particular shape. Possible values are the",
          " * functions defined in <mxPerimeter>. Alternatively, the constants in this",
          " * class that start with \"PERIMETER_\" may be used to access",
          " * perimeter styles in <mxStyleRegistry>. Value is \"perimeter\".",
          " */"
        ]
      ],
      "static STYLE_SOURCE_PORT": [
        "static STYLE_SOURCE_PORT: 'sourcePort';",
        [
          "/**",
          " * Defines the ID of the cell that should be used for computing the",
          " * perimeter point of the source for an edge. This allows for graphically",
          " * connecting to a cell while keeping the actual terminal of the edge.",
          " * Value is \"sourcePort\".",
          " */"
        ]
      ],
      "static STYLE_TARGET_PORT": [
        "static STYLE_TARGET_PORT: 'targetPort';",
        [
          "/**",
          " * Defines the ID of the cell that should be used for computing the",
          " * perimeter point of the target for an edge. This allows for graphically",
          " * connecting to a cell while keeping the actual terminal of the edge.",
          " * Value is \"targetPort\".",
          " */"
        ]
      ],
      "static STYLE_PORT_CONSTRAINT": [
        "static STYLE_PORT_CONSTRAINT: 'portConstraint';",
        [
          "/**",
          " * Defines the direction(s) that edges are allowed to connect to cells in.",
          " * Possible values are \"DIRECTION_NORTH, DIRECTION_SOUTH,",
          " * DIRECTION_EAST\" and \"DIRECTION_WEST\". Value is",
          " * \"portConstraint\".",
          " */"
        ]
      ],
      "static STYLE_PORT_CONSTRAINT_ROTATION": [
        "static STYLE_PORT_CONSTRAINT_ROTATION: 'portConstraintRotation';",
        [
          "/**",
          " * Define whether port constraint directions are rotated with vertex",
          " * rotation. 0 (default) causes port constraints to remain absolute,",
          " * relative to the graph, 1 causes the constraints to rotate with",
          " * the vertex. Value is \"portConstraintRotation\".",
          " */"
        ]
      ],
      "static STYLE_SOURCE_PORT_CONSTRAINT": [
        "static STYLE_SOURCE_PORT_CONSTRAINT: 'sourcePortConstraint';",
        [
          "/**",
          " * Defines the direction(s) that edges are allowed to connect to sources in.",
          " * Possible values are \"DIRECTION_NORTH, DIRECTION_SOUTH, DIRECTION_EAST\"",
          " * and \"DIRECTION_WEST\". Value is \"sourcePortConstraint\".",
          " */"
        ]
      ],
      "static STYLE_TARGET_PORT_CONSTRAINT": [
        "static STYLE_TARGET_PORT_CONSTRAINT: 'targetPortConstraint';",
        [
          "/**",
          " * Defines the direction(s) that edges are allowed to connect to targets in.",
          " * Possible values are \"DIRECTION_NORTH, DIRECTION_SOUTH, DIRECTION_EAST\"",
          " * and \"DIRECTION_WEST\". Value is \"targetPortConstraint\".",
          " */"
        ]
      ],
      "static STYLE_OPACITY": [
        "static STYLE_OPACITY: 'opacity';",
        [
          "/**",
          " * Defines the key for the opacity style. The type of the value is",
          " * numeric and the possible range is 0-100. Value is \"opacity\".",
          " */"
        ]
      ],
      "static STYLE_FILL_OPACITY": [
        "static STYLE_FILL_OPACITY: 'fillOpacity';",
        [
          "/**",
          " * Defines the key for the fill opacity style. The type of the value is",
          " * numeric and the possible range is 0-100. Value is \"fillOpacity\".",
          " */"
        ]
      ],
      "static STYLE_STROKE_OPACITY": [
        "static STYLE_STROKE_OPACITY: 'strokeOpacity';",
        [
          "/**",
          " * Defines the key for the stroke opacity style. The type of the value is",
          " * numeric and the possible range is 0-100. Value is \"strokeOpacity\".",
          " */"
        ]
      ],
      "static STYLE_TEXT_OPACITY": [
        "static STYLE_TEXT_OPACITY: 'textOpacity';",
        [
          "/**",
          " * Defines the key for the text opacity style. The type of the value is",
          " * numeric and the possible range is 0-100. Value is \"textOpacity\".",
          " */"
        ]
      ],
      "static STYLE_TEXT_DIRECTION": [
        "static STYLE_TEXT_DIRECTION: 'textDirection';",
        [
          "/**",
          " * Defines the key for the text direction style. Possible values are",
          " * \"TEXT_DIRECTION_DEFAULT, TEXT_DIRECTION_AUTO, TEXT_DIRECTION_LTR\"",
          " * and \"TEXT_DIRECTION_RTL\". Value is \"textDirection\".",
          " * The default value for the style is defined in <DEFAULT_TEXT_DIRECTION>.",
          " * It is used is no value is defined for this key in a given style. This is",
          " * an experimental style that is currently ignored in the backends.",
          " */"
        ]
      ],
      "static STYLE_OVERFLOW": [
        "static STYLE_OVERFLOW: 'overflow';",
        [
          "/**",
          " * Defines the key for the overflow style. Possible values are 'visible';",
          " * 'hidden', 'fill' and 'width'. The default value is 'visible'. This value",
          " * specifies how overlapping vertex labels are handled. A value of",
          " * 'visible' will show the complete label. A value of 'hidden' will clip",
          " * the label so that it does not overlap the vertex bounds. A value of",
          " * 'fill' will use the vertex bounds and a value of 'width' will use the",
          " * the vertex width for the label. See <mxGraph.isLabelClipped>. Note that",
          " * the vertical alignment is ignored for overflow fill and for horizontal",
          " * alignment, left should be used to avoid pixel offsets in Internet Explorer",
          " * 11 and earlier or if foreignObjects are disabled. Value is \"overflow\".",
          " */"
        ]
      ],
      "static STYLE_ORTHOGONAL": [
        "static STYLE_ORTHOGONAL: 'orthogonal';",
        [
          "/**",
          " * Defines if the connection points on either end of the edge should be",
          " * computed so that the edge is vertical or horizontal if possible and",
          " * if the point is not at a fixed location. Default is false. This is",
          " * used in <mxGraph.isOrthogonal>, which also returns true if the edgeStyle",
          " * of the edge is an elbow or entity. Value is \"orthogonal\".",
          " */"
        ]
      ],
      "static STYLE_EXIT_X": [
        "static STYLE_EXIT_X: 'exitX';",
        [
          "/**",
          " * Defines the key for the horizontal relative coordinate connection point",
          " * of an edge with its source terminal. Value is \"exitX\".",
          " */"
        ]
      ],
      "static STYLE_EXIT_Y": [
        "static STYLE_EXIT_Y: 'exitY';",
        [
          "/**",
          " * Defines the key for the vertical relative coordinate connection point",
          " * of an edge with its source terminal. Value is \"exitY\".",
          " */"
        ]
      ],
      "static STYLE_EXIT_PERIMETER": [
        "static STYLE_EXIT_PERIMETER: 'exitPerimeter';",
        [
          "/**",
          " * Defines if the perimeter should be used to find the exact entry point",
          " * along the perimeter of the source. Possible values are 0 (false) and",
          " * 1 (true). Default is 1 (true). Value is \"exitPerimeter\".",
          " */"
        ]
      ],
      "static STYLE_ENTRY_X": [
        "static STYLE_ENTRY_X: 'entryX';",
        [
          "/**",
          " * Defines the key for the horizontal relative coordinate connection point",
          " * of an edge with its target terminal. Value is \"entryX\".",
          " */"
        ]
      ],
      "static STYLE_ENTRY_Y": [
        "static STYLE_ENTRY_Y: 'entryY';",
        [
          "/**",
          " * Defines the key for the vertical relative coordinate connection point",
          " * of an edge with its target terminal. Value is \"entryY\".",
          " */"
        ]
      ],
      "static STYLE_ENTRY_PERIMETER": [
        "static STYLE_ENTRY_PERIMETER: 'entryPerimeter';",
        [
          "/**",
          " * Defines if the perimeter should be used to find the exact entry point",
          " * along the perimeter of the target. Possible values are 0 (false) and",
          " * 1 (true). Default is 1 (true). Value is \"entryPerimeter\".",
          " */"
        ]
      ],
      "static STYLE_WHITE_SPACE": [
        "static STYLE_WHITE_SPACE: 'whiteSpace';",
        [
          "/**",
          " * Defines the key for the white-space style. Possible values are 'nowrap'",
          " * and 'wrap'. The default value is 'nowrap'. This value specifies how",
          " * white-space inside a HTML vertex label should be handled. A value of",
          " * 'nowrap' means the text will never wrap to the next line until a",
          " * linefeed is encountered. A value of 'wrap' means text will wrap when",
          " * necessary. This style is only used for HTML labels.",
          " * See <mxGraph.isWrapping>. Value is \"whiteSpace\".",
          " */"
        ]
      ],
      "static STYLE_ROTATION": [
        "static STYLE_ROTATION: 'rotation';",
        [
          "/**",
          " * Defines the key for the rotation style. The type of the value is",
          " * numeric and the possible range is 0-360. Value is \"rotation\".",
          " */"
        ]
      ],
      "static STYLE_FILLCOLOR": [
        "static STYLE_FILLCOLOR: 'fillColor';",
        [
          "/**",
          " * Defines the key for the fill color. Possible values are all HTML color",
          " * names or HEX codes, as well as special keywords such as 'swimlane;",
          " * 'inherit' or 'indicated' to use the color code of a related cell or the",
          " * indicator shape. Value is \"fillColor\".",
          " */"
        ]
      ],
      "static 'pointerEvents'": [
        "static 'pointerEvents': 'pointerEvents';",
        [
          "/**",
          " * Specifies if pointer events should be fired on transparent backgrounds.",
          " * This style is currently only supported in <mxRectangleShape>. Default",
          " * is true. Value is \"pointerEvents\". This is typically set to",
          " * false in groups where the transparent part should allow any underlying",
          " * cells to be clickable.",
          " */"
        ]
      ],
      "static STYLE_SWIMLANE_FILLCOLOR": [
        "static STYLE_SWIMLANE_FILLCOLOR: 'swimlaneFillColor';",
        [
          "/**",
          " * Defines the key for the fill color of the swimlane background. Possible",
          " * values are all HTML color names or HEX codes. Default is no background.",
          " * Value is \"swimlaneFillColor\".",
          " */"
        ]
      ],
      "static 'margin'": [
        "static 'margin': 'margin';",
        [
          "/**",
          " * Defines the key for the margin between the ellipses in the double ellipse shape.",
          " * Possible values are all positive numbers. Value is \"margin\".",
          " */"
        ]
      ],
      "static STYLE_GRADIENTCOLOR": [
        "static STYLE_GRADIENTCOLOR: 'gradientColor';",
        [
          "/**",
          " * Defines the key for the gradient color. Possible values are all HTML color",
          " * names or HEX codes, as well as special keywords such as 'swimlane;",
          " * 'inherit' or 'indicated' to use the color code of a related cell or the",
          " * indicator shape. This is ignored if no fill color is defined. Value is",
          " * \"gradientColor\".",
          " */"
        ]
      ],
      "static STYLE_GRADIENT_DIRECTION": [
        "static STYLE_GRADIENT_DIRECTION: 'gradientDirection';",
        [
          "/**",
          " * Defines the key for the gradient direction. Possible values are",
          " * <DIRECTION_EAST>, <DIRECTION_WEST>, <DIRECTION_NORTH> and",
          " * <DIRECTION_SOUTH>. Default is <DIRECTION_SOUTH>. Generally, and by",
          " * default in mxGraph, gradient painting is done from the value of",
          " * <STYLE_FILLCOLOR> to the value of <STYLE_GRADIENTCOLOR>. Taking the",
          " * example of <DIRECTION_NORTH>, this means <STYLE_FILLCOLOR> color at the",
          " * bottom of paint pattern and <STYLE_GRADIENTCOLOR> at top, with a",
          " * gradient in-between. Value is \"gradientDirection\".",
          " */"
        ]
      ],
      "static 'strokeColor'": [
        "static 'strokeColor': 'strokeColor';",
        [
          "/**",
          " * Defines the key for the strokeColor style. Possible values are all HTML",
          " * color names or HEX codes, as well as special keywords such as 'swimlane;",
          " * 'inherit', 'indicated' to use the color code of a related cell or the",
          " * indicator shape or 'none' for no color. Value is \"strokeColor\".",
          " */"
        ]
      ],
      "static STYLE_SEPARATORCOLOR": [
        "static STYLE_SEPARATORCOLOR: 'separatorColor';",
        [
          "/**",
          " * Defines the key for the separatorColor style. Possible values are all",
          " * HTML color names or HEX codes. This style is only used for",
          " * <SHAPE_SWIMLANE> shapes. Value is \"separatorColor\".",
          " */"
        ]
      ],
      "static 'strokeWidth'": [
        "static 'strokeWidth': 'strokeWidth';",
        [
          "/**",
          " * Defines the key for the strokeWidth style. The type of the value is",
          " * numeric and the possible range is any non-negative value larger or equal",
          " * to 1. The value defines the stroke width in pixels. Note: To hide a",
          " * stroke use strokeColor none. Value is \"strokeWidth\".",
          " */"
        ]
      ],
      "static 'align'": [
        "static 'align': 'align';",
        [
          "/**",
          " * Defines the key for the align style. Possible values are <ALIGN_LEFT>;",
          " * <ALIGN_CENTER> and <ALIGN_RIGHT>. This value defines how the lines of",
          " * the label are horizontally aligned. <ALIGN_LEFT> mean label text lines",
          " * are aligned to left of the label bounds, <ALIGN_RIGHT> to the right of",
          " * the label bounds and <ALIGN_CENTER> means the center of the text lines",
          " * are aligned in the center of the label bounds. Note this value doesn't",
          " * affect the positioning of the overall label bounds relative to the",
          " * vertex, to move the label bounds horizontally, use",
          " * <'labelPosition'>. Value is \"align\".",
          " */"
        ]
      ],
      "static 'verticalAlign'": [
        "static 'verticalAlign': 'verticalAlign';",
        [
          "/**",
          " * Defines the key for the verticalAlign style. Possible values are",
          " * <ALIGN_TOP>, <ALIGN_MIDDLE> and <ALIGN_BOTTOM>. This value defines how",
          " * the lines of the label are vertically aligned. <ALIGN_TOP> means the",
          " * topmost label text line is aligned against the top of the label bounds;",
          " * <ALIGN_BOTTOM> means the bottom-most label text line is aligned against",
          " * the bottom of the label bounds and <ALIGN_MIDDLE> means there is equal",
          " * spacing between the topmost text label line and the top of the label",
          " * bounds and the bottom-most text label line and the bottom of the label",
          " * bounds. Note this value doesn't affect the positioning of the overall",
          " * label bounds relative to the vertex, to move the label bounds",
          " * vertically, use <'verticalLabelPosition'>. Value is \"verticalAlign\".",
          " */"
        ]
      ],
      "static 'labelWidth'": [
        "static 'labelWidth': 'labelWidth';",
        [
          "/**",
          " * Defines the key for the width of the label if the label position is not",
          " * center. Value is \"labelWidth\".",
          " */"
        ]
      ],
      "static 'labelPosition'": [
        "static 'labelPosition': 'labelPosition';",
        [
          "/**",
          " * Defines the key for the horizontal label position of vertices. Possible",
          " * values are <ALIGN_LEFT>, <ALIGN_CENTER> and <ALIGN_RIGHT>. Default is",
          " * <ALIGN_CENTER>. The label align defines the position of the label",
          " * relative to the cell. <ALIGN_LEFT> means the entire label bounds is",
          " * placed completely just to the left of the vertex, <ALIGN_RIGHT> means",
          " * adjust to the right and <ALIGN_CENTER> means the label bounds are",
          " * vertically aligned with the bounds of the vertex. Note this value",
          " * doesn't affect the positioning of label within the label bounds, to move",
          " * the label horizontally within the label bounds, use <'align'>.",
          " * Value is \"labelPosition\".",
          " */"
        ]
      ],
      "static 'verticalLabelPosition'": [
        "static 'verticalLabelPosition': 'verticalLabelPosition';",
        [
          "/**",
          " * Defines the key for the vertical label position of vertices. Possible",
          " * values are <ALIGN_TOP>, <ALIGN_BOTTOM> and <ALIGN_MIDDLE>. Default is",
          " * <ALIGN_MIDDLE>. The label align defines the position of the label",
          " * relative to the cell. <ALIGN_TOP> means the entire label bounds is",
          " * placed completely just on the top of the vertex, <ALIGN_BOTTOM> means",
          " * adjust on the bottom and <ALIGN_MIDDLE> means the label bounds are",
          " * horizontally aligned with the bounds of the vertex. Note this value",
          " * doesn't affect the positioning of label within the label bounds, to move",
          " * the label vertically within the label bounds, use",
          " * <'verticalAlign'>. Value is \"verticalLabelPosition\".",
          " */"
        ]
      ],
      "static STYLE_IMAGE_ASPECT": [
        "static STYLE_IMAGE_ASPECT: 'imageAspect';",
        [
          "/**",
          " * Defines the key for the image aspect style. Possible values are 0 (do",
          " * not preserve aspect) or 1 (keep aspect). This is only used in",
          " * <mxImageShape>. Default is 1. Value is \"imageAspect\".",
          " */"
        ]
      ],
      "static STYLE_IMAGE_ALIGN": [
        "static STYLE_IMAGE_ALIGN: 'imageAlign';",
        [
          "/**",
          " * Defines the key for the align style. Possible values are <ALIGN_LEFT>;",
          " * <ALIGN_CENTER> and <ALIGN_RIGHT>. The value defines how any image in the",
          " * vertex label is aligned horizontally within the label bounds of a",
          " * <SHAPE_LABEL> shape. Value is \"imageAlign\".",
          " */"
        ]
      ],
      "static STYLE_IMAGE_VERTICAL_ALIGN": [
        "static STYLE_IMAGE_VERTICAL_ALIGN: 'imageVerticalAlign';",
        [
          "/**",
          " * Defines the key for the verticalAlign style. Possible values are",
          " * <ALIGN_TOP>, <ALIGN_MIDDLE> and <ALIGN_BOTTOM>. The value defines how",
          " * any image in the vertex label is aligned vertically within the label",
          " * bounds of a <SHAPE_LABEL> shape. Value is \"imageVerticalAlign\".",
          " */"
        ]
      ],
      "static STYLE_GLASS": [
        "static STYLE_GLASS: 'glass';",
        [
          "/**",
          " * Defines the key for the glass style. Possible values are 0 (disabled) and",
          " * 1(enabled). The default value is 0. This is used in <mxLabel>. Value is",
          " * \"glass\".",
          " */"
        ]
      ],
      "static STYLE_IMAGE": [
        "static STYLE_IMAGE: 'image';",
        [
          "/**",
          " * Defines the key for the image style. Possible values are any image URL;",
          " * the type of the value is String. This is the path to the image that is",
          " * to be displayed within the label of a vertex. Data URLs should use the",
          " * following format: data:image/png,xyz where xyz is the base64 encoded",
          " * data (without the \"base64\"-prefix). Note that Data URLs are only",
          " * supported in modern browsers. Value is \"image\".",
          " */"
        ]
      ],
      "static STYLE_IMAGE_WIDTH": [
        "static STYLE_IMAGE_WIDTH: 'imageWidth';",
        [
          "/**",
          " * Defines the key for the imageWidth style. The type of this value is",
          " * int, the value is the image width in pixels and must be greater than 0.",
          " * Value is \"imageWidth\".",
          " */"
        ]
      ],
      "static STYLE_IMAGE_HEIGHT": [
        "static STYLE_IMAGE_HEIGHT: 'imageHeight';",
        [
          "/**",
          " * Defines the key for the imageHeight style. The type of this value is",
          " * int, the value is the image height in pixels and must be greater than 0.",
          " * Value is \"imageHeight\".",
          " */"
        ]
      ],
      "static STYLE_IMAGE_BACKGROUND": [
        "static STYLE_IMAGE_BACKGROUND: 'imageBackground';",
        [
          "/**",
          " * Defines the key for the image background color. This style is only used",
          " * in <mxImageShape>. Possible values are all HTML color names or HEX",
          " * codes. Value is \"imageBackground\".",
          " */"
        ]
      ],
      "static STYLE_IMAGE_BORDER": [
        "static STYLE_IMAGE_BORDER: 'imageBorder';",
        [
          "/**",
          " * Defines the key for the image border color. This style is only used in",
          " * <mxImageShape>. Possible values are all HTML color names or HEX codes.",
          " * Value is \"imageBorder\".",
          " */"
        ]
      ],
      "static STYLE_FLIPH": [
        "static STYLE_FLIPH: 'flipH';",
        [
          "/**",
          " * Defines the key for the horizontal image flip. This style is only used",
          " * in <mxImageShape>. Possible values are 0 and 1. Default is 0. Value is",
          " * \"flipH\".",
          " */"
        ]
      ],
      "static STYLE_FLIPV": [
        "static STYLE_FLIPV: 'flipV';",
        [
          "/**",
          " * Defines the key for the vertical flip. Possible values are 0 and 1.",
          " * Default is 0. Value is \"flipV\".",
          " */"
        ]
      ],
      "static STYLE_NOLABEL": [
        "static STYLE_NOLABEL: 'noLabel';",
        [
          "/**",
          " * Defines the key for the noLabel style. If this is true then no label is",
          " * visible for a given cell. Possible values are true or false (1 or 0).",
          " * Default is false. Value is \"noLabel\".",
          " */"
        ]
      ],
      "static STYLE_NOEDGESTYLE": [
        "static STYLE_NOEDGESTYLE: 'noEdgeStyle';",
        [
          "/**",
          " * Defines the key for the noEdgeStyle style. If this is true then no edge",
          " * style is applied for a given edge. Possible values are true or false",
          " * (1 or 0). Default is false. Value is \"noEdgeStyle\".",
          " */"
        ]
      ],
      "static STYLE_LABEL_BACKGROUNDCOLOR": [
        "static STYLE_LABEL_BACKGROUNDCOLOR: 'labelBackgroundColor';",
        [
          "/**",
          " * Defines the key for the label background color. Possible values are all",
          " * HTML color names or HEX codes. Value is \"labelBackgroundColor\".",
          " */"
        ]
      ],
      "static STYLE_LABEL_BORDERCOLOR": [
        "static STYLE_LABEL_BORDERCOLOR: 'labelBorderColor';",
        [
          "/**",
          " * Defines the key for the label border color. Possible values are all",
          " * HTML color names or HEX codes. Value is \"labelBorderColor\".",
          " */"
        ]
      ],
      "static STYLE_LABEL_PADDING": [
        "static STYLE_LABEL_PADDING: 'labelPadding';",
        [
          "/**",
          " * Defines the key for the label padding, ie. the space between the label",
          " * border and the label. Value is \"labelPadding\".",
          " */"
        ]
      ],
      "static STYLE_INDICATOR_SHAPE": [
        "static STYLE_INDICATOR_SHAPE: 'indicatorShape';",
        [
          "/**",
          " * Defines the key for the indicator shape used within an <mxLabel>.",
          " * Possible values are all SHAPE_* constants or the names of any new",
          " * shapes. The indicatorShape has precedence over the indicatorImage.",
          " * Value is \"indicatorShape\".",
          " */"
        ]
      ],
      "static STYLE_INDICATOR_IMAGE": [
        "static STYLE_INDICATOR_IMAGE: 'indicatorImage';",
        [
          "/**",
          " * Defines the key for the indicator image used within an <mxLabel>.",
          " * Possible values are all image URLs. The indicatorShape has",
          " * precedence over the indicatorImage. Value is \"indicatorImage\".",
          " */"
        ]
      ],
      "static STYLE_INDICATOR_COLOR": [
        "static STYLE_INDICATOR_COLOR: 'indicatorColor';",
        [
          "/**",
          " * Defines the key for the indicatorColor style. Possible values are all",
          " * HTML color names or HEX codes, as well as the special 'swimlane' keyword",
          " * to refer to the color of the parent swimlane if one exists. Value is",
          " * \"indicatorColor\".",
          " */"
        ]
      ],
      "static 'indicatorStrokeColor'": [
        "static 'indicatorStrokeColor': 'indicatorStrokeColor';",
        [
          "/**",
          " * Defines the key for the indicator stroke color in <mxLabel>.",
          " * Possible values are all color codes. Value is \"indicatorStrokeColor\".",
          " */"
        ]
      ],
      "static STYLE_INDICATOR_GRADIENTCOLOR": [
        "static STYLE_INDICATOR_GRADIENTCOLOR: 'indicatorGradientColor';",
        [
          "/**",
          " * Defines the key for the indicatorGradientColor style. Possible values",
          " * are all HTML color names or HEX codes. This style is only supported in",
          " * <SHAPE_LABEL> shapes. Value is \"indicatorGradientColor\".",
          " */"
        ]
      ],
      "static STYLE_INDICATOR_SPACING": [
        "static STYLE_INDICATOR_SPACING: 'indicatorSpacing';",
        [
          "/**",
          " * The defines the key for the spacing between the label and the",
          " * indicator in <mxLabel>. Possible values are in pixels. Value is",
          " * \"indicatorSpacing\".",
          " */"
        ]
      ],
      "static STYLE_INDICATOR_WIDTH": [
        "static STYLE_INDICATOR_WIDTH: 'indicatorWidth';",
        [
          "/**",
          " * Defines the key for the indicator width. Possible values start at 0 (in",
          " * pixels). Value is \"indicatorWidth\".",
          " */"
        ]
      ],
      "static STYLE_INDICATOR_HEIGHT": [
        "static STYLE_INDICATOR_HEIGHT: 'indicatorHeight';",
        [
          "/**",
          " * Defines the key for the indicator height. Possible values start at 0 (in",
          " * pixels). Value is \"indicatorHeight\".",
          " */"
        ]
      ],
      "static 'indicatorDirection'": [
        "static 'indicatorDirection': 'indicatorDirection';",
        [
          "/**",
          " * Defines the key for the indicatorDirection style. The direction style is",
          " * used to specify the direction of certain shapes (eg. <mxTriangle>).",
          " * Possible values are <DIRECTION_EAST> (default), <DIRECTION_WEST>;",
          " * <DIRECTION_NORTH> and <DIRECTION_SOUTH>. Value is \"indicatorDirection\".",
          " */"
        ]
      ],
      "static STYLE_SHADOW": [
        "static STYLE_SHADOW: 'shadow';",
        [
          "/**",
          " * Defines the key for the shadow style. The type of the value is Boolean.",
          " * Value is \"shadow\".",
          " */"
        ]
      ],
      "static 'segment'": [
        "static 'segment': 'segment';",
        [
          "/**",
          " * Defines the key for the segment style. The type of this value is float",
          " * and the value represents the size of the horizontal segment of the",
          " * entity relation style. Default is ENTITY_SEGMENT. Value is \"segment\".",
          " */"
        ]
      ],
      "static 'endArrow'": [
        "static 'endArrow': 'endArrow';",
        [
          "/**",
          " * Defines the key for the end arrow marker. Possible values are all",
          " * constants with an ARROW-prefix. This is only used in <mxConnector>.",
          " * Value is \"endArrow\".",
          " *",
          " * Example:",
          " * (code)",
          " * style.endArrow = mxConstants.ARROW_CLASSIC;",
          " * (end)",
          " */"
        ]
      ],
      "static 'startArrow'": [
        "static 'startArrow': 'startArrow';",
        [
          "/**",
          " * Defines the key for the start arrow marker. Possible values are all",
          " * constants with an ARROW-prefix. This is only used in <mxConnector>.",
          " * See <'endArrow'>. Value is \"startArrow\".",
          " */"
        ]
      ],
      "static STYLE_ENDSIZE": [
        "static STYLE_ENDSIZE: 'endSize';",
        [
          "/**",
          " * Defines the key for the endSize style. The type of this value is numeric",
          " * and the value represents the size of the end marker in pixels. Value is",
          " * \"endSize\".",
          " */"
        ]
      ],
      "static STYLE_STARTSIZE": [
        "static STYLE_STARTSIZE: 'startSize';",
        [
          "/**",
          " * Defines the key for the startSize style. The type of this value is",
          " * numeric and the value represents the size of the start marker or the",
          " * size of the swimlane title region depending on the shape it is used for.",
          " * Value is \"startSize\".",
          " */"
        ]
      ],
      "static STYLE_SWIMLANE_LINE": [
        "static STYLE_SWIMLANE_LINE: 'swimlaneLine';",
        [
          "/**",
          " * Defines the key for the swimlaneLine style. This style specifies whether",
          " * the line between the title regio of a swimlane should be visible. Use 0",
          " * for hidden or 1 (default) for visible. Value is \"swimlaneLine\".",
          " */"
        ]
      ],
      "static STYLE_ENDFILL": [
        "static STYLE_ENDFILL: 'endFill';",
        [
          "/**",
          " * Defines the key for the endFill style. Use 0 for no fill or 1 (default)",
          " * for fill. (This style is only exported via <mxImageExport>.) Value is",
          " * \"endFill\".",
          " */"
        ]
      ],
      "static STYLE_STARTFILL": [
        "static STYLE_STARTFILL: 'startFill';",
        [
          "/**",
          " * Defines the key for the startFill style. Use 0 for no fill or 1 (default)",
          " * for fill. (This style is only exported via <mxImageExport>.) Value is",
          " * \"startFill\".",
          " */"
        ]
      ],
      "static STYLE_DASHED": [
        "static STYLE_DASHED: 'dashed';",
        [
          "/**",
          " * Defines the key for the dashed style. Use 0 (default) for non-dashed or 1",
          " * for dashed. Value is \"dashed\".",
          " */"
        ]
      ],
      "static STYLE_DASH_PATTERN": [
        "static STYLE_DASH_PATTERN: 'dashPattern';",
        [
          "/**",
          " * Defines the key for the dashed pattern style in SVG and image exports.",
          " * The type of this value is a space separated list of numbers that specify",
          " * a custom-defined dash pattern. Dash styles are defined in terms of the",
          " * length of the dash (the drawn part of the stroke) and the length of the",
          " * space between the dashes. The lengths are relative to the line width: a",
          " * length of \"1\" is equal to the line width. VML ignores this style and",
          " * uses dashStyle instead as defined in the VML specification. This style",
          " * is only used in the <mxConnector> shape. Value is \"dashPattern\".",
          " */"
        ]
      ],
      "static STYLE_FIX_DASH": [
        "static STYLE_FIX_DASH: 'fixDash';",
        [
          "/**",
          " * Defines the key for the fixDash style. Use 0 (default) for dash patterns",
          " * that depend on the linewidth and 1 for dash patterns that ignore the",
          " * line width. Value is \"fixDash\".",
          " */"
        ]
      ],
      "static STYLE_ROUNDED": [
        "static STYLE_ROUNDED: 'rounded';",
        [
          "/**",
          " * Defines the key for the rounded style. The type of this value is",
          " * Boolean. For edges this determines whether or not joins between edges",
          " * segments are smoothed to a rounded finish. For vertices that have the",
          " * rectangle shape, this determines whether or not the rectangle is",
          " * rounded. Use 0 (default) for non-rounded or 1 for rounded. Value is",
          " * \"rounded\".",
          " */"
        ]
      ],
      "static STYLE_CURVED": [
        "static STYLE_CURVED: 'curved';",
        [
          "/**",
          " * Defines the key for the curved style. The type of this value is",
          " * Boolean. It is only applicable for connector shapes. Use 0 (default)",
          " * for non-curved or 1 for curved. Value is \"curved\".",
          " */"
        ]
      ],
      "static 'arcSize'": [
        "static 'arcSize': 'arcSize';",
        [
          "/**",
          " * Defines the rounding factor for a rounded rectangle in percent (without",
          " * the percent sign). Possible values are between 0 and 100. If this value",
          " * is not specified then RECTANGLE_ROUNDING_FACTOR * 100 is used. For",
          " * edges, this defines the absolute size of rounded corners in pixels. If",
          " * this values is not specified then LINE_ARCSIZE is used.",
          " * (This style is only exported via <mxImageExport>.) Value is \"arcSize\".",
          " */"
        ]
      ],
      "static STYLE_ABSOLUTE_ARCSIZE": [
        "static STYLE_ABSOLUTE_ARCSIZE: 'absoluteArcSize';",
        [
          "/**",
          " * Defines the key for the absolute arc size style. This specifies if",
          " * arcSize for rectangles is abolute or relative. Possible values are 1",
          " * and 0 (default). Value is \"absoluteArcSize\".",
          " */"
        ]
      ],
      "static STYLE_SOURCE_PERIMETER_SPACING": [
        "static STYLE_SOURCE_PERIMETER_SPACING: 'sourcePerimeterSpacing';",
        [
          "/**",
          " * Defines the key for the source perimeter spacing. The type of this value",
          " * is numeric. This is the distance between the source connection point of",
          " * an edge and the perimeter of the source vertex in pixels. This style",
          " * only applies to edges. Value is \"sourcePerimeterSpacing\".",
          " */"
        ]
      ],
      "static STYLE_TARGET_PERIMETER_SPACING": [
        "static STYLE_TARGET_PERIMETER_SPACING: 'targetPerimeterSpacing';",
        [
          "/**",
          " * Defines the key for the target perimeter spacing. The type of this value",
          " * is numeric. This is the distance between the target connection point of",
          " * an edge and the perimeter of the target vertex in pixels. This style",
          " * only applies to edges. Value is \"targetPerimeterSpacing\".",
          " */"
        ]
      ],
      "static STYLE_PERIMETER_SPACING": [
        "static STYLE_PERIMETER_SPACING: 'perimeterSpacing';",
        [
          "/**",
          " * Defines the key for the perimeter spacing. This is the distance between",
          " * the connection point and the perimeter in pixels. When used in a vertex",
          " * style, this applies to all incoming edges to floating ports (edges that",
          " * terminate on the perimeter of the vertex). When used in an edge style;",
          " * this spacing applies to the source and target separately, if they",
          " * terminate in floating ports (on the perimeter of the vertex). Value is",
          " * \"perimeterSpacing\".",
          " */"
        ]
      ],
      "static STYLE_SPACING": [
        "static STYLE_SPACING: 'spacing';",
        [
          "/**",
          " * Defines the key for the spacing. The value represents the spacing, in",
          " * pixels, added to each side of a label in a vertex (style applies to",
          " * vertices only). Value is \"spacing\".",
          " */"
        ]
      ],
      "static STYLE_SPACING_TOP": [
        "static STYLE_SPACING_TOP: 'spacingTop';",
        [
          "/**",
          " * Defines the key for the spacingTop style. The value represents the",
          " * spacing, in pixels, added to the top side of a label in a vertex (style",
          " * applies to vertices only). Value is \"spacingTop\".",
          " */"
        ]
      ],
      "static STYLE_SPACING_LEFT": [
        "static STYLE_SPACING_LEFT: 'spacingLeft';",
        [
          "/**",
          " * Defines the key for the spacingLeft style. The value represents the",
          " * spacing, in pixels, added to the left side of a label in a vertex (style",
          " * applies to vertices only). Value is \"spacingLeft\".",
          " */"
        ]
      ],
      "static STYLE_SPACING_BOTTOM": [
        "static STYLE_SPACING_BOTTOM: 'spacingBottom';",
        [
          "/**",
          " * Defines the key for the spacingBottom style The value represents the",
          " * spacing, in pixels, added to the bottom side of a label in a vertex",
          " * (style applies to vertices only). Value is \"spacingBottom\".",
          " */"
        ]
      ],
      "static STYLE_SPACING_RIGHT": [
        "static STYLE_SPACING_RIGHT: 'spacingRight';",
        [
          "/**",
          " * Defines the key for the spacingRight style The value represents the",
          " * spacing, in pixels, added to the right side of a label in a vertex (style",
          " * applies to vertices only). Value is \"spacingRight\".",
          " */"
        ]
      ],
      "static STYLE_HORIZONTAL": [
        "static STYLE_HORIZONTAL: 'horizontal';",
        [
          "/**",
          " * Defines the key for the horizontal style. Possible values are",
          " * true or false. This value only applies to vertices. If the <'shape'>",
          " * is \"SHAPE_SWIMLANE\" a value of false indicates that the",
          " * swimlane should be drawn vertically, true indicates to draw it",
          " * horizontally. If the shape style does not indicate that this vertex is a",
          " * swimlane, this value affects only whether the label is drawn",
          " * horizontally or vertically. Value is \"horizontal\".",
          " */"
        ]
      ],
      "static STYLE_DIRECTION": [
        "static STYLE_DIRECTION: 'direction';",
        [
          "/**",
          " * Defines the key for the direction style. The direction style is used",
          " * to specify the direction of certain shapes (eg. <mxTriangle>).",
          " * Possible values are <DIRECTION_EAST> (default), <DIRECTION_WEST>;",
          " * <DIRECTION_NORTH> and <DIRECTION_SOUTH>. Value is \"direction\".",
          " */"
        ]
      ],
      "static STYLE_ANCHOR_POINT_DIRECTION": [
        "static STYLE_ANCHOR_POINT_DIRECTION: 'anchorPointDirection';",
        [
          "/**",
          " * Defines the key for the anchorPointDirection style. The defines if the",
          " * direction style should be taken into account when computing the fixed",
          " * point location for connected edges. Default is 1 (yes). Set this to 0",
          " * to ignore the direction style for fixed connection points. Value is",
          " * \"anchorPointDirection\".",
          " */"
        ]
      ],
      "static 'elbow'": [
        "static 'elbow': 'elbow';",
        [
          "/**",
          " * Defines the key for the elbow style. Possible values are",
          " * <ELBOW_HORIZONTAL> and <ELBOW_VERTICAL>. Default is <ELBOW_HORIZONTAL>.",
          " * This defines how the three segment orthogonal edge style leaves its",
          " * terminal vertices. The vertical style leaves the terminal vertices at",
          " * the top and bottom sides. Value is \"elbow\".",
          " */"
        ]
      ],
      "static 'fontColor'": [
        "static 'fontColor': 'fontColor';",
        [
          "/**",
          " * Defines the key for the fontColor style. Possible values are all HTML",
          " * color names or HEX codes. Value is \"fontColor\".",
          " */"
        ]
      ],
      "static STYLE_FONTFAMILY": [
        "static STYLE_FONTFAMILY: 'fontFamily';",
        [
          "/**",
          " * Defines the key for the fontFamily style. Possible values are names such",
          " * as Arial; Dialog; Verdana; Times New Roman. The value is of type String.",
          " * Value is fontFamily.",
          " */"
        ]
      ],
      "static STYLE_FONTSIZE": [
        "static STYLE_FONTSIZE: 'fontSize';",
        [
          "/**",
          " * Defines the key for the fontSize style (in px). The type of the value",
          " * is int. Value is \"fontSize\".",
          " */"
        ]
      ],
      "static STYLE_FONTSTYLE": [
        "static STYLE_FONTSTYLE: 'fontStyle';",
        [
          "/**",
          " * Defines the key for the fontStyle style. Values may be any logical AND",
          " * (sum) of <FONT_BOLD>, <FONT_ITALIC> and <FONT_UNDERLINE>.",
          " * The type of the value is int. Value is \"fontStyle\".",
          " */"
        ]
      ],
      "static STYLE_ASPECT": [
        "static STYLE_ASPECT: 'aspect';",
        [
          "/**",
          " * Defines the key for the aspect style. Possible values are empty or fixed.",
          " * If fixed is used then the aspect ratio of the cell will be maintained",
          " * when resizing. Default is empty. Value is \"aspect\".",
          " */"
        ]
      ],
      "static STYLE_AUTOSIZE": [
        "static STYLE_AUTOSIZE: 'autosize';",
        [
          "/**",
          " * Defines the key for the autosize style. This specifies if a cell should be",
          " * resized automatically if the value has changed. Possible values are 0 or 1.",
          " * Default is 0. See <mxGraph.isAutoSizeCell>. This is normally combined with",
          " * <STYLE_RESIZABLE> to disable manual sizing. Value is \"autosize\".",
          " */"
        ]
      ],
      "static STYLE_FOLDABLE": [
        "static STYLE_FOLDABLE: 'foldable';",
        [
          "/**",
          " * Defines the key for the foldable style. This specifies if a cell is foldable",
          " * using a folding icon. Possible values are 0 or 1. Default is 1. See",
          " * <mxGraph.isCellFoldable>. Value is \"foldable\".",
          " */"
        ]
      ],
      "static STYLE_EDITABLE": [
        "static STYLE_EDITABLE: 'editable';",
        [
          "/**",
          " * Defines the key for the editable style. This specifies if the value of",
          " * a cell can be edited using the in-place editor. Possible values are 0 or",
          " * 1. Default is 1. See <mxGraph.isCellEditable>. Value is \"editable\".",
          " */"
        ]
      ],
      "static 'backgroundOutline'": [
        "static 'backgroundOutline': 'backgroundOutline';",
        [
          "/**",
          " * Defines the key for the backgroundOutline style. This specifies if a",
          " * only the background of a cell should be painted when it is highlighted.",
          " * Possible values are 0 or 1. Default is 0. Value is \"backgroundOutline\".",
          " */"
        ]
      ],
      "static STYLE_BENDABLE": [
        "static STYLE_BENDABLE: 'bendable';",
        [
          "/**",
          " * Defines the key for the bendable style. This specifies if the control",
          " * points of an edge can be moved. Possible values are 0 or 1. Default is",
          " * 1. See <mxGraph.isCellBendable>. Value is \"bendable\".",
          " */"
        ]
      ],
      "static STYLE_MOVABLE": [
        "static STYLE_MOVABLE: 'movable';",
        [
          "/**",
          " * Defines the key for the movable style. This specifies if a cell can",
          " * be moved. Possible values are 0 or 1. Default is 1. See",
          " * <mxGraph.isCellMovable>. Value is \"movable\".",
          " */"
        ]
      ],
      "static STYLE_RESIZABLE": [
        "static STYLE_RESIZABLE: 'resizable';",
        [
          "/**",
          " * Defines the key for the resizable style. This specifies if a cell can",
          " * be resized. Possible values are 0 or 1. Default is 1. See",
          " * <mxGraph.isCellResizable>. Value is \"resizable\".",
          " */"
        ]
      ],
      "static STYLE_RESIZE_WIDTH": [
        "static STYLE_RESIZE_WIDTH: 'resizeWidth';",
        [
          "/**",
          " * Defines the key for the resizeWidth style. This specifies if a cell's",
          " * width is resized if the parent is resized. If this is 1 then the width",
          " * will be resized even if the cell's geometry is relative. If this is 0",
          " * then the cell's width will not be resized. Default is not defined. Value",
          " * is \"resizeWidth\".",
          " */"
        ]
      ],
      "static STYLE_RESIZE_HEIGHT": [
        "static STYLE_RESIZE_HEIGHT: 'resizeHeight';",
        [
          "/**",
          " * Defines the key for the resizeHeight style. This specifies if a cell's",
          " * height if resize if the parent is resized. If this is 1 then the height",
          " * will be resized even if the cell's geometry is relative. If this is 0",
          " * then the cell's height will not be resized. Default is not defined. Value",
          " * is \"resizeHeight\".",
          " */"
        ]
      ],
      "static STYLE_ROTATABLE": [
        "static STYLE_ROTATABLE: 'rotatable';",
        [
          "/**",
          " * Defines the key for the rotatable style. This specifies if a cell can",
          " * be rotated. Possible values are 0 or 1. Default is 1. See",
          " * <mxGraph.isCellRotatable>. Value is \"rotatable\".",
          " */"
        ]
      ],
      "static STYLE_CLONEABLE": [
        "static STYLE_CLONEABLE: 'cloneable';",
        [
          "/**",
          " * Defines the key for the cloneable style. This specifies if a cell can",
          " * be cloned. Possible values are 0 or 1. Default is 1. See",
          " * <mxGraph.isCellCloneable>. Value is \"cloneable\".",
          " */"
        ]
      ],
      "static STYLE_DELETABLE": [
        "static STYLE_DELETABLE: 'deletable';",
        [
          "/**",
          " * Defines the key for the deletable style. This specifies if a cell can be",
          " * deleted. Possible values are 0 or 1. Default is 1. See",
          " * <mxGraph.isCellDeletable>. Value is \"deletable\".",
          " */"
        ]
      ],
      "static 'shape'": [
        "static 'shape': 'shape';",
        [
          "/**",
          " * Defines the key for the shape. Possible values are all constants with",
          " * a SHAPE-prefix or any newly defined shape names. Value is \"shape\".",
          " */"
        ]
      ],
      "static STYLE_EDGE": [
        "static STYLE_EDGE: 'edgeStyle';",
        [
          "/**",
          " * Defines the key for the edge style. Possible values are the functions",
          " * defined in <mxEdgeStyle>. Value is \"edgeStyle\".",
          " */"
        ]
      ],
      "static 'jettySize'": [
        "static 'jettySize': 'jettySize';",
        [
          "/**",
          " * Defines the key for the jetty size in <mxEdgeStyle.OrthConnector>.",
          " * Default is 10. Possible values are all numeric values or \"auto\".",
          " * Value is \"jettySize\".",
          " */"
        ]
      ],
      "static 'sourceJettySize'": [
        "static 'sourceJettySize': 'sourceJettySize';",
        [
          "/**",
          " * Defines the key for the jetty size in <mxEdgeStyle.OrthConnector>.",
          " * Default is 10. Possible values are numeric values or \"auto\". This has",
          " * precedence over <'jettySize'>. Value is \"sourceJettySize\".",
          " */"
        ]
      ],
      "static 'targetJettySize'": [
        "static 'targetJettySize': 'targetJettySize';",
        [
          "/**",
          " * Defines the key for the jetty size in <mxEdgeStyle.OrthConnector>.",
          " * Default is 10. Possible values are numeric values or \"auto\". This has",
          " * precedence over <'jettySize'>. Value is \"targetJettySize\".",
          " */"
        ]
      ],
      "static STYLE_LOOP": [
        "static STYLE_LOOP: 'loopStyle';",
        [
          "/**",
          " * Defines the key for the loop style. Possible values are the functions",
          " * defined in <mxEdgeStyle>. Value is \"loopStyle\".",
          " */"
        ]
      ],
      "static STYLE_ORTHOGONAL_LOOP": [
        "static STYLE_ORTHOGONAL_LOOP: 'orthogonalLoop';",
        [
          "/**",
          " * Defines the key for the orthogonal loop style. Possible values are 0 and",
          " * 1. Default is 0. Value is \"orthogonalLoop\". Use this style to specify",
          " * if loops should be routed using an orthogonal router. Currently, this",
          " * uses <mxEdgeStyle.OrthConnector> but will be replaced with a dedicated",
          " * orthogonal loop router in later releases.",
          " */"
        ]
      ],
      "static STYLE_ROUTING_CENTER_X": [
        "static STYLE_ROUTING_CENTER_X: 'routingCenterX';",
        [
          "/**",
          " * Defines the key for the horizontal routing center. Possible values are",
          " * between -0.5 and 0.5. This is the relative offset from the center used",
          " * for connecting edges. The type of this value is numeric. Value is",
          " * \"routingCenterX\".",
          " */"
        ]
      ],
      "static STYLE_ROUTING_CENTER_Y": [
        "static STYLE_ROUTING_CENTER_Y: 'routingCenterY';",
        [
          "/**",
          " * Defines the key for the vertical routing center. Possible values are",
          " * between -0.5 and 0.5. This is the relative offset from the center used",
          " * for connecting edges. The type of this value is numeric. Value is",
          " * \"routingCenterY\".",
          " */"
        ]
      ],
      "static FONT_BOLD": [
        "static FONT_BOLD: number;",
        [
          "/**",
          " * Constant for bold fonts. Default is 1.",
          " * @default 1",
          " */"
        ]
      ],
      "static FONT_ITALIC": [
        "static FONT_ITALIC: number;",
        [
          "/**",
          " * Constant for italic fonts. Default is 2.",
          " * @default 2",
          " */"
        ]
      ],
      "static FONT_UNDERLINE": [
        "static FONT_UNDERLINE: number;",
        [
          "/**",
          " * Constant for underlined fonts. Default is 4.",
          " * @default 4",
          " */"
        ]
      ],
      "static FONT_STRIKETHROUGH": [
        "static FONT_STRIKETHROUGH: number;",
        [
          "/**",
          " * Constant for strikthrough fonts. Default is 8.",
          " * @since mxgraph 4.1.0",
          " * @default 8",
          " */"
        ]
      ],
      "static SHAPE_RECTANGLE": [
        "static SHAPE_RECTANGLE: 'rectangle';",
        [
          "/**",
          " * Name under which <mxRectangleShape> is registered in <mxCellRenderer>.",
          " * Default is rectangle.",
          " */"
        ]
      ],
      "static SHAPE_ELLIPSE": [
        "static SHAPE_ELLIPSE: 'ellipse';",
        [
          "/**",
          " * Name under which <mxEllipse> is registered in <mxCellRenderer>.",
          " * Default is ellipse.",
          " */"
        ]
      ],
      "static SHAPE_DOUBLE_ELLIPSE": [
        "static SHAPE_DOUBLE_ELLIPSE: 'doubleEllipse';",
        [
          "/**",
          " * Name under which <mxDoubleEllipse> is registered in <mxCellRenderer>.",
          " * Default is doubleEllipse.",
          " */"
        ]
      ],
      "static SHAPE_RHOMBUS": [
        "static SHAPE_RHOMBUS: 'rhombus';",
        [
          "/**",
          " * Name under which <mxRhombus> is registered in <mxCellRenderer>.",
          " * Default is rhombus.",
          " */"
        ]
      ],
      "static SHAPE_LINE": [
        "static SHAPE_LINE: 'line';",
        [
          "/**",
          " * Name under which <mxLine> is registered in <mxCellRenderer>.",
          " * Default is line.",
          " */"
        ]
      ],
      "static SHAPE_IMAGE": [
        "static SHAPE_IMAGE: 'image';",
        [
          "/**",
          " * Name under which <mxImageShape> is registered in <mxCellRenderer>.",
          " * Default is image.",
          " */"
        ]
      ],
      "static SHAPE_ARROW": [
        "static SHAPE_ARROW: 'arrow';",
        [
          "/**",
          " * Name under which <mxArrow> is registered in <mxCellRenderer>.",
          " * Default is arrow.",
          " */"
        ]
      ],
      "static SHAPE_ARROW_CONNECTOR": [
        "static SHAPE_ARROW_CONNECTOR: 'arrowConnector';",
        [
          "/**",
          " * Name under which <mxArrowConnector> is registered in <mxCellRenderer>.",
          " * Default is arrowConnector.",
          " */"
        ]
      ],
      "static SHAPE_LABEL": [
        "static SHAPE_LABEL: 'label';",
        [
          "/**",
          " * Name under which <mxLabel> is registered in <mxCellRenderer>.",
          " * Default is label.",
          " */"
        ]
      ],
      "static SHAPE_CYLINDER": [
        "static SHAPE_CYLINDER: 'cylinder';",
        [
          "/**",
          " * Name under which <mxCylinder> is registered in <mxCellRenderer>.",
          " * Default is cylinder.",
          " */"
        ]
      ],
      "static SHAPE_SWIMLANE": [
        "static SHAPE_SWIMLANE: 'swimlane';",
        [
          "/**",
          " * Name under which <mxSwimlane> is registered in <mxCellRenderer>.",
          " * Default is swimlane.",
          " */"
        ]
      ],
      "static SHAPE_CONNECTOR": [
        "static SHAPE_CONNECTOR: 'connector';",
        [
          "/**",
          " * Name under which <mxConnector> is registered in <mxCellRenderer>.",
          " * Default is connector.",
          " */"
        ]
      ],
      "static SHAPE_ACTOR": [
        "static SHAPE_ACTOR: 'actor';",
        [
          "/**",
          " * Name under which <mxActor> is registered in <mxCellRenderer>.",
          " * Default is actor.",
          " */"
        ]
      ],
      "static SHAPE_CLOUD": [
        "static SHAPE_CLOUD: 'cloud';",
        [
          "/**",
          " * Name under which <mxCloud> is registered in <mxCellRenderer>.",
          " * Default is cloud.",
          " */"
        ]
      ],
      "static SHAPE_TRIANGLE": [
        "static SHAPE_TRIANGLE: 'triangle';",
        [
          "/**",
          " * Name under which <mxTriangle> is registered in <mxCellRenderer>.",
          " * Default is triangle.",
          " */"
        ]
      ],
      "static SHAPE_HEXAGON": [
        "static SHAPE_HEXAGON: 'hexagon';",
        [
          "/**",
          " * Name under which <mxHexagon> is registered in <mxCellRenderer>.",
          " * Default is hexagon.",
          " */"
        ]
      ],
      "static ARROW_CLASSIC": [
        "static ARROW_CLASSIC: 'classic';",
        [
          "/**",
          " * Constant for classic arrow markers.",
          " */"
        ]
      ],
      "static ARROW_CLASSIC_THIN": [
        "static ARROW_CLASSIC_THIN: 'classicThin';",
        [
          "/**",
          " * Constant for thin classic arrow markers.",
          " */"
        ]
      ],
      "static ARROW_BLOCK": [
        "static ARROW_BLOCK: 'block';",
        [
          "/**",
          " * Constant for block arrow markers.",
          " */"
        ]
      ],
      "static ARROW_BLOCK_THIN": [
        "static ARROW_BLOCK_THIN: 'blockThin';",
        [
          "/**",
          " * Constant for thin block arrow markers.",
          " */"
        ]
      ],
      "static ARROW_OPEN": [
        "static ARROW_OPEN: 'open';",
        [
          "/**",
          " * Constant for open arrow markers.",
          " */"
        ]
      ],
      "static ARROW_OPEN_THIN": [
        "static ARROW_OPEN_THIN: 'openThin';",
        [
          "/**",
          " * Constant for thin open arrow markers.",
          " */"
        ]
      ],
      "static ARROW_OVAL": [
        "static ARROW_OVAL: 'oval';",
        [
          "/**",
          " * Constant for oval arrow markers.",
          " */"
        ]
      ],
      "static ARROW_DIAMOND": [
        "static ARROW_DIAMOND: 'diamond';",
        [
          "/**",
          " * Constant for diamond arrow markers.",
          " */"
        ]
      ],
      "static ARROW_DIAMOND_THIN": [
        "static ARROW_DIAMOND_THIN: 'diamondThin';",
        [
          "/**",
          " * Constant for thin diamond arrow markers.",
          " */"
        ]
      ],
      "static ALIGN_LEFT": [
        "static ALIGN_LEFT: 'left';",
        [
          "/**",
          " * Constant for left horizontal alignment. Default is left.",
          " */"
        ]
      ],
      "static ALIGN_CENTER": [
        "static ALIGN_CENTER: 'center';",
        [
          "/**",
          " * Constant for center horizontal alignment. Default is center.",
          " */"
        ]
      ],
      "static ALIGN_RIGHT": [
        "static ALIGN_RIGHT: 'right';",
        [
          "/**",
          " * Constant for right horizontal alignment. Default is right.",
          " */"
        ]
      ],
      "static ALIGN_TOP": [
        "static ALIGN_TOP: 'top';",
        [
          "/**",
          " * Constant for top vertical alignment. Default is top.",
          " */"
        ]
      ],
      "static ALIGN_MIDDLE": [
        "static ALIGN_MIDDLE: 'middle';",
        [
          "/**",
          " * Constant for middle vertical alignment. Default is middle.",
          " */"
        ]
      ],
      "static ALIGN_BOTTOM": [
        "static ALIGN_BOTTOM: 'bottom';",
        [
          "/**",
          " * Constant for bottom vertical alignment. Default is bottom.",
          " */"
        ]
      ],
      "static DIRECTION_NORTH": [
        "static DIRECTION_NORTH: 'north';",
        [
          "/**",
          " * Constant for direction north. Default is north.",
          " */"
        ]
      ],
      "static DIRECTION_SOUTH": [
        "static DIRECTION_SOUTH: 'south';",
        [
          "/**",
          " * Constant for direction south. Default is south.",
          " */"
        ]
      ],
      "static DIRECTION_EAST": [
        "static DIRECTION_EAST: 'east';",
        [
          "/**",
          " * Constant for direction east. Default is east.",
          " */"
        ]
      ],
      "static DIRECTION_WEST": [
        "static DIRECTION_WEST: 'west';",
        [
          "/**",
          " * Constant for direction west. Default is west.",
          " */"
        ]
      ],
      "static TEXT_DIRECTION_DEFAULT": [
        "static TEXT_DIRECTION_DEFAULT: '';",
        [
          "/**",
          " * Constant for text direction default. Default is an empty string. Use",
          " * this value to use the default text direction of the operating system.",
          " */"
        ]
      ],
      "static TEXT_DIRECTION_AUTO": [
        "static TEXT_DIRECTION_AUTO: 'auto';",
        [
          "/**",
          " * Constant for text direction automatic. Default is auto. Use this value",
          " * to find the direction for a given text with <mxText.getAutoDirection>.",
          " */"
        ]
      ],
      "static TEXT_DIRECTION_LTR": [
        "static TEXT_DIRECTION_LTR: 'ltr';",
        [
          "/**",
          " * Constant for text direction left to right. Default is ltr. Use this",
          " * value for left to right text direction.",
          " */"
        ]
      ],
      "static TEXT_DIRECTION_RTL": [
        "static TEXT_DIRECTION_RTL: 'rtl';",
        [
          "/**",
          " * Constant for text direction right to left. Default is rtl. Use this",
          " * value for right to left text direction.",
          " */"
        ]
      ],
      "static DIRECTION_MASK_NONE": [
        "static DIRECTION_MASK_NONE: number;",
        [
          "/**",
          " * Constant for no direction.",
          " * @default 0",
          " */"
        ]
      ],
      "static DIRECTION_MASK_WEST": [
        "static DIRECTION_MASK_WEST: number;",
        [
          "/**",
          " * Bitwise mask for west direction.",
          " * @default 1",
          " */"
        ]
      ],
      "static DIRECTION_MASK_NORTH": [
        "static DIRECTION_MASK_NORTH: number;",
        [
          "/**",
          " * Bitwise mask for north direction.",
          " * @default 2",
          " */"
        ]
      ],
      "static DIRECTION_MASK_SOUTH": [
        "static DIRECTION_MASK_SOUTH: number;",
        [
          "/**",
          " * Bitwise mask for south direction.",
          " * @default 4",
          " */"
        ]
      ],
      "static DIRECTION_MASK_EAST": [
        "static DIRECTION_MASK_EAST: number;",
        [
          "/**",
          " * Bitwise mask for east direction.",
          " * @default 8",
          " */"
        ]
      ],
      "static DIRECTION_MASK_ALL": [
        "static DIRECTION_MASK_ALL: number;",
        [
          "/**",
          " * Bitwise mask for all directions.",
          " * @default 15",
          " */"
        ]
      ],
      "static ELBOW_VERTICAL": [
        "static ELBOW_VERTICAL: 'vertical';",
        [
          "/**",
          " * Constant for elbow vertical. Default is horizontal.",
          " */"
        ]
      ],
      "static ELBOW_HORIZONTAL": [
        "static ELBOW_HORIZONTAL: 'horizontal';",
        [
          "/**",
          " * Constant for elbow horizontal. Default is horizontal.",
          " */"
        ]
      ],
      "static EDGESTYLE_ELBOW": [
        "static EDGESTYLE_ELBOW: 'elbowEdgeStyle';",
        [
          "/**",
          " * Name of the elbow edge style. Can be used as a string value",
          " * for the STYLE_EDGE style.",
          " */"
        ]
      ],
      "static EDGESTYLE_ENTITY_RELATION": [
        "static EDGESTYLE_ENTITY_RELATION: 'entityRelationEdgeStyle';",
        [
          "/**",
          " * Name of the entity relation edge style. Can be used as a string value",
          " * for the STYLE_EDGE style.",
          " */"
        ]
      ],
      "static EDGESTYLE_LOOP": [
        "static EDGESTYLE_LOOP: 'loopEdgeStyle';",
        [
          "/**",
          " * Name of the loop edge style. Can be used as a string value",
          " * for the STYLE_EDGE style.",
          " */"
        ]
      ],
      "static EDGESTYLE_SIDETOSIDE": [
        "static EDGESTYLE_SIDETOSIDE: 'sideToSideEdgeStyle';",
        [
          "/**",
          " * Name of the side to side edge style. Can be used as a string value",
          " * for the STYLE_EDGE style.",
          " */"
        ]
      ],
      "static EDGESTYLE_TOPTOBOTTOM": [
        "static EDGESTYLE_TOPTOBOTTOM: 'topToBottomEdgeStyle';",
        [
          "/**",
          " * Name of the top to bottom edge style. Can be used as a string value",
          " * for the STYLE_EDGE style.",
          " */"
        ]
      ],
      "static EDGESTYLE_ORTHOGONAL": [
        "static EDGESTYLE_ORTHOGONAL: 'orthogonalEdgeStyle';",
        [
          "/**",
          " * Name of the generic orthogonal edge style. Can be used as a string value",
          " * for the STYLE_EDGE style.",
          " */"
        ]
      ],
      "static EDGESTYLE_SEGMENT": [
        "static EDGESTYLE_SEGMENT: 'segmentEdgeStyle';",
        [
          "/**",
          " * Name of the generic segment edge style. Can be used as a string value",
          " * for the STYLE_EDGE style.",
          " */"
        ]
      ],
      "static PERIMETER_ELLIPSE": [
        "static PERIMETER_ELLIPSE: 'ellipsePerimeter';",
        [
          "/**",
          " * Name of the ellipse perimeter. Can be used as a string value",
          " * for the STYLE_PERIMETER style.",
          " */"
        ]
      ],
      "static PERIMETER_RECTANGLE": [
        "static PERIMETER_RECTANGLE: 'rectanglePerimeter';",
        [
          "/**",
          " * Name of the rectangle perimeter. Can be used as a string value",
          " * for the STYLE_PERIMETER style.",
          " */"
        ]
      ],
      "static PERIMETER_RHOMBUS": [
        "static PERIMETER_RHOMBUS: 'rhombusPerimeter';",
        [
          "/**",
          " * Name of the rhombus perimeter. Can be used as a string value",
          " * for the STYLE_PERIMETER style.",
          " */"
        ]
      ],
      "static PERIMETER_HEXAGON": [
        "static PERIMETER_HEXAGON: 'hexagonPerimeter';",
        [
          "/**",
          " * Name of the hexagon perimeter. Can be used as a string value",
          " * for the STYLE_PERIMETER style.",
          " */"
        ]
      ],
      "static PERIMETER_TRIANGLE": [
        "static PERIMETER_TRIANGLE: 'trianglePerimeter';",
        [
          "/**",
          " * Name of the triangle perimeter. Can be used as a string value",
          " * for the STYLE_PERIMETER style.",
          " */"
        ]
      ]
    }
  ],
  "mxDictionary<T = any>": [
    null,
    {
      "constructor": [
        "constructor();",
        null
      ],
      "map": [
        "map: { [key: string]: T };",
        [
          "/**",
          " * Function: map",
          " *",
          " * Stores the (key, value) pairs in this dictionary.",
          " */"
        ]
      ],
      "clear": [
        "clear(): void;",
        [
          "/**",
          " * Function: clear",
          " *",
          " * Clears the dictionary.",
          " */"
        ]
      ],
      "get": [
        "get(key: any): T;",
        [
          "/**",
          " * Function: get",
          " *",
          " * Returns the value for the given key.",
          " */"
        ]
      ],
      "put": [
        "put(key: any, value: T): T;",
        [
          "/**",
          " * Function: put",
          " *",
          " * Stores the value under the given key and returns the previous",
          " * value for that key.",
          " */"
        ]
      ],
      "remove": [
        "remove(key: string): T;",
        [
          "/**",
          " * Function: remove",
          " *",
          " * Removes the value for the given key and returns the value that",
          " * has been removed.",
          " */"
        ]
      ],
      "getKeys": [
        "getKeys(): string[];",
        [
          "/**",
          " * Function: getKeys",
          " *",
          " * Returns all keys as an array.",
          " */"
        ]
      ],
      "getValues": [
        "getValues(): T[];",
        [
          "/**",
          " * Function: getValues",
          " *",
          " * Returns all values as an array.",
          " */"
        ]
      ],
      "visit": [
        "visit(visitor: (key: string, value: T) => void): void;",
        [
          "/**",
          " * Function: visit",
          " *",
          " * Visits all entries in the dictionary using the given function with the",
          " * following signature: function(key, value) where key is a string and",
          " * value is an object.",
          " *",
          " * Parameters:",
          " *",
          " * visitor - A function that takes the key and value as arguments.",
          " */"
        ]
      ]
    }
  ],
  "mxResources": [
    [
      "/**",
      " * Implements internationalization. You can provide any number of",
      " * resource files on the server using the following format for the",
      " * filename: name[-en].properties. The en stands for any lowercase",
      " * 2-character language shortcut (eg. de for german, fr for french).",
      " *",
      " * If the optional language extension is omitted, then the file is used as a",
      " * default resource which is loaded in all cases. If a properties file for a",
      " * specific language exists, then it is used to override the settings in the",
      " * default resource. All entries in the file are of the form key=value. The",
      " * values may then be accessed in code via <get>. Lines without",
      " * equal signs in the properties files are ignored.",
      " *",
      " * Resource files may either be added programmatically using",
      " * <add> or via a resource tag in the UI section of the",
      " * editor configuration file, eg:",
      " *",
      " * ```JavaScript",
      " * <mxEditor>",
      " *   <ui>",
      " *     <resource basename=\"examples/resources/mxWorkflow\"/>",
      " * ```",
      " *",
      " * The above element will load examples/resources/mxWorkflow.properties as well",
      " * as the language specific file for the current language, if it exists.",
      " *",
      " * Values may contain placeholders of the form {1}...{n} where each placeholder",
      " * is replaced with the value of the corresponding array element in the params",
      " * argument passed to {@link mxResources.get}. The placeholder {1} maps to the first",
      " * element in the array (at index 0).",
      " *",
      " * See {@link mxClient.language} for more information on specifying the default",
      " * language or disabling all loading of resources.",
      " *",
      " * Lines that start with a # sign will be ignored.",
      " *",
      " * ### Special characters",
      " *",
      " * To use unicode characters, use the standard notation (eg. \\u8fd1) or %u as a",
      " * prefix (eg. %u20AC will display a Euro sign). For normal hex encoded strings,",
      " * use % as a prefix, eg. %F6 will display a \"o umlaut\" (&ouml;).",
      " *",
      " * See {@link resourcesEncoded} to disable this. If you disable this, make sure that",
      " * your files are UTF-8 encoded.",
      " *",
      " * ### Asynchronous loading",
      " *",
      " * By default, the core adds two resource files synchronously at load time.",
      " * To load these files asynchronously, set {@link mxLoadResources} to false",
      " * before loading mxClient.js and use {@link mxResources.loadResources} instead.",
      " */"
    ],
    {
      "static resources": [
        "static resources: {};",
        [
          "/**",
          " * Object that maps from keys to values.",
          " */"
        ]
      ],
      "static extension": [
        "static extension: typeof mxResourceExtension;",
        [
          "/**",
          " * Specifies the extension used for language files. Default is {@link mxResourceExtension}.",
          " */"
        ]
      ],
      "static resourcesEncoded": [
        "static resourcesEncoded: boolean;",
        [
          "/**",
          " * Specifies whether or not values in resource files are encoded with \\u or",
          " * percentage. Default is false.",
          " *",
          " * @default false",
          " */"
        ]
      ],
      "static loadDefaultBundle": [
        "static loadDefaultBundle: boolean;",
        [
          "/**",
          " * Specifies if the default file for a given basename should be loaded. Default is true.",
          " *",
          " * @default true",
          " */"
        ]
      ],
      "static loadSpecialBundle": [
        "static loadSpecialBundle: boolean;",
        [
          "/**",
          " * Specifies if the specific language file file for a given basename should",
          " * be loaded. Default is true.",
          " *",
          " * @default true",
          " */"
        ]
      ],
      "static isLanguageSupported": [
        "static isLanguageSupported(lan: string): boolean;",
        [
          "/**",
          " * Hook for subclassers to disable support for a given language. This",
          " * implementation returns true if lan is in {@link mxClient.languages}.",
          " *",
          " * @param lan The current language.",
          " */"
        ]
      ],
      "static getDefaultBundle": [
        "static getDefaultBundle(basename: string, lan: string): any;",
        [
          "/**",
          " * Hook for subclassers to return the URL for the special bundle. This",
          " * implementation returns basename + {@link extension} or null if",
          " * {@link loadDefaultBundle} is false.",
          " *",
          " * @param basename The basename for which the file should be loaded.",
          " * @param lan The current language.",
          " */"
        ]
      ],
      "static getSpecialBundle": [
        "static getSpecialBundle(basename: string, lan: string): any;",
        [
          "/**",
          " * Hook for subclassers to return the URL for the special bundle. This",
          " * implementation returns basename + '_' + lan + {@link extension} or null if",
          " * {@link loadSpecialBundle} is false or lan equals {@link mxClient.defaultLanguage}.",
          " *",
          " * If {@link mxResources.languages} is not null and {@link mxClient.language} contains",
          " * a dash, then this method checks if {@link isLanguageSupported} returns true",
          " * for the full language (including the dash). If that returns false the",
          " * first part of the language (up to the dash) will be tried as an extension.",
          " *",
          " * If {@link mxResources.language} is null then the first part of the language is",
          " * used to maintain backwards compatibility.",
          " *",
          " * @param basename The basename for which the file should be loaded.",
          " * @param lan The current language.",
          " */"
        ]
      ],
      "static add": [
        "static add(basename: string, lan: string, callback?: Function): void;",
        [
          "/**",
          " * Adds the default and current language properties file for the specified",
          " * basename. Existing keys are overridden as new files are added. If no",
          " * callback is used then the request is synchronous.",
          " *",
          " * @example",
          " *",
          " * At application startup, additional resources may be",
          " * added using the following code:",
          " *",
          " * ```JavaScript",
          " * mxResources.add('resources/editor');",
          " * ```",
          " *",
          " * @param basename The basename for which the file should be loaded.",
          " * @param lan The language for which the file should be loaded.",
          " * @param callback Optional callback for asynchronous loading.",
          " */"
        ]
      ],
      "static parse": [
        "static parse(text: string): void;",
        [
          "/**",
          " * Parses the key, value pairs in the specified",
          " * text and stores them as local resources.",
          " *",
          " * @param text",
          " */"
        ]
      ],
      "static get": [
        "static get(key: string, params?: Array<string | number | boolean>, defaultValue?: string): string;",
        [
          "/**",
          " * Returns the value for the specified resource key.",
          " *",
          " * @example",
          " * To read the value for 'welomeMessage', use the following:",
          " *",
          " * ```JavaScript",
          " * var result = mxResources.get('welcomeMessage') || '';",
          " * ```",
          " *",
          " * This would require an entry of the following form in",
          " * one of the English language resource files:",
          " *",
          " * ```JavaScript",
          " * welcomeMessage=Welcome to mxGraph!",
          " * ```",
          " *",
          " * The part behind the || is the string value to be used if the given",
          " * resource is not available.",
          " *",
          " * @param key String that represents the key of the resource to be returned.",
          " * @param params Array of the values for the placeholders of the form {1}...{n} to be replaced with in the resulting string.",
          " * @param defaultValue Optional string that specifies the default return value.",
          " */"
        ]
      ],
      "static replacePlaceholders": [
        "static replacePlaceholders(value: string, params: Array<string | number | boolean>): string;",
        [
          "/**",
          " * Replaces the given placeholders with the given parameters.",
          " *",
          " * @param value String that contains the placeholders.",
          " * @param params Array of the values for the placeholders of the form {1}...{n}",
          " * to be replaced with in the resulting string.",
          " */"
        ]
      ],
      "static loadResources": [
        "static loadResources(callback: Function): void;",
        [
          "/**",
          " * Loads all required resources asynchronously. Use this to load the graph and",
          " * editor resources if {@link mxLoadResources} is false.",
          " *",
          " * @param callback Callback function for asynchronous loading.",
          " */"
        ]
      ]
    }
  ],
  "mxImage": [
    null,
    {
      "constructor": [
        "constructor(src: string, width: number, height: number);",
        null
      ],
      "src": [
        "src: string;",
        [
          "/**",
          " * Variable: src",
          " *",
          " * String that specifies the URL of the image.",
          " */"
        ]
      ],
      "width": [
        "width: number;",
        [
          "/**",
          " * Variable: width",
          " *",
          " * Integer that specifies the width of the image.",
          " */"
        ]
      ],
      "height": [
        "height: number;",
        [
          "/**",
          " * Variable: height",
          " *",
          " * Integer that specifies the height of the image.",
          " */"
        ]
      ]
    }
  ],
  "mxUndoManager": [
    [
      "/**",
      " * @class mxUndoManager",
      " *",
      " * Implements a command history. When changing the graph model, an",
      " * {@link mxUndoableChange} object is created at the start of the transaction (when",
      " * model.beginUpdate is called). All atomic changes are then added to this",
      " * object until the last model.endUpdate call, at which point the",
      " * {@link mxUndoableEdit} is dispatched in an event, and added to the history inside",
      " * {@link mxUndoManager}. This is done by an event listener in",
      " * {@link mxEditor.installUndoHandler}.",
      " *",
      " * Each atomic change of the model is represented by an object (eg.",
      " * {@link mxRootChange}, {@link mxChildChange}, {@link mxTerminalChange} etc) which contains the",
      " * complete undo information. The {@link mxUndoManager} also listens to the",
      " * {@link mxGraphView} and stores it's changes to the current root as insignificant",
      " * undoable changes, so that drilling (step into, step up) is undone.",
      " *",
      " * This means when you execute an atomic change on the model, then change the",
      " * current root on the view and click undo, the change of the root will be",
      " * undone together with the change of the model so that the display represents",
      " * the state at which the model was changed. However, these changes are not",
      " * transmitted for sharing as they do not represent a state change.",
      " *",
      " * ### Example",
      " *",
      " * When adding an undo manager to a graph, make sure to add it",
      " * to the model and the view as well to maintain a consistent",
      " * display across multiple undo/redo steps.",
      " *",
      " * @example",
      " * ```javascript",
      " * var undoManager = new mxUndoManager();",
      " * var listener(sender, evt)",
      " * {",
      " *   undoManager.undoableEditHappened(evt.getProperty('edit'));",
      " * };",
      " * graph.getModel().addListener(mxEvent.UNDO, listener);",
      " * graph.getView().addListener(mxEvent.UNDO, listener);",
      " * ```",
      " *",
      " * The code creates a function that informs the undoManager",
      " * of an undoable edit and binds it to the undo event of",
      " * {@link mxGraphModel} and {@link mxGraphView} using",
      " * {@link mxEventSource.addListener}.",
      " *",
      " * ### Event: mxEvent.CLEAR",
      " *",
      " * Fires after {@link clear} was invoked. This event has no properties.",
      " *",
      " * ### Event: mxEvent.UNDO",
      " *",
      " * Fires afer a significant edit was undone in {@link undo}. The `edit`",
      " * property contains the {@link mxUndoableEdit} that was undone.",
      " *",
      " * ### Event: mxEvent.REDO",
      " *",
      " * Fires afer a significant edit was redone in {@link redo}. The `edit`",
      " * property contains the {@link mxUndoableEdit} that was redone.",
      " *",
      " * ### Event: mxEvent.ADD",
      " *",
      " * Fires after an undoable edit was added to the history. The `edit`",
      " * property contains the {@link mxUndoableEdit} that was added.",
      " */"
    ],
    {
      "constructor": [
        "constructor(size?: number);",
        [
          "/**",
          " * Constructs a new undo manager with the given history size. If no history",
          " * size is given, then a default size of 100 steps is used.",
          " * @param {number} [size] max history size",
          " */"
        ]
      ],
      "size": [
        "size: number;",
        [
          "/**",
          " * Maximum command history size. 0 means unlimited history. Default is",
          " * 100.",
          " * @default 100",
          " */"
        ]
      ],
      "history": [
        "history: Array<mxUndoableEdit>;",
        [
          "/**",
          " * Array that contains the steps of the command history.",
          " */"
        ]
      ],
      "indexOfNextAdd": [
        "indexOfNextAdd: number;",
        [
          "/**",
          " * Index of the element to be added next.",
          " */"
        ]
      ],
      "isEmpty": [
        "isEmpty(): boolean;",
        [
          "/**",
          " * Returns true if the history is empty.",
          " */"
        ]
      ],
      "clear": [
        "clear(): void;",
        [
          "/**",
          " * Clears the command history.",
          " */"
        ]
      ],
      "canUndo": [
        "canUndo(): boolean;",
        [
          "/**",
          " * Returns true if an undo is possible.",
          " */"
        ]
      ],
      "undo": [
        "undo(): void;",
        [
          "/**",
          " * Undoes the last change.",
          " */"
        ]
      ],
      "canRedo": [
        "canRedo(): boolean;",
        [
          "/**",
          " * Returns true if a redo is possible.",
          " */"
        ]
      ],
      "redo": [
        "redo(): void;",
        [
          "/**",
          " * Redoes the last change.",
          " */"
        ]
      ],
      "undoableEditHappened": [
        "undoableEditHappened(undoableEdit: mxUndoableEdit): void;",
        [
          "/**",
          " * Method to be called to add new undoable edits to the <history>.",
          " */"
        ]
      ],
      "trim": [
        "trim(): void;",
        [
          "/**",
          " * Removes all pending steps after <indexOfNextAdd> from the history,",
          " * invoking die on each edit. This is called from <undoableEditHappened>.",
          " */"
        ]
      ]
    }
  ],
  "mxSvgCanvas2D": [
    [
      "/**",
      " * Extends {@link mxAbstractCanvas2D} to implement a canvas for SVG. This canvas writes all calls as SVG output to the",
      " * given SVG root node.",
      " *",
      " * @example",
      " * ```javascript",
      " * var svgDoc = mxUtils.createXmlDocument();",
      " * var root = (svgDoc.createElementNS != null) ?",
      " * \t\tsvgDoc.createElementNS(mxConstants.NS_SVG, 'svg') : svgDoc.createElement('svg');",
      " *",
      " * if (svgDoc.createElementNS == null)",
      " * {",
      " *   root.setAttribute('xmlns', mxConstants.NS_SVG);",
      " *   root.setAttribute('xmlns:xlink', mxConstants.NS_XLINK);",
      " * }",
      " * else",
      " * {",
      " *   root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', mxConstants.NS_XLINK);",
      " * }",
      " *",
      " * var bounds = graph.getGraphBounds();",
      " * root.setAttribute('width', (bounds.x + bounds.width + 4) + 'px');",
      " * root.setAttribute('height', (bounds.y + bounds.height + 4) + 'px');",
      " * root.setAttribute('version', '1.1');",
      " *",
      " * svgDoc.appendChild(root);",
      " *",
      " * var svgCanvas = new mxSvgCanvas2D(root);",
      " * ```",
      " *",
      " *",
      " * To disable anti-aliasing in the output, use the following code.",
      " * @example",
      " * ```javascript",
      " * graph.view.canvas.ownerSVGElement.setAttribute('shape-rendering', 'crispEdges');",
      " * ```",
      " * Or set the respective attribute in the SVG element directly.",
      " */"
    ],
    {
      "constructor": [
        "constructor(root: Element, styleEnabled?: boolean);",
        [
          "/**",
          " * @param root          SVG container for the output",
          " * @param styleEnabled  Optional boolean that specifies if a style section should be added.",
          " *                      The style section sets the default font-size, font-family and stroke-miterlimit globally.",
          " *                      Default is `false`.",
          " */"
        ]
      ],
      "root": [
        "root: Element;",
        [
          "/**",
          " * Reference to the container for the SVG content.",
          " */"
        ]
      ],
      "gradients": [
        "gradients: Element[];",
        [
          "/**",
          " * Local cache of gradients for quick lookups.",
          " */"
        ]
      ],
      "defs": [
        "defs: Element;",
        [
          "/**",
          " * Reference to the defs section of the SVG document. Only for export.",
          " */"
        ]
      ],
      "styleEnabled": [
        "styleEnabled: boolean;",
        [
          "/**",
          " * Stores the value of styleEnabled passed to the constructor.",
          " * @default false",
          " */"
        ]
      ],
      "node": [
        "node: Element;",
        [
          "/**",
          " * Holds the current DOM node.",
          " */"
        ]
      ],
      "matchHtmlAlignment": [
        "matchHtmlAlignment: boolean;",
        [
          "/**",
          " * Specifies if plain text output should match the vertical HTML alignment.",
          " * @default true.",
          " */"
        ]
      ],
      "textEnabled": [
        "textEnabled: boolean;",
        [
          "/**",
          " * Specifies if text output should be enabled.",
          " * @default true",
          " */"
        ]
      ],
      "foEnabled": [
        "foEnabled: boolean;",
        [
          "/**",
          " * Specifies if use of foreignObject for HTML markup is allowed.",
          " * @default true",
          " */"
        ]
      ],
      "foAltText": [
        "foAltText: string;",
        [
          "/**",
          " * Specifies the fallback text for unsupported foreignObjects in exported documents.",
          " * If this is set to `null` then no fallback text is added to the exported document.",
          " * @default [Object]",
          " */"
        ]
      ],
      "foOffset": [
        "foOffset: number;",
        [
          "/**",
          " * Offset to be used for foreignObjects.",
          " * @default 0",
          " */"
        ]
      ],
      "textOffset": [
        "textOffset: number;",
        [
          "/**",
          " * Offset to be used for text elements.",
          " * @default 0",
          " */"
        ]
      ],
      "imageOffset": [
        "imageOffset: number;",
        [
          "/**",
          " * Offset to be used for image elements.",
          " * @default 0",
          " */"
        ]
      ],
      "strokeTolerance": [
        "strokeTolerance: number;",
        [
          "/**",
          " * Adds transparent paths for strokes.",
          " * @default 0",
          " */"
        ]
      ],
      "minStrokeWidth": [
        "minStrokeWidth: number;",
        [
          "/**",
          " * Minimum stroke width for output.",
          " * @default 1",
          " */"
        ]
      ],
      "refCount": [
        "refCount: number;",
        [
          "/**",
          " * Local counter for references in SVG export.",
          " * @default 0",
          " */"
        ]
      ],
      "lineHeightCorrection": [
        "lineHeightCorrection: number;",
        [
          "/**",
          " * Correction factor for {@link mxConstants.LINE_HEIGHT} in HTML output.",
          " * @default 1",
          " */"
        ]
      ],
      "pointerEventsValue": [
        "pointerEventsValue: string;",
        [
          "/**",
          " * Default value for active pointer events.",
          " * @default all",
          " */"
        ]
      ],
      "fontMetricsPadding": [
        "fontMetricsPadding: number;",
        [
          "/**",
          " * Padding to be added for text that is not wrapped to account for differences in font metrics on different platforms in pixels.",
          " * @default 10.",
          " */"
        ]
      ],
      "cacheOffsetSize": [
        "cacheOffsetSize: boolean;",
        [
          "/**",
          " * Specifies if offsetWidth and offsetHeight should be cached. This is used to speed up repaint of text in {@link updateText}.",
          " * @default true",
          " */"
        ]
      ],
      "format": [
        "format(value: string): number;",
        [
          "/**",
          " * Rounds all numbers to 2 decimal points.",
          " */"
        ]
      ],
      "getBaseUrl": [
        "getBaseUrl(): string;",
        [
          "/**",
          " * Returns the URL of the page without the hash part. This needs to use href to",
          " * include any search part with no params (ie question mark alone). This is a",
          " * workaround for the fact that window.location.search is empty if there is",
          " * no search string behind the question mark.",
          " */"
        ]
      ],
      "reset": [
        "reset(): void;",
        [
          "/**",
          " * Returns any offsets for rendering pixels.",
          " */"
        ]
      ],
      "createStyle": [
        "createStyle(x?: any): HTMLElement;",
        [
          "/**",
          " * Creates the optional style section.",
          " */"
        ]
      ],
      "createElement": [
        "createElement(tagName: string, namespace?: string): HTMLElement;",
        [
          "/**",
          " * Private helper function to create SVG elements",
          " */"
        ]
      ],
      ")": [
        "): void;",
        [
          "/**",
          " * Background color and border",
          " */"
        ]
      ],
      "createGradientId": [
        "createGradientId(start: string, end: string, alpha1: string, alpha2: string, direction: string): string;",
        [
          "/**",
          " * Private helper function to create SVG elements",
          " */"
        ]
      ],
      "getSvgGradient": [
        "getSvgGradient(start: string, end: string, alpha1: string, alpha2: string, direction: string): string;",
        [
          "/**",
          " * Private helper function to create SVG elements",
          " */"
        ]
      ],
      "createSvgGradient": [
        "createSvgGradient(start: string, end: string, alpha1: string, alpha2: string, direction: string): Element;",
        [
          "/**",
          " * Creates the given SVG gradient.",
          " */"
        ]
      ],
      "addNode": [
        "addNode(filled: boolean, stroked: boolean): void;",
        [
          "/**",
          " * Private helper function to create SVG elements",
          " */"
        ]
      ],
      "updateFill": [
        "updateFill(): void;",
        [
          "/**",
          " * Transfers the stroke attributes from <state> to <node>.",
          " */"
        ]
      ],
      "getCurrentStrokeWidth": [
        "getCurrentStrokeWidth(): number;",
        [
          "/**",
          " * Returns the current stroke width (>= 1), ie. max(1, this.format(this.state.strokeWidth * this.state.scale)).",
          " */"
        ]
      ],
      "updateStroke": [
        "updateStroke(): void;",
        [
          "/**",
          " * Transfers the stroke attributes from {@link mxAbstractCanvas2D.state} to {@link node}.",
          " */"
        ]
      ],
      "updateStrokeAttributes": [
        "updateStrokeAttributes(): void;",
        [
          "/**",
          " * Transfers the stroke attributes from {@link mxAbstractCanvas2D.state} to {@link node}.",
          " */"
        ]
      ],
      "createDashPattern": [
        "createDashPattern(scale: number): string;",
        [
          "/**",
          " * Creates the SVG dash pattern for the given state.",
          " */"
        ]
      ],
      "createTolerance": [
        "createTolerance(node: Element): Element;",
        [
          "/**",
          " * Creates a hit detection tolerance shape for the given node.",
          " */"
        ]
      ],
      "createShadow": [
        "createShadow(node: Element): Element;",
        [
          "/**",
          " * Creates a shadow for the given node.",
          " */"
        ]
      ],
      "setLink": [
        "setLink(link: string): void;",
        [
          "/**",
          " * Experimental implementation for hyperlinks.",
          " */"
        ]
      ],
      "rotate": [
        "rotate(theta: number, flipH: boolean, flipV: boolean, cx: number, cy: number): void;",
        [
          "/**",
          " * Sets the rotation of the canvas. Note that rotation cannot be concatenated.",
          " */"
        ]
      ],
      "begin": [
        "begin(): void;",
        [
          "/**",
          " * Extends superclass to create path.",
          " */"
        ]
      ],
      "rect": [
        "rect(x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Private helper function to create SVG elements",
          " */"
        ]
      ],
      "roundrect": [
        "roundrect(x: number, y: number, w: number, h: number, dx: number, dy: number): void;",
        [
          "/**",
          " * Private helper function to create SVG elements",
          " */"
        ]
      ],
      "ellipse": [
        "ellipse(x: number, y: number, w: number, h: number): void;",
        [
          "/**",
          " * Private helper function to create SVG elements",
          " */"
        ]
      ],
      "convertHtml": [
        "convertHtml(val: string): string;",
        [
          "/**",
          " * Converts the given HTML string to XHTML.",
          " */"
        ]
      ],
      "createDiv": [
        "createDiv(str: string): HTMLElement;",
        [
          "/**",
          " * Private helper function to create SVG elements",
          " * Note: signature changed in mxgraph 4.1.0",
          " */"
        ]
      ],
      "getTextCss": [
        "getTextCss(): string;",
        [
          "/**",
          " * Private helper function to create SVG elements",
          " */"
        ]
      ],
      "createClip": [
        "createClip(x: number, y: number, w: number, h: number): Element;",
        [
          "/**",
          " * Creates a clip for the given coordinates.",
          " */"
        ]
      ],
      "updateFont": [
        "updateFont(node: Element): void;",
        [
          "/**",
          " * Updates the text properties for the given node. (NOTE: For this to work in",
          " * IE, the given node must be a text or tspan element.)",
          " */"
        ]
      ],
      "stroke": [
        "stroke(): void;",
        [
          "/**",
          " * Paints the outline of the current path.",
          " */"
        ]
      ],
      "fill": [
        "fill(): void;",
        [
          "/**",
          " * Fills the current path.",
          " */"
        ]
      ],
      "fillAndStroke": [
        "fillAndStroke(): void;",
        [
          "/**",
          " * Fills and paints the outline of the current path.",
          " */"
        ]
      ]
    }
  ],
  "mxEffects": [
    [
      "/**",
      " * Provides animation effects.",
      " *",
      " * @class mxEffects",
      " */"
    ],
    {
      "static animateChanges": [
        "static animateChanges(graph: mxGraph, changes: Array<any>, done?: Function): void;",
        [
          "/**",
          " * Asynchronous animated move operation. See also: <mxMorphing>.",
          " *",
          " * @example",
          " * ```javascript",
          " * graph.model.addListener(mxEvent.CHANGE, function(sender, evt)",
          " * {",
          " *   var changes = evt.getProperty('edit').changes;",
          " *",
          " *   if (changes.length < 10)",
          " *   {",
          " *     mxEffects.animateChanges(graph, changes);",
          " *   }",
          " * });",
          " * ```",
          " *",
          " * @param graph - <mxGraph> that received the changes.",
          " * @param changes - Array of changes to be animated.",
          " * @param done - Optional function argument that is invoked after the",
          " * last step of the animation.",
          " */"
        ]
      ],
      "static cascadeOpacity": [
        "static cascadeOpacity(graph: mxGraph, cell: mxCell, opacity: number): void;",
        [
          "/**",
          " * Sets the opacity on the given cell and its descendants.",
          " *",
          " * @param graph - <mxGraph> that contains the cells.",
          " * @param cell - <mxCell> to set the opacity for.",
          " * @param opacity - New value for the opacity in %.",
          " */"
        ]
      ],
      ")": [
        "): void;",
        [
          "/**",
          " * Asynchronous fade-out operation.",
          " */"
        ]
      ]
    }
  ],
  "mxGeometry": [
    [
      "/**",
      " * @class mxGeometry",
      " *",
      " * @extends {mxRectangle}",
      " *",
      " * For vertices, the geometry consists of the x- and y-location, and the width",
      " * and height. For edges, the geometry consists of the optional terminal- and",
      " * control points. The terminal points are only required if an edge is",
      " * unconnected, and are stored in the {@link sourcePoint} and {@link targetPoint}",
      " * variables, respectively.",
      " *",
      " * ### Example",
      " *",
      " * If an edge is unconnected, that is, it has no source or target terminal,",
      " * then a geometry with terminal points for a new edge can be defined as",
      " * follows.",
      " *",
      " * ```javascript",
      " * geometry.setTerminalPoint(new mxPoint(x1, y1), true);",
      " * geometry.points: [new mxPoint(x2, y2)];",
      " * geometry.setTerminalPoint(new mxPoint(x3, y3), false);",
      " * ```",
      " *",
      " * Control points are used regardless of the connected state of an edge and may",
      " * be ignored or interpreted differently depending on the edge's {@link mxEdgeStyle}.",
      " *",
      " * To disable automatic reset of control points after a cell has been moved or",
      " * resized, the the {@link mxGraph.resizeEdgesOnMove} and",
      " * {@link mxGraph.resetEdgesOnResize} may be used.",
      " *",
      " * ### Edge Labels",
      " *",
      " * Using the x- and y-coordinates of a cell's geometry, it is possible to",
      " * position the label on edges on a specific location on the actual edge shape",
      " * as it appears on the screen. The x-coordinate of an edge's geometry is used",
      " * to describe the distance from the center of the edge from -1 to 1 with 0",
      " * being the center of the edge and the default value. The y-coordinate of an",
      " * edge's geometry is used to describe the absolute, orthogonal distance in",
      " * pixels from that point. In addition, the {@link mxGeometry.offset} is used as an",
      " * absolute offset vector from the resulting point.",
      " *",
      " * This coordinate system is applied if {@link relative} is true, otherwise the",
      " * offset defines the absolute vector from the edge's center point to the",
      " * label and the values for {@link x} and {@link y} are ignored.",
      " *",
      " * The width and height parameter for edge geometries can be used to set the",
      " * label width and height (eg. for word wrapping).",
      " *",
      " * ### Ports",
      " *",
      " * The term \"port\" refers to a relatively positioned, connectable child cell,",
      " * which is used to specify the connection between the parent and another cell",
      " * in the graph. Ports are typically modeled as vertices with relative",
      " * geometries.",
      " *",
      " * ### Offsets",
      " *",
      " * The {@link offset} field is interpreted in 3 different ways, depending on the cell",
      " * and the geometry. For edges, the offset defines the absolute offset for the",
      " * edge label. For relative geometries, the offset defines the absolute offset",
      " * for the origin (top, left corner) of the vertex, otherwise the offset",
      " * defines the absolute offset for the label inside the vertex or group.",
      " */"
    ],
    {
      "constructor": [
        "constructor(x?: number, y?: number, width?: number, height?: number);",
        null
      ],
      "TRANSLATE_CONTROL_POINTS": [
        "TRANSLATE_CONTROL_POINTS: boolean;",
        [
          "/**",
          " * Global switch to translate the points in translate. Default is true.",
          " */"
        ]
      ],
      "alternateBounds": [
        "alternateBounds: mxRectangle;",
        [
          "/**",
          " * Stores alternate values for x, y, width and height in a rectangle.",
          " * See {@link swap} to exchange the values. Default is null.",
          " *",
          " * @see {@link swap}",
          " */"
        ]
      ],
      "sourcePoint": [
        "sourcePoint: mxPoint;",
        [
          "/**",
          " * Defines the source {@link mxPoint} of the edge. This is used if the",
          " * corresponding edge does not have a source vertex. Otherwise it is",
          " * ignored. Default is  null.",
          " */"
        ]
      ],
      "targetPoint": [
        "targetPoint: mxPoint;",
        [
          "/**",
          " * Defines the target {@link mxPoint} of the edge. This is used if the",
          " * corresponding edge does not have a target vertex. Otherwise it is",
          " * ignored. Default is null.",
          " */"
        ]
      ],
      "points": [
        "points: Array<mxPoint>;",
        [
          "/**",
          " * Array of {@link mxPoints} which specifies the control points along the edge.",
          " * These points are the intermediate points on the edge, for the endpoints",
          " * use {@link targetPoint} and {@link sourcePoint} or set the terminals of the edge to",
          " * a non-null value. Default is null.",
          " */"
        ]
      ],
      "offset": [
        "offset: mxPoint;",
        [
          "/**",
          " * For edges, this holds the offset (in pixels) from the position defined",
          " * by {@link x} and {@link y} on the edge. For relative geometries (for vertices), this",
          " * defines the absolute offset from the point defined by the relative",
          " * coordinates. For absolute geometries (for vertices), this defines the",
          " * offset for the label. Default is null.",
          " */"
        ]
      ],
      "relative": [
        "relative: boolean;",
        [
          "/**",
          " * Specifies if the coordinates in the geometry are to be interpreted as",
          " * relative coordinates. For edges, this is used to define the location of",
          " * the edge label relative to the edge as rendered on the display. For",
          " * vertices, this specifies the relative location inside the bounds of the",
          " * parent cell.",
          " *",
          " * If this is false, then the coordinates are relative to the origin of the",
          " * parent cell or, for edges, the edge label position is relative to the",
          " * center of the edge as rendered on screen.",
          " *",
          " * Default is false.",
          " */"
        ]
      ],
      "setRelative": [
        "setRelative(relative: boolean): void;",
        [
          "/**",
          " * Specifies if the coordinates in the geometry are to be interpreted as",
          " * relative coordinates. For edges, this is used to define the location of",
          " * the edge label relative to the edge as rendered on the display. For",
          " * vertices, this specifies the relative location inside the bounds of the",
          " * parent cell.",
          " *",
          " * If this is false, then the coordinates are relative to the origin of the",
          " * parent cell or, for edges, the edge label position is relative to the",
          " * center of the edge as rendered on screen.",
          " *",
          " * Default is false.",
          " */"
        ]
      ],
      "swap": [
        "swap(): void;",
        [
          "/**",
          " * Swaps the x, y, width and height with the values stored in",
          " * {@link alternateBounds} and puts the previous values into {@link alternateBounds} as",
          " * a rectangle. This operation is carried-out in-place, that is, using the",
          " * existing geometry instance. If this operation is called during a graph",
          " * model transactional change, then the geometry should be cloned before",
          " * calling this method and setting the geometry of the cell using",
          " * {@link mxGraphModel.setGeometry}.",
          " */"
        ]
      ],
      "getTerminalPoint": [
        "getTerminalPoint(isSource: boolean): mxPoint;",
        [
          "/**",
          " * Returns the {@link mxPoint} representing the source or target point of this",
          " * edge. This is only used if the edge has no source or target vertex.",
          " *",
          " * @param {Boolean} isSource that specifies if the source or target point should be returned.",
          " */"
        ]
      ],
      "setTerminalPoint": [
        "setTerminalPoint(point: mxPoint, isSource: boolean): mxPoint;",
        [
          "/**",
          " * Sets the {@link sourcePoint} or {@link targetPoint} to the given {@link mxPoint} and",
          " * returns the new point.",
          " *",
          " * @param {Point} point to be used as the new source or target point.",
          " * @param {Boolean} isSource that specifies if the source or target point should be set.",
          " */"
        ]
      ],
      "rotate": [
        "rotate(angle: number, cx: mxPoint): void;",
        [
          "/**",
          " * Rotates the geometry by the given angle around the given center. That is,",
          " * {@link x} and {@link y} of the geometry, the {@link sourcePoint}, {@link targetPoint} and all",
          " * {@link points} are translated by the given amount. {@link x} and {@link y} are only",
          " * translated if {@link relative} is false.",
          " *",
          " * @param {Number} angle that specifies the rotation angle in degrees.",
          " * @param {mxPoint} cx   that specifies the center of the rotation.",
          " */"
        ]
      ],
      "translate": [
        "translate(dx: number, dy: number): void;",
        [
          "/**",
          " * Translates the geometry by the specified amount. That is, {@link x} and {@link y} of the",
          " * geometry, the {@link sourcePoint}, {@link targetPoint} and all {@link points} are translated",
          " * by the given amount. {@link x} and {@link y} are only translated if {@link relative} is false.",
          " * If {@link TRANSLATE_CONTROL_POINTS} is false, then {@link points} are not modified by",
          " * this function.",
          " *",
          " * @param {Number} dx that specifies the x-coordinate of the translation.",
          " * @param {Number} dy that specifies the y-coordinate of the translation.",
          " */"
        ]
      ],
      "scale": [
        "scale(sx: number, sy: number, fixedAspect: boolean): void;",
        [
          "/**",
          " * Scales the geometry by the given amount. That is, {@link x} and {@link y} of the",
          " * geometry, the {@link sourcePoint}, {@link targetPoint} and all {@link points} are scaled",
          " * by the given amount. {@link x}, {@link y}, {@link width} and {@link height} are only scaled if",
          " * {@link relative} is false. If {@link fixedAspect} is true, then the smaller value",
          " * is used to scale the width and the height.",
          " *",
          " * @param {Number} sx that specifies the horizontal scale factor.",
          " * @param {Number} sy that specifies the vertical scale factor.",
          " * @param {Optional} fixedAspect boolean to keep the aspect ratio fixed.",
          " */"
        ]
      ],
      "equals": [
        "equals(obj: mxGeometry): boolean;",
        [
          "/**",
          " * Returns true if the given object equals this geometry.",
          " */"
        ]
      ],
      "clone": [
        "clone(): mxGeometry;",
        [
          "/**",
          " * Returns true if the given object equals this geometry.",
          " */"
        ]
      ]
    }
  ],
  "mxCellPath": [
    [
      "/**",
      " * Implements a mechanism for temporary cell Ids.",
      " * @class mxCellPath",
      " */"
    ],
    {
      "static PATH_SEPARATOR": [
        "static PATH_SEPARATOR: string;",
        [
          "/**",
          " * Defines the separator between the path components. Default is \".\".",
          " */"
        ]
      ],
      "static create": [
        "static create(cell: mxCell): string;",
        [
          "/**",
          " * Creates the cell path for the given cell. The cell path is a",
          " * concatenation of the indices of all ancestors on the (finite) path to",
          " * the root, eg. \"0.0.0.1\".",
          " *",
          " * Parameters:",
          " *",
          " * cell - Cell whose path should be returned.",
          " */"
        ]
      ],
      "static getParentPath": [
        "static getParentPath(path: string): string;",
        [
          "/**",
          " * Returns the path for the parent of the cell represented by the given",
          " * path. Returns null if the given path has no parent.",
          " *",
          " * Parameters:",
          " *",
          " * path - Path whose parent path should be returned.",
          " */"
        ]
      ],
      "static resolve": [
        "static resolve(root: string, path: string): string;",
        [
          "/**",
          " * Returns the cell for the specified cell path using the given root as the",
          " * root of the path.",
          " *",
          " * Parameters:",
          " *",
          " * root - Root cell of the path to be resolved.",
          " * path - String that defines the path.",
          " */"
        ]
      ],
      "static compare": [
        "static compare(p1: string, p2: string): number;",
        [
          "/**",
          " * Compares the given cell paths and returns -1 if p1 is smaller, 0 if",
          " * p1 is equal and 1 if p1 is greater than p2.",
          " */"
        ]
      ]
    }
  ],
  "mxGraphModel": [
    [
      "/**",
      " * Extends {@link mxEventSource} to implement a graph model. The graph model acts as",
      " * a wrapper around the cells which are in charge of storing the actual graph",
      " * datastructure. The model acts as a transactional wrapper with event",
      " * notification for all changes, whereas the cells contain the atomic",
      " * operations for updating the actual datastructure.",
      " *",
      " * ### Layers",
      " *",
      " * The cell hierarchy in the model must have a top-level root cell which",
      " * contains the layers (typically one default layer), which in turn contain the",
      " * top-level cells of the layers. This means each cell is contained in a layer.",
      " * If no layers are required, then all new cells should be added to the default",
      " * layer.",
      " *",
      " * Layers are useful for hiding and showing groups of cells, or for placing",
      " * groups of cells on top of other cells in the display. To identify a layer,",
      " * the {@link isLayer} function is used. It returns true if the parent of the given",
      " * cell is the root of the model.",
      " *",
      " * ### Events",
      " *",
      " * See events section for more details. There is a new set of events for",
      " * tracking transactional changes as they happen. The events are called",
      " * startEdit for the initial beginUpdate, executed for each executed change",
      " * and endEdit for the terminal endUpdate. The executed event contains a",
      " * property called change which represents the change after execution.",
      " *",
      " * ### Encoding the model",
      " *",
      " * #### To encode a graph model, use the following code:",
      " *",
      " * ```javascript",
      " * var enc = new mxCodec();",
      " * var node = enc.encode(graph.getModel());",
      " * ```",
      " *",
      " * This will create an XML node that contains all the model information.",
      " *",
      " * #### Encoding and decoding changes:",
      " *",
      " * For the encoding of changes, a graph model listener is required that encodes",
      " * each change from the given array of changes.",
      " *",
      " * ```javascript",
      " * model.addListener(mxEvent.CHANGE, function(sender, evt)",
      " * {",
      " *   var changes = evt.getProperty('edit').changes;",
      " *   var nodes = [];",
      " *   var codec = new mxCodec();",
      " *",
      " *   for (var i = 0; i < changes.length; i++)",
      " *   {",
      " *     nodes.push(codec.encode(changes[i]));",
      " *   }",
      " *   // do something with the nodes",
      " * });",
      " * ```",
      " *",
      " * For the decoding and execution of changes, the codec needs a lookup function",
      " * that allows it to resolve cell IDs as follows:",
      " *",
      " * ```javascript",
      " * var codec = new mxCodec();",
      " * codec.lookup(id)",
      " * {",
      " *   return model.getCell(id);",
      " * }",
      " * ```",
      " *",
      " * For each encoded change (represented by a node), the following code can be",
      " * used to carry out the decoding and create a change object.",
      " *",
      " * ```javascript",
      " * var changes = [];",
      " * var change = codec.decode(node);",
      " * change.model = model;",
      " * change.execute();",
      " * changes.push(change);",
      " * ```",
      " *",
      " * The changes can then be dispatched using the model as follows.",
      " *",
      " * ```javascript",
      " * var edit = new mxUndoableEdit(model, false);",
      " * edit.changes = changes;",
      " *",
      " * edit.notify()",
      " * {",
      " *   edit.source.fireEvent(new mxEventObject(mxEvent.CHANGE,",
      " *   \t'edit', edit, 'changes', edit.changes));",
      " *   edit.source.fireEvent(new mxEventObject(mxEvent.NOTIFY,",
      " *   \t'edit', edit, 'changes', edit.changes));",
      " * }",
      " *",
      " * model.fireEvent(new mxEventObject(mxEvent.UNDO, 'edit', edit));",
      " * model.fireEvent(new mxEventObject(mxEvent.CHANGE,",
      " *    'edit', edit, 'changes', changes));",
      " * ```",
      " *",
      " * Event: mxEvent.CHANGE",
      " *",
      " * Fires when an undoable edit is dispatched. The `edit` property",
      " * contains the {@link mxUndoableEdit}. The `changes` property contains",
      " * the array of atomic changes inside the undoable edit. The changes property",
      " * is **deprecated**, please use edit.changes instead.",
      " *",
      " * ### Example",
      " *",
      " * For finding newly inserted cells, the following code can be used:",
      " *",
      " * ```javascript",
      " * graph.model.addListener(mxEvent.CHANGE, function(sender, evt)",
      " * {",
      " *   var changes = evt.getProperty('edit').changes;",
      " *",
      " *   for (var i = 0; i < changes.length; i++)",
      " *   {",
      " *     var change = changes[i];",
      " *",
      " *     if (change instanceof mxChildChange &&",
      " *       change.change.previous == null)",
      " *     {",
      " *       graph.startEditingAtCell(change.child);",
      " *       break;",
      " *     }",
      " *   }",
      " * });",
      " * ```",
      " *",
      " * Event: mxEvent.NOTIFY",
      " *",
      " * Same as <mxEvent.CHANGE>, this event can be used for classes that need to",
      " * implement a sync mechanism between this model and, say, a remote model. In",
      " * such a setup, only local changes should trigger a notify event and all",
      " * changes should trigger a change event.",
      " *",
      " * Event: mxEvent.EXECUTE",
      " *",
      " * Fires between begin- and endUpdate and after an atomic change was executed",
      " * in the model. The `change` property contains the atomic change",
      " * that was executed.",
      " *",
      " * Event: mxEvent.EXECUTED",
      " *",
      " * Fires between START_EDIT and END_EDIT after an atomic change was executed.",
      " * The `change` property contains the change that was executed.",
      " *",
      " * Event: mxEvent.BEGIN_UPDATE",
      " *",
      " * Fires after the {@link updateLevel} was incremented in {@link beginUpdate}. This event",
      " * contains no properties.",
      " *",
      " * Event: mxEvent.START_EDIT",
      " *",
      " * Fires after the {@link updateLevel} was changed from 0 to 1. This event",
      " * contains no properties.",
      " *",
      " * Event: mxEvent.END_UPDATE",
      " *",
      " * Fires after the {@link updateLevel} was decreased in {@link endUpdate} but before any",
      " * notification or change dispatching. The `edit` property contains",
      " * the {@link currentEdit}.",
      " *",
      " * Event: mxEvent.END_EDIT",
      " *",
      " * Fires after the {@link updateLevel} was changed from 1 to 0. This event",
      " * contains no properties.",
      " *",
      " * Event: mxEvent.BEFORE_UNDO",
      " *",
      " * Fires before the change is dispatched after the update level has reached 0",
      " * in {@link endUpdate}. The `edit` property contains the {@link curreneEdit}.",
      " *",
      " * Event: mxEvent.UNDO",
      " *",
      " * Fires after the change was dispatched in {@link endUpdate}. The `edit`",
      " * property contains the {@link currentEdit}.",
      " *",
      " * @class mxGraphModel",
      " */"
    ],
    {
      "constructor": [
        "constructor(root: mxCell);",
        null
      ],
      "root": [
        "root: mxCell;",
        [
          "/**",
          " * Holds the root cell, which in turn contains the cells that represent the",
          " * layers of the diagram as child cells. That is, the actual elements of the",
          " * diagram are supposed to live in the third generation of cells and below.",
          " */"
        ]
      ],
      "cells": [
        "cells: any;",
        [
          "/**",
          " * Maps from Ids to cells.",
          " */"
        ]
      ],
      "maintainEdgeParent": [
        "maintainEdgeParent: boolean;",
        [
          "/**",
          " * Specifies if edges should automatically be moved into the nearest common",
          " * ancestor of their terminals. Default is true.",
          " */"
        ]
      ],
      "ignoreRelativeEdgeParent": [
        "ignoreRelativeEdgeParent: boolean;",
        [
          "/**",
          " * Specifies if relative edge parents should be ignored for finding the nearest",
          " * common ancestors of an edge's terminals. Default is true.",
          " */"
        ]
      ],
      "createIds": [
        "createIds: boolean;",
        [
          "/**",
          " * Specifies if the model should automatically create Ids for new cells.",
          " * Default is true.",
          " */"
        ]
      ],
      "prefix": [
        "prefix: string;",
        [
          "/**",
          " * Defines the prefix of new Ids. Default is an empty string.",
          " */"
        ]
      ],
      "postfix": [
        "postfix: string;",
        [
          "/**",
          " * Defines the postfix of new Ids. Default is an empty string.",
          " */"
        ]
      ],
      "nextId": [
        "nextId: number | string;",
        [
          "/**",
          " * Specifies the next Id to be created. Initial value is 0.",
          " */"
        ]
      ],
      "currentEdit": [
        "currentEdit: any;",
        [
          "/**",
          " * Holds the changes for the current transaction. If the transaction is",
          " * closed then a new object is created for this variable using",
          " * {@link createUndoableEdit}.",
          " */"
        ]
      ],
      "updateLevel": [
        "updateLevel: number;",
        [
          "/**",
          " * Counter for the depth of nested transactions. Each call to {@link beginUpdate}",
          " * will increment this number and each call to {@link endUpdate} will decrement",
          " * it. When the counter reaches 0, the transaction is closed and the",
          " * respective events are fired. Initial value is 0.",
          " */"
        ]
      ],
      "endingUpdate": [
        "endingUpdate: boolean;",
        [
          "/**",
          " * True if the program flow is currently inside endUpdate.",
          " */"
        ]
      ],
      "clear": [
        "clear(): void;",
        [
          "/**",
          " * Sets a new root using {@link createRoot}.",
          " */"
        ]
      ],
      "isCreateIds": [
        "isCreateIds(): boolean;",
        [
          "/**",
          " * Returns {@link createIds}.",
          " */"
        ]
      ],
      "setCreateIds": [
        "setCreateIds(value: boolean): void;",
        [
          "/**",
          " * Sets {@link createIds}.",
          " */"
        ]
      ],
      "createRoot": [
        "createRoot(): mxCell;",
        [
          "/**",
          " * Creates a new root cell with a default layer (child 0).",
          " */"
        ]
      ],
      "getCell": [
        "getCell(id: string): mxCell;",
        [
          "/**",
          " * Returns the {@link mxCell} for the specified Id or null if no cell can be",
          " * found for the given Id.",
          " *",
          " * @param {string} id  A string representing the Id of the cell.",
          " */"
        ]
      ],
      "filterCells": [
        "filterCells(cells: Array<mxCell>, filter: (...args: any) => boolean): Array<mxCell>;",
        [
          "/**",
          " * Returns the cells from the given array where the given filter function",
          " * returns true.",
          " */"
        ]
      ],
      "getDescendants": [
        "getDescendants(parent: mxCell): Array<mxCell>;",
        [
          "/**",
          " * Returns all descendants of the given cell and the cell itself in an array.",
          " *",
          " * @param {mxCell} parent  whose descendants should be returned.",
          " */"
        ]
      ],
      "filterDescendants": [
        "filterDescendants(filter: (...args: any) => boolean, parent?: mxCell): Array<mxCell>;",
        [
          "/**",
          " * Visits all cells recursively and applies the specified filter function",
          " * to each cell. If the function returns true then the cell is added",
          " * to the resulting array. The parent and result paramters are optional.",
          " * If parent is not specified then the recursion starts at {@link root}.",
          " *",
          " * Example:",
          " * The following example extracts all vertices from a given model:",
          " * ```javascript",
          " * var filter(cell)",
          " * {",
          " * \treturn model.isVertex(cell);",
          " * }",
          " * var vertices = model.filterDescendants(filter);",
          " * ```",
          " *",
          " * @param filter  JavaScript function that takes an {@link mxCell} as an argument",
          " * and returns a boolean.",
          " * @param parent  Optional {@link mxCell} that is used as the root of the recursion.",
          " */"
        ]
      ],
      "getRoot": [
        "getRoot(cell?: mxCell): mxCell;",
        [
          "/**",
          " * Returns the root of the model or the topmost parent of the given cell.",
          " *",
          " * @param cell  Optional {@link mxCell} that specifies the child.",
          " */"
        ]
      ],
      "setRoot": [
        "setRoot(root: mxCell): mxCell;",
        [
          "/**",
          " * Sets the {@link root} of the model using {@link mxRootChange} and adds the change to",
          " * the current transaction. This resets all datastructures in the model and",
          " * is the preferred way of clearing an existing model. Returns the new",
          " * root.",
          " *",
          " * Example:",
          " *",
          " * ```javascript",
          " * var root = new mxCell();",
          " * root.insert(new mxCell());",
          " * model.setRoot(root);",
          " * ```",
          " *",
          " * @param {mxCell} root  that specifies the new root.",
          " */"
        ]
      ],
      "rootChanged": [
        "rootChanged(root: mxCell): mxCell;",
        [
          "/**",
          " * Inner callback to change the root of the model and update the internal",
          " * datastructures, such as {@link cells} and {@link nextId}. Returns the previous root.",
          " *",
          " * @param {mxCell} root  that specifies the new root.",
          " */"
        ]
      ],
      "isRoot": [
        "isRoot(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is the root of the model and a non-null",
          " * value.",
          " *",
          " * @param {mxCell} cell  that represents the possible root.",
          " */"
        ]
      ],
      "isLayer": [
        "isLayer(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if {@link isRoot} returns true for the parent of the given cell.",
          " *",
          " * @param {mxCell} cell  that represents the possible layer.",
          " */"
        ]
      ],
      "isAncestor": [
        "isAncestor(parent: mxCell, child: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given parent is an ancestor of the given child. Note",
          " * returns true if child == parent.",
          " *",
          " * @param {mxCell} parent  that specifies the parent.",
          " * @param {mxCell} child  that specifies the child.",
          " */"
        ]
      ],
      "contains": [
        "contains(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the model contains the given {@link mxCell}.",
          " *",
          " * @param {mxCell} cell  that specifies the cell.",
          " */"
        ]
      ],
      "getParent": [
        "getParent(cell: mxCell): mxCell;",
        [
          "/**",
          " * Returns the parent of the given cell.",
          " *",
          " * @param {mxCell} cell  whose parent should be returned.",
          " */"
        ]
      ],
      "add": [
        "add(parent: mxCell, child: mxCell, index?: number): mxCell;",
        [
          "/**",
          " * Adds the specified child to the parent at the given index using",
          " * {@link mxChildChange} and adds the change to the current transaction. If no",
          " * index is specified then the child is appended to the parent's array of",
          " * children. Returns the inserted child.",
          " *",
          " * @param {mxCell} parent  that specifies the parent to contain the child.",
          " * @param {mxCell} child  that specifies the child to be inserted.",
          " * @param index  Optional integer that specifies the index of the child.",
          " */"
        ]
      ],
      "cellAdded": [
        "cellAdded(cell: mxCell): void;",
        [
          "/**",
          " * Inner callback to update {@link cells} when a cell has been added. This",
          " * implementation resolves collisions by creating new Ids. To change the",
          " * ID of a cell after it was inserted into the model, use the following",
          " * code:",
          " *",
          " * (code",
          " * delete model.cells[cell.getId()];",
          " * cell.setId(newId);",
          " * model.cells[cell.getId()] = cell;",
          " * ```",
          " *",
          " * If the change of the ID should be part of the command history, then the",
          " * cell should be removed from the model and a clone with the new ID should",
          " * be reinserted into the model instead.",
          " *",
          " * @param {mxCell} cell  that specifies the cell that has been added.",
          " */"
        ]
      ],
      "createId": [
        "createId(cell: mxCell): string;",
        [
          "/**",
          " * Hook method to create an Id for the specified cell. This implementation",
          " * concatenates {@link prefix}, id and {@link postfix} to create the Id and increments",
          " * {@link nextId}. The cell is ignored by this implementation, but can be used in",
          " * overridden methods to prefix the Ids with eg. the cell type.",
          " *",
          " * @param {mxCell} cell  to create the Id for.",
          " */"
        ]
      ],
      "updateEdgeParents": [
        "updateEdgeParents(cell: mxCell, root: mxCell): void;",
        [
          "/**",
          " * Updates the parent for all edges that are connected to cell or one of",
          " * its descendants using {@link updateEdgeParent}.",
          " */"
        ]
      ],
      "updateEdgeParent": [
        "updateEdgeParent(edge: mxCell, root: mxCell): void;",
        [
          "/**",
          " * Inner callback to update the parent of the specified {@link mxCell} to the",
          " * nearest-common-ancestor of its two terminals.",
          " *",
          " * @param {mxCell} edge  that specifies the edge.",
          " * @param {mxCell} root  that represents the current root of the model.",
          " */"
        ]
      ],
      "getOrigin": [
        "getOrigin(cell: mxCell): mxPoint;",
        [
          "/**",
          " * Returns the absolute, accumulated origin for the children inside the",
          " * given parent as an {@link mxPoint}.",
          " */"
        ]
      ],
      "getNearestCommonAncestor": [
        "getNearestCommonAncestor(cell1: mxCell, cell2: mxCell): mxCell;",
        [
          "/**",
          " * Returns the nearest common ancestor for the specified cells.",
          " *",
          " * @param {mxCell} cell1  that specifies the first cell in the tree.",
          " * @param {mxCell} cell2  that specifies the second cell in the tree.",
          " */"
        ]
      ],
      "remove": [
        "remove(cell: mxCell): mxCell;",
        [
          "/**",
          " * Removes the specified cell from the model using {@link mxChildChange} and adds",
          " * the change to the current transaction. This operation will remove the",
          " * cell and all of its children from the model. Returns the removed cell.",
          " *",
          " * @param {mxCell} cell  that should be removed.",
          " */"
        ]
      ],
      "cellRemoved": [
        "cellRemoved(cell: mxCell): void;",
        [
          "/**",
          " * Inner callback to update {@link cells} when a cell has been removed.",
          " *",
          " * @param {mxCell} cell  that specifies the cell that has been removed.",
          " */"
        ]
      ],
      "parentForCellChanged": [
        "parentForCellChanged(cell: mxCell, parent: mxCell, index: number): mxCell;",
        [
          "/**",
          " * Inner callback to update the parent of a cell using <mxCell.insert>",
          " * on the parent and return the previous parent.",
          " *",
          " * @param {mxCell} cell  to update the parent for.",
          " * @param {mxCell} parent  that specifies the new parent of the cell.",
          " * @param index  Optional integer that defines the index of the child",
          " * in the parent's child array.",
          " */"
        ]
      ],
      "getChildCount": [
        "getChildCount(cell?: mxCell): number;",
        [
          "/**",
          " * Returns the number of children in the given cell.",
          " *",
          " * @param {mxCell} cell  whose number of children should be returned.",
          " */"
        ]
      ],
      "getChildAt": [
        "getChildAt(cell: mxCell, index: number): mxCell;",
        [
          "/**",
          " * Returns the child of the given {@link mxCell} at the given index.",
          " *",
          " * @param {mxCell} cell  that represents the parent.",
          " * @param index  Integer that specifies the index of the child to be returned.",
          " */"
        ]
      ],
      "getChildren": [
        "getChildren(cell: mxCell): Array<mxCell>;",
        [
          "/**",
          " * Returns all children of the given {@link mxCell} as an array of {@link mxCell}. The",
          " * return value should be only be read.",
          " *",
          " * @param {mxCell} cell  the represents the parent.",
          " */"
        ]
      ],
      "getChildVertices": [
        "getChildVertices(parent: mxCell): Array<mxCell>;",
        [
          "/**",
          " * Returns the child vertices of the given parent.",
          " *",
          " * @param {mxCell} cell  whose child vertices should be returned.",
          " */"
        ]
      ],
      "getChildEdges": [
        "getChildEdges(parent: mxCell): Array<mxCell>;",
        [
          "/**",
          " * Returns the child edges of the given parent.",
          " *",
          " * @param {mxCell} cell  whose child edges should be returned.",
          " */"
        ]
      ],
      "getChildCells": [
        "getChildCells(parent: mxCell, vertices: boolean, edges: boolean): Array<mxCell>;",
        [
          "/**",
          " * Returns the children of the given cell that are vertices and/or edges",
          " * depending on the arguments.",
          " *",
          " * @param {mxCell} cell  the represents the parent.",
          " * @param vertices  Boolean indicating if child vertices should be returned.",
          " * Default is false.",
          " * @param edges  Boolean indicating if child edges should be returned.",
          " * Default is false.",
          " */"
        ]
      ],
      "getTerminal": [
        "getTerminal(edge: mxCell, isSource: boolean): mxCell;",
        [
          "/**",
          " * Returns the source or target {@link mxCell} of the given edge depending on the",
          " * value of the boolean parameter.",
          " *",
          " * @param {mxCell} edge  that specifies the edge.",
          " * @param isSource  Boolean indicating which end of the edge should be returned.",
          " */"
        ]
      ],
      "setTerminal": [
        "setTerminal(edge: mxCell, terminal: mxCell, isSource: boolean): mxCell;",
        [
          "/**",
          " * Sets the source or target terminal of the given {@link mxCell} using",
          " * {@link mxTerminalChange} and adds the change to the current transaction.",
          " * This implementation updates the parent of the edge using {@link updateEdgeParent}",
          " * if required.",
          " *",
          " * @param {mxCell} edge  that specifies the edge.",
          " * @param {mxCell} terminal  that specifies the new terminal.",
          " * @param isSource  Boolean indicating if the terminal is the new source or",
          " * target terminal of the edge.",
          " */"
        ]
      ],
      "setTerminals": [
        "setTerminals(edge: mxCell, source: mxCell, target: mxCell): void;",
        [
          "/**",
          " * Sets the source and target {@link mxCell} of the given {@link mxCell} in a single",
          " * transaction using {@link setTerminal} for each end of the edge.",
          " *",
          " * @param {mxCell} edge  that specifies the edge.",
          " * @param {mxCell} source  that specifies the new source terminal.",
          " * @param {mxCell} target  that specifies the new target terminal.",
          " */"
        ]
      ],
      "terminalForCellChanged": [
        "terminalForCellChanged(edge: mxCell, terminal: mxCell, isSource: boolean): mxCell;",
        [
          "/**",
          " * Inner helper function to update the terminal of the edge using",
          " * <mxCell.insertEdge> and return the previous terminal.",
          " *",
          " * @param {mxCell} edge  that specifies the edge to be updated.",
          " * @param {mxCell} terminal  that specifies the new terminal.",
          " * @param isSource  Boolean indicating if the terminal is the new source or",
          " * target terminal of the edge.",
          " */"
        ]
      ],
      "getEdgeCount": [
        "getEdgeCount(cell: mxCell): number;",
        [
          "/**",
          " * Returns the number of distinct edges connected to the given cell.",
          " *",
          " * @param {mxCell} cell  that represents the vertex.",
          " */"
        ]
      ],
      "getEdgeAt": [
        "getEdgeAt(cell: mxCell, index: number): mxCell;",
        [
          "/**",
          " * Returns the edge of cell at the given index.",
          " *",
          " * @param {mxCell} cell  that specifies the vertex.",
          " * @param index  Integer that specifies the index of the edge",
          " * to return.",
          " */"
        ]
      ],
      "getDirectedEdgeCount": [
        "getDirectedEdgeCount(cell: mxCell, outgoing: boolean, ignoredEdge: boolean): number;",
        [
          "/**",
          " * Returns the number of incoming or outgoing edges, ignoring the given",
          " * edge.",
          " *",
          " * @param {mxCell} cell  whose edge count should be returned.",
          " * @param outgoing  Boolean that specifies if the number of outgoing or",
          " * incoming edges should be returned.",
          " * @param {mxCell} ignoredEdge  that represents an edge to be ignored.",
          " */"
        ]
      ],
      "getConnections": [
        "getConnections(cell: mxCell): Array<mxCell>;",
        [
          "/**",
          " * Returns all edges of the given cell without loops.",
          " *",
          " * @param {mxCell} cell  whose edges should be returned.",
          " *",
          " */"
        ]
      ],
      "getIncomingEdges": [
        "getIncomingEdges(cell: mxCell): Array<mxCell>;",
        [
          "/**",
          " * Returns the incoming edges of the given cell without loops.",
          " *",
          " * @param {mxCell} cell  whose incoming edges should be returned.",
          " *",
          " */"
        ]
      ],
      "getOutgoingEdges": [
        "getOutgoingEdges(cell: mxCell): Array<mxCell>;",
        [
          "/**",
          " * Returns the outgoing edges of the given cell without loops.",
          " *",
          " * @param {mxCell} cell  whose outgoing edges should be returned.",
          " *",
          " */"
        ]
      ],
      "getEdges": [
        "getEdges(cell: mxCell, incoming?: boolean, outgoing?: boolean, includeLoops?: boolean): Array<mxCell>;",
        [
          "/**",
          " * Returns all distinct edges connected to this cell as a new array of",
          " * {@link mxCell}. If at least one of incoming or outgoing is true, then loops",
          " * are ignored, otherwise if both are false, then all edges connected to",
          " * the given cell are returned including loops.",
          " *",
          " * @param {mxCell} cell  that specifies the cell.",
          " * @param incoming  Optional boolean that specifies if incoming edges should be",
          " * returned. Default is true.",
          " * @param outgoing  Optional boolean that specifies if outgoing edges should be",
          " * returned. Default is true.",
          " * @param includeLoops  Optional boolean that specifies if loops should be returned.",
          " * Default is true.",
          " */"
        ]
      ],
      "getEdgesBetween": [
        "getEdgesBetween(source: mxCell, target: mxCell, directed?: boolean): Array<mxCell>;",
        [
          "/**",
          " * Returns all edges between the given source and target pair. If directed",
          " * is true, then only edges from the source to the target are returned,",
          " * otherwise, all edges between the two cells are returned.",
          " *",
          " * @param {mxCell} source  that defines the source terminal of the edge to be",
          " * returned.",
          " * @param {mxCell} target  that defines the target terminal of the edge to be",
          " * returned.",
          " * @param directed  Optional boolean that specifies if the direction of the",
          " * edge should be taken into account. Default is false.",
          " */"
        ]
      ],
      "getOpposites": [
        "getOpposites(edges: Array<mxCell>, terminal: mxCell, sources?: boolean, targets?: boolean): Array<mxCell>;",
        [
          "/**",
          " * Returns all opposite vertices wrt terminal for the given edges, only",
          " * returning sources and/or targets as specified. The result is returned",
          " * as an array of {@link mxCell}.",
          " *",
          " * @param edges  Array of {@link mxCell} that contain the edges to be examined.",
          " * @param {mxCell} terminal  that specifies the known end of the edges.",
          " * @param sources  Boolean that specifies if source terminals should be contained",
          " * in the result. Default is true.",
          " * @param targets  Boolean that specifies if target terminals should be contained",
          " * in the result. Default is true.",
          " */"
        ]
      ],
      "getTopmostCells": [
        "getTopmostCells(cells: Array<mxCell>): Array<mxCell>;",
        [
          "/**",
          " * Returns the topmost cells of the hierarchy in an array that contains no",
          " * descendants for each {@link mxCell} that it contains. Duplicates should be",
          " * removed in the cells array to improve performance.",
          " *",
          " * @param cells  Array of {@link mxCell} whose topmost ancestors should be returned.",
          " */"
        ]
      ],
      "isVertex": [
        "isVertex(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is a vertex.",
          " *",
          " * @param {mxCell} cell  that represents the possible vertex.",
          " */"
        ]
      ],
      "isEdge": [
        "isEdge(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given cell is an edge.",
          " *",
          " * @param {mxCell} cell  that represents the possible edge.",
          " */"
        ]
      ],
      "isConnectable": [
        "isConnectable(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given {@link mxCell} is connectable. If {@link edgesConnectable}",
          " * is false, then this function returns false for all edges else it returns",
          " * the return value of <mxCell.isConnectable>.",
          " *",
          " * @param {mxCell} cell  whose connectable state should be returned.",
          " */"
        ]
      ],
      "getValue": [
        "getValue(cell: mxCell): any;",
        [
          "/**",
          " * Returns the user object of the given {@link mxCell} using <mxCell.getValue>.",
          " *",
          " * @param {mxCell} cell  whose user object should be returned.",
          " */"
        ]
      ],
      "setValue": [
        "setValue(cell: mxCell, value: any): any;",
        [
          "/**",
          " * Sets the user object of then given {@link mxCell} using {@link mxValueChange}",
          " * and adds the change to the current transaction.",
          " *",
          " * @param {mxCell} cell  whose user object should be changed.",
          " * @param value  Object that defines the new user object.",
          " */"
        ]
      ],
      "valueForCellChanged": [
        "valueForCellChanged(cell: mxCell, value: any): any;",
        [
          "/**",
          " * Inner callback to update the user object of the given {@link mxCell}",
          " * using <mxCell.valueChanged> and return the previous value,",
          " * that is, the return value of <mxCell.valueChanged>.",
          " *",
          " * To change a specific attribute in an XML node, the following code can be",
          " * used.",
          " *",
          " * ```javascript",
          " * graph.getModel().valueForCellChanged(cell, value)",
          " * {",
          " *   var previous = cell.value.getAttribute('label');",
          " *   cell.value.setAttribute('label', value);",
          " *",
          " *   return previous;",
          " * };",
          " * ```",
          " */"
        ]
      ],
      "getGeometry": [
        "getGeometry(cell: mxCell): mxGeometry;",
        [
          "/**",
          " * Returns the {@link mxGeometry} of the given {@link mxCell}.",
          " *",
          " * @param {mxCell} cell  whose geometry should be returned.",
          " */"
        ]
      ],
      "setGeometry": [
        "setGeometry(cell: mxCell, geometry: mxGeometry): mxGeometry;",
        [
          "/**",
          " * Sets the {@link mxGeometry} of the given {@link mxCell}. The actual update",
          " * of the cell is carried out in {@link geometryForCellChanged}. The",
          " * {@link mxGeometryChange} action is used to encapsulate the change.",
          " *",
          " * @param {mxCell} cell  whose geometry should be changed.",
          " * @param {mxGeometry} geometry  that defines the new geometry.",
          " */"
        ]
      ],
      "geometryForCellChanged": [
        "geometryForCellChanged(cell: mxCell, geometry: mxGeometry): mxGeometry;",
        [
          "/**",
          " * Inner callback to update the {@link mxGeometry} of the given {@link mxCell} using",
          " * <mxCell.setGeometry> and return the previous {@link mxGeometry}.",
          " */"
        ]
      ],
      "getStyle": [
        "getStyle(cell: mxCell): string | null;",
        [
          "/**",
          " * Returns the style of the given {@link mxCell}.",
          " *",
          " * @param {mxCell} cell  whose style should be returned.",
          " */"
        ]
      ],
      "setStyle": [
        "setStyle(cell: mxCell, style: string): string;",
        [
          "/**",
          " * Sets the style of the given {@link mxCell} using {@link mxStyleChange} and",
          " * adds the change to the current transaction.",
          " *",
          " * @param {mxCell} cell  whose style should be changed.",
          " * @param style  String of the form [stylename;|key=value;] to specify",
          " * the new cell style.",
          " */"
        ]
      ],
      "styleForCellChanged": [
        "styleForCellChanged(cell: mxCell, style: string): string;",
        [
          "/**",
          " * Inner callback to update the style of the given {@link mxCell}",
          " * using <mxCell.setStyle> and return the previous style.",
          " *",
          " * @param {mxCell} cell  that specifies the cell to be updated.",
          " * @param style  String of the form [stylename;|key=value;] to specify",
          " * the new cell style.",
          " */"
        ]
      ],
      "isCollapsed": [
        "isCollapsed(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given {@link mxCell} is collapsed.",
          " *",
          " * @param {mxCell} cell  whose collapsed state should be returned.",
          " */"
        ]
      ],
      "setCollapsed": [
        "setCollapsed(cell: mxCell, collapsed: boolean): boolean;",
        [
          "/**",
          " * Sets the collapsed state of the given {@link mxCell} using {@link mxCollapseChange}",
          " * and adds the change to the current transaction.",
          " *",
          " * @param {mxCell} cell  whose collapsed state should be changed.",
          " * @param collapsed  Boolean that specifies the new collpased state.",
          " */"
        ]
      ],
      "collapsedStateForCellChanged": [
        "collapsedStateForCellChanged(cell: mxCell, collapsed: boolean): boolean;",
        [
          "/**",
          " * Inner callback to update the collapsed state of the",
          " * given {@link mxCell} using <mxCell.setCollapsed> and return",
          " * the previous collapsed state.",
          " *",
          " * @param {mxCell} cell  that specifies the cell to be updated.",
          " * @param collapsed  Boolean that specifies the new collpased state.",
          " */"
        ]
      ],
      "isVisible": [
        "isVisible(cell: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given {@link mxCell} is visible.",
          " *",
          " * @param {mxCell} cell  whose visible state should be returned.",
          " */"
        ]
      ],
      "setVisible": [
        "setVisible(cell: mxCell, visible: boolean): boolean;",
        [
          "/**",
          " * Sets the visible state of the given {@link mxCell} using {@link mxVisibleChange} and",
          " * adds the change to the current transaction.",
          " *",
          " * @param {mxCell} cell  whose visible state should be changed.",
          " * @param visible  Boolean that specifies the new visible state.",
          " */"
        ]
      ],
      "visibleStateForCellChanged": [
        "visibleStateForCellChanged(cell: mxCell, visible: boolean): boolean;",
        [
          "/**",
          " * Inner callback to update the visible state of the",
          " * given {@link mxCell} using <mxCell.setCollapsed> and return",
          " * the previous visible state.",
          " *",
          " * @param {mxCell} cell  that specifies the cell to be updated.",
          " * @param visible  Boolean that specifies the new visible state.",
          " */"
        ]
      ],
      "execute": [
        "execute(change: any): void;",
        [
          "/**",
          " * Executes the given edit and fires events if required. The edit object",
          " * requires an execute function which is invoked. The edit is added to the",
          " * {@link currentEdit} between {@link beginUpdate} and {@link endUpdate} calls, so that",
          " * events will be fired if this execute is an individual transaction, that",
          " * is, if no previous {@link beginUpdate} calls have been made without calling",
          " * {@link endUpdate}. This implementation fires an {@link execute} event before",
          " * executing the given change.",
          " *",
          " * @param change  Object that described the change.",
          " */"
        ]
      ],
      "beginUpdate": [
        "beginUpdate(): void;",
        [
          "/**",
          " * Increments the {@link updateLevel} by one. The event notification",
          " * is queued until {@link updateLevel} reaches 0 by use of",
          " * {@link endUpdate}.",
          " *",
          " * All changes on {@link mxGraphModel} are transactional,",
          " * that is, they are executed in a single undoable change",
          " * on the model (without transaction isolation).",
          " * Therefore, if you want to combine any",
          " * number of changes into a single undoable change,",
          " * you should group any two or more API calls that",
          " * modify the graph model between {@link beginUpdate}",
          " * and {@link endUpdate} calls as shown here:",
          " *",
          " * ```javascript",
          " * var model = graph.getModel();",
          " * var parent = graph.getDefaultParent();",
          " * var index = model.getChildCount(parent);",
          " * model.beginUpdate();",
          " * try",
          " * {",
          " *   model.add(parent, v1, index);",
          " *   model.add(parent, v2, index+1);",
          " * }",
          " * finally",
          " * {",
          " *   model.endUpdate();",
          " * }",
          " * ```",
          " *",
          " * Of course there is a shortcut for appending a",
          " * sequence of cells into the default parent:",
          " *",
          " * ```javascript",
          " * graph.addCells([v1, v2]).",
          " * ```",
          " */"
        ]
      ],
      "endUpdate": [
        "endUpdate(): void;",
        [
          "/**",
          " * Decrements the {@link updateLevel} by one and fires an {@link undo}",
          " * event if the {@link updateLevel} reaches 0. This function",
          " * indirectly fires a {@link change} event by invoking the notify",
          " * function on the {@link currentEdit} und then creates a new",
          " * {@link currentEdit} using {@link createUndoableEdit}.",
          " *",
          " * The {@link undo} event is fired only once per edit, whereas",
          " * the {@link change} event is fired whenever the notify",
          " * function is invoked, that is, on undo and redo of",
          " * the edit.",
          " */"
        ]
      ],
      "createUndoableEdit": [
        "createUndoableEdit(significant?: boolean): mxUndoableEdit;",
        [
          "/**",
          " * Creates a new {@link mxUndoableEdit} that implements the",
          " * notify function to fire a {@link change} and {@link notify} event",
          " * through the {@link mxUndoableEdit}'s source.",
          " *",
          " * @param significant  Optional boolean that specifies if the edit to be created is",
          " * significant. Default is true.",
          " */"
        ]
      ],
      "mergeChildren": [
        "mergeChildren(from: mxGraphModel, to: mxGraphModel, cloneAllEdges?: boolean): void;",
        [
          "/**",
          " * Merges the children of the given cell into the given target cell inside",
          " * this model. All cells are cloned unless there is a corresponding cell in",
          " * the model with the same id, in which case the source cell is ignored and",
          " * all edges are connected to the corresponding cell in this model. Edges",
          " * are considered to have no identity and are always cloned unless the",
          " * cloneAllEdges flag is set to false, in which case edges with the same",
          " * id in the target model are reconnected to reflect the terminals of the",
          " * source edges.",
          " */"
        ]
      ],
      "mergeChildrenImpl": [
        "mergeChildrenImpl(from: mxGraphModel, to: mxGraphModel, cloneAllEdges: boolean, mapping: any): void;",
        [
          "/**",
          " * Clones the children of the source cell into the given target cell in",
          " * this model and adds an entry to the mapping that maps from the source",
          " * cell to the target cell with the same id or the clone of the source cell",
          " * that was inserted into this model.",
          " */"
        ]
      ],
      "getParents": [
        "getParents(cells: Array<mxCell>): Array<mxCell>;",
        [
          "/**",
          " * Returns an array that represents the set (no duplicates) of all parents",
          " * for the given array of cells.",
          " *",
          " * @param cells  Array of cells whose parents should be returned.",
          " */"
        ]
      ],
      "cloneCell": [
        "cloneCell(cell: mxCell): mxCell;",
        [
          "/**",
          " * Returns a deep clone of the given {@link mxCell}` (including",
          " * the children) which is created using {@link cloneCells}`.",
          " *",
          " * @param {mxCell} cell  to be cloned.",
          " */"
        ]
      ],
      "cloneCells": [
        "cloneCells(cells: Array<mxCell>, includeChildren?: boolean, mapping?: any): Array<mxCell>;",
        [
          "/**",
          " * Returns an array of clones for the given array of {@link mxCell}`.",
          " * Depending on the value of includeChildren, a deep clone is created for",
          " * each cell. Connections are restored based if the corresponding",
          " * cell is contained in the passed in array.",
          " *",
          " * @param cells  Array of {@link mxCell}` to be cloned.",
          " * @param includeChildren  Boolean indicating if the cells should be cloned",
          " * with all descendants.",
          " * @param mapping  Optional mapping for existing clones.",
          " */"
        ]
      ],
      "cloneCellImpl": [
        "cloneCellImpl(cell: mxCell, mapping?: any, includeChildren?: boolean): mxCell;",
        [
          "/**",
          " * Inner helper method for cloning cells recursively.",
          " */"
        ]
      ],
      "cellCloned": [
        "cellCloned(cell: mxCell): mxCell;",
        [
          "/**",
          " * Hook for cloning the cell. This returns cell.clone() or",
          " * any possible exceptions.",
          " */"
        ]
      ],
      "restoreClone": [
        "restoreClone(clone: mxCell, cell: mxCell, mapping?: any): void;",
        [
          "/**",
          " * Inner helper method for restoring the connections in",
          " * a network of cloned cells.",
          " */"
        ]
      ]
    }
  ],
  "mxRootChange": [
    [
      "/**",
      " * Action to change the root in a model.",
      " *",
      " * Constructor: mxRootChange",
      " *",
      " * Constructs a change of the root in the",
      " * specified model.",
      " *",
      " * @class mxRootChange",
      " */"
    ],
    {
      "constructor": [
        "constructor(model: mxGraphModel, root: mxCell);",
        [
          "/**",
          " * Inner helper method for restoring the connections in",
          " * a network of cloned cells.",
          " */"
        ]
      ],
      "execute": [
        "execute(): void;",
        [
          "/**",
          " * Carries out a change of the root using",
          " * <mxGraphModel.rootChanged>.",
          " */"
        ]
      ]
    }
  ],
  "mxChildChange": [
    [
      "/**",
      " * Action to add or remove a child in a model.",
      " *",
      " * Constructor: mxChildChange",
      " *",
      " * Constructs a change of a child in the",
      " * specified model.",
      " *",
      " * @class mxChildChange",
      " */"
    ],
    {
      "constructor": [
        "constructor(model: mxGraphModel, parent: mxCell, child: mxCell, index: number);",
        [
          "/**",
          " * Carries out a change of the root using",
          " * <mxGraphModel.rootChanged>.",
          " */"
        ]
      ],
      "child": [
        "child: mxCell;",
        [
          "/**",
          " * Carries out a change of the root using",
          " * <mxGraphModel.rootChanged>.",
          " */"
        ]
      ],
      "index": [
        "index: number;",
        [
          "/**",
          " * Carries out a change of the root using",
          " * <mxGraphModel.rootChanged>.",
          " */"
        ]
      ],
      "model": [
        "model: mxGraphModel;",
        [
          "/**",
          " * Carries out a change of the root using",
          " * <mxGraphModel.rootChanged>.",
          " */"
        ]
      ],
      "parent": [
        "parent: mxCell;",
        [
          "/**",
          " * Carries out a change of the root using",
          " * <mxGraphModel.rootChanged>.",
          " */"
        ]
      ],
      "previous": [
        "previous: any;",
        [
          "/**",
          " * Carries out a change of the root using",
          " * <mxGraphModel.rootChanged>.",
          " */"
        ]
      ],
      "previousIndex": [
        "previousIndex: number;",
        [
          "/**",
          " * Carries out a change of the root using",
          " * <mxGraphModel.rootChanged>.",
          " */"
        ]
      ],
      "execute": [
        "execute(): void;",
        [
          "/**",
          " * Changes the parent of {@link child}` using",
          " * <mxGraphModel.parentForCellChanged> and",
          " * removes or restores the cell's",
          " * connections.",
          " */"
        ]
      ],
      "connect": [
        "connect(cell: mxCell, isConnect: boolean): void;",
        [
          "/**",
          " * Disconnects the given cell recursively from its",
          " * terminals and stores the previous terminal in the",
          " * cell's terminals.",
          " *",
          " * @warning doc from mxGraph source code is incorrect",
          " */"
        ]
      ]
    }
  ],
  "mxTerminalChange": [
    [
      "/**",
      " * Action to change a terminal in a model.",
      " *",
      " * Constructor: mxTerminalChange",
      " *",
      " * Constructs a change of a terminal in the",
      " * specified model.",
      " */"
    ],
    {
      "constructor": [
        "constructor(model: mxGraphModel, cell: mxCell, terminal: mxCell, source: boolean);",
        [
          "/**",
          " * Disconnects the given cell recursively from its",
          " * terminals and stores the previous terminal in the",
          " * cell's terminals.",
          " *",
          " * @warning doc from mxGraph source code is incorrect",
          " */"
        ]
      ],
      "execute": [
        "execute(): void;",
        [
          "/**",
          " * Changes the terminal of {@link cell}` to {@link previous}` using",
          " * <mxGraphModel.terminalForCellChanged>.",
          " */"
        ]
      ]
    }
  ],
  "mxValueChange": [
    [
      "/**",
      " * Action to change a user object in a model.",
      " *",
      " * Constructs a change of a user object in the",
      " * specified model.",
      " *",
      " * @class mxValueChange",
      " */"
    ],
    {
      "constructor": [
        "constructor(model: mxGraphModel, cell: mxCell, value: any);",
        [
          "/**",
          " * Changes the terminal of {@link cell}` to {@link previous}` using",
          " * <mxGraphModel.terminalForCellChanged>.",
          " */"
        ]
      ],
      "execute": [
        "execute(): void;",
        [
          "/**",
          " * Changes the value of {@link cell}` to {@link previous}` using",
          " * <mxGraphModel.valueForCellChanged>.",
          " */"
        ]
      ]
    }
  ],
  "mxStyleChange": [
    [
      "/**",
      " * Action to change a cell's style in a model.",
      " *",
      " * @class mxStyleChange",
      " */"
    ],
    {
      "constructor": [
        "constructor(model: mxGraphModel, cell: mxCell, style?: string);",
        [
          "/**",
          " * Changes the value of {@link cell}` to {@link previous}` using",
          " * <mxGraphModel.valueForCellChanged>.",
          " */"
        ]
      ],
      "execute": [
        "execute(): void;",
        [
          "/**",
          " * Function: execute",
          " *",
          " * Changes the style of {@link cell}` to {@link previous}` using",
          " * <mxGraphModel.styleForCellChanged>.",
          " */"
        ]
      ]
    }
  ],
  "mxGeometryChange": [
    [
      "/**",
      " * Class: mxGeometryChange",
      " *",
      " * Action to change a cell's geometry in a model.",
      " *",
      " * Constructor: mxGeometryChange",
      " *",
      " * Constructs a change of a geometry in the",
      " * specified model.",
      " */"
    ],
    {
      "constructor": [
        "constructor(model: mxGraphModel, cell: mxCell, geometry: mxGeometry);",
        [
          "/**",
          " * Function: execute",
          " *",
          " * Changes the style of {@link cell}` to {@link previous}` using",
          " * <mxGraphModel.styleForCellChanged>.",
          " */"
        ]
      ],
      "model": [
        "model: mxGraphModel;",
        [
          "/**",
          " * Function: execute",
          " *",
          " * Changes the style of {@link cell}` to {@link previous}` using",
          " * <mxGraphModel.styleForCellChanged>.",
          " */"
        ]
      ],
      "cell": [
        "cell: mxCell;",
        [
          "/**",
          " * Function: execute",
          " *",
          " * Changes the style of {@link cell}` to {@link previous}` using",
          " * <mxGraphModel.styleForCellChanged>.",
          " */"
        ]
      ],
      "geometry": [
        "geometry: mxGeometry;",
        [
          "/**",
          " * Function: execute",
          " *",
          " * Changes the style of {@link cell}` to {@link previous}` using",
          " * <mxGraphModel.styleForCellChanged>.",
          " */"
        ]
      ],
      "previous": [
        "previous: mxGeometry;",
        [
          "/**",
          " * Function: execute",
          " *",
          " * Changes the style of {@link cell}` to {@link previous}` using",
          " * <mxGraphModel.styleForCellChanged>.",
          " */"
        ]
      ],
      "execute": [
        "execute(): void;",
        [
          "/**",
          " * Function: execute",
          " *",
          " * Changes the geometry of {@link cell}` ro {@link previous}` using",
          " * <mxGraphModel.geometryForCellChanged>.",
          " */"
        ]
      ]
    }
  ],
  "mxCollapseChange": [
    [
      "/**",
      " * Class: mxCollapseChange",
      " *",
      " * Action to change a cell's collapsed state in a model.",
      " *",
      " * Constructor: mxCollapseChange",
      " *",
      " * Constructs a change of a collapsed state in the",
      " * specified model.",
      " */"
    ],
    {
      "constructor": [
        "constructor(model: mxGraphModel, cell: mxCell, collapsed: boolean);",
        [
          "/**",
          " * Function: execute",
          " *",
          " * Changes the geometry of {@link cell}` ro {@link previous}` using",
          " * <mxGraphModel.geometryForCellChanged>.",
          " */"
        ]
      ],
      "model": [
        "model: mxGraphModel;",
        [
          "/**",
          " * Function: execute",
          " *",
          " * Changes the geometry of {@link cell}` ro {@link previous}` using",
          " * <mxGraphModel.geometryForCellChanged>.",
          " */"
        ]
      ],
      "cell": [
        "cell: mxCell;",
        [
          "/**",
          " * Function: execute",
          " *",
          " * Changes the geometry of {@link cell}` ro {@link previous}` using",
          " * <mxGraphModel.geometryForCellChanged>.",
          " */"
        ]
      ],
      "geometry": [
        "geometry: boolean;",
        [
          "/**",
          " * Function: execute",
          " *",
          " * Changes the geometry of {@link cell}` ro {@link previous}` using",
          " * <mxGraphModel.geometryForCellChanged>.",
          " */"
        ]
      ],
      "previous": [
        "previous: boolean;",
        [
          "/**",
          " * Function: execute",
          " *",
          " * Changes the geometry of {@link cell}` ro {@link previous}` using",
          " * <mxGraphModel.geometryForCellChanged>.",
          " */"
        ]
      ],
      "execute": [
        "execute(): void;",
        [
          "/**",
          " * Function: execute",
          " *",
          " * Changes the collapsed state of {@link cell}` to {@link previous}` using",
          " * <mxGraphModel.collapsedStateForCellChanged>.",
          " */"
        ]
      ]
    }
  ],
  "mxVisibleChange": [
    [
      "/**",
      " * Class: mxVisibleChange",
      " *",
      " * Action to change a cell's visible state in a model.",
      " *",
      " * Constructor: mxVisibleChange",
      " *",
      " * Constructs a change of a visible state in the",
      " * specified model.",
      " */"
    ],
    {
      "constructor": [
        "constructor(model: mxGraphModel, cell: mxCell, visible: boolean);",
        [
          "/**",
          " * Function: execute",
          " *",
          " * Changes the collapsed state of {@link cell}` to {@link previous}` using",
          " * <mxGraphModel.collapsedStateForCellChanged>.",
          " */"
        ]
      ],
      "execute": [
        "execute(): void;",
        [
          "/**",
          " * Function: execute",
          " *",
          " * Changes the visible state of {@link cell}` to {@link previous}` using",
          " * <mxGraphModel.visibleStateForCellChanged>.",
          " */"
        ]
      ]
    }
  ],
  "mxCellAttributeChange": [
    [
      "/**",
      " * Class: mxCellAttributeChange",
      " *",
      " * Action to change the attribute of a cell's user object.",
      " * There is no method on the graph model that uses this",
      " * action. To use the action, you can use the code shown",
      " * in the example below.",
      " *",
      " * Example:",
      " *",
      " * To change the attributeName in the cell's user object",
      " * to attributeValue, use the following code:",
      " *",
      " * ```javascript",
      " * model.beginUpdate();",
      " * try",
      " * {",
      " *   var edit = new mxCellAttributeChange(",
      " *     cell, attributeName, attributeValue);",
      " *   model.execute(edit);",
      " * }",
      " * finally",
      " * {",
      " *   model.endUpdate();",
      " * }",
      " * ```",
      " *",
      " * Constructor: mxCellAttributeChange",
      " *",
      " * Constructs a change of a attribute of the DOM node",
      " * stored as the value of the given {@link mxCell}`.",
      " */"
    ],
    {
      "constructor": [
        "constructor(cell: mxCell, attribute: string, value: any);",
        [
          "/**",
          " * Function: execute",
          " *",
          " * Changes the visible state of {@link cell}` to {@link previous}` using",
          " * <mxGraphModel.visibleStateForCellChanged>.",
          " */"
        ]
      ],
      "execute": [
        "execute(): void;",
        [
          "/**",
          " * Function: execute",
          " *",
          " * Changes the attribute of the cell's user object by",
          " * using <mxCell.setAttribute>.",
          " */"
        ]
      ]
    }
  ],
  "mxCell": [
    [
      "/**",
      " * Cells are the elements of the graph model. They represent the state",
      " * of the groups, vertices and edges in a graph.",
      " *",
      " * ### Custom attributes",
      " * For custom attributes we recommend using an XML node as the value of a cell.",
      " * The following code can be used to create a cell with an XML node as the value:",
      " * @example",
      " * ```javascript",
      " * var doc = mxUtils.createXmlDocument();",
      " * var node = doc.createElement('MyNode')",
      " * node.setAttribute('label', 'MyLabel');",
      " * node.setAttribute('attribute1', 'value1');",
      " * graph.insertVertex(graph.getDefaultParent(), null, node, 40, 40, 80, 30);",
      " * ```",
      " *",
      " * For the label to work, {@link mxGraph.convertValueToString} and",
      " * {@link mxGraph.cellLabelChanged} should be overridden as follows:",
      " *",
      " * @example",
      " * ```javascript",
      " * graph.convertValueToString(cell)",
      " * {",
      " *   if (mxUtils.isNode(cell.value))",
      " *   {",
      " *     return cell.getAttribute('label', '')",
      " *   }",
      " * };",
      " *",
      " * var cellLabelChanged = graph.cellLabelChanged;",
      " * graph.cellLabelChanged(cell, newValue, autoSize)",
      " * {",
      " *   if (mxUtils.isNode(cell.value))",
      " *   {",
      " *     // Clones the value for correct undo/redo",
      " *     var elt = cell.value.cloneNode(true);",
      " *     elt.setAttribute('label', newValue);",
      " *     newValue = elt;",
      " *   }",
      " *",
      " *   cellLabelChanged.apply(this, arguments);",
      " * };",
      " * ```",
      " * @class mxCell",
      " */"
    ],
    {
      "constructor": [
        "constructor(value?: any, geometry?: mxGeometry, style?: string);",
        [
          "/**",
          " * @param {*} value               Optional object that represents the cell value.",
          " * @param {mxGeometry} geometry   Optional <mxGeometry> that specifies the geometry.",
          " * @param {string} style          Optional formatted string that defines the style.",
          " */"
        ]
      ],
      "overlays": [
        "overlays: Array<mxCellOverlay>;",
        [
          "/**",
          " * @see {mxGraph.getCellOverlays}",
          " *",
          " * @type {Array<mxCellOverlay>}",
          " */"
        ]
      ],
      "id": [
        "id: string;",
        [
          "/**",
          " * Holds the Id. Default is null.",
          " */"
        ]
      ],
      "value": [
        "value: any;",
        [
          "/**",
          " * Holds the user object. Default is null.",
          " */"
        ]
      ],
      "geometry": [
        "geometry: mxGeometry;",
        [
          "/**",
          " * Holds the <mxGeometry>. Default is null.",
          " */"
        ]
      ],
      "style": [
        "style: string;",
        [
          "/**",
          " * Holds the style as a string of the form [(stylename|key=value);]. Default is",
          " * null.",
          " */"
        ]
      ],
      "vertex": [
        "vertex: boolean;",
        [
          "/**",
          " * Specifies whether the cell is a vertex. Default is false.",
          " */"
        ]
      ],
      "edge": [
        "edge: boolean;",
        [
          "/**",
          " * Specifies whether the cell is an edge. Default is false.",
          " */"
        ]
      ],
      "connectable": [
        "connectable: boolean;",
        [
          "/**",
          " * Specifies whether the cell is connectable. Default is true.",
          " */"
        ]
      ],
      "visible": [
        "visible: boolean;",
        [
          "/**",
          " * Specifies whether the cell is visible. Default is true.",
          " */"
        ]
      ],
      "collapsed": [
        "collapsed: boolean;",
        [
          "/**",
          " * Specifies whether the cell is collapsed. Default is false.",
          " */"
        ]
      ],
      "parent": [
        "parent: mxCell;",
        [
          "/**",
          " * Reference to the parent cell.",
          " */"
        ]
      ],
      "source": [
        "source: mxCell;",
        [
          "/**",
          " * Reference to the source terminal.",
          " */"
        ]
      ],
      "target": [
        "target: mxCell;",
        [
          "/**",
          " * Reference to the target terminal.",
          " */"
        ]
      ],
      "children": [
        "children: Array<mxCell>;",
        [
          "/**",
          " * Holds the child cells.",
          " */"
        ]
      ],
      "edges": [
        "edges: Array<mxCell>;",
        [
          "/**",
          " * Holds the edges.",
          " */"
        ]
      ],
      "mxTransient": [
        "mxTransient: Array<string>;",
        [
          "/**",
          " * List of members that should not be cloned inside <clone>. This field is",
          " * passed to <mxUtils.clone> and is not made persistent in <mxCellCodec>.",
          " * This is not a convention for all classes, it is only used in this class",
          " * to mark transient fields since transient modifiers are not supported by",
          " * the language.",
          " */"
        ]
      ],
      "getId": [
        "getId(): string;",
        [
          "/**",
          " * Returns the Id of the cell as a string.",
          " */"
        ]
      ],
      "setId": [
        "setId(id: string): void;",
        [
          "/**",
          " * Sets the Id of the cell to the given string.",
          " */"
        ]
      ],
      "getValue": [
        "getValue(): any;",
        [
          "/**",
          " * Returns the user object of the cell. The user",
          " * object is stored in <value>.",
          " */"
        ]
      ],
      "setValue": [
        "setValue(value: any): void;",
        [
          "/**",
          " * Sets the user object of the cell. The user object",
          " * is stored in <value>.",
          " */"
        ]
      ],
      "valueChanged": [
        "valueChanged(newValue: any): any;",
        [
          "/**",
          " * Changes the user object after an in-place edit",
          " * and returns the previous value. This implementation",
          " * replaces the user object with the given value and",
          " * returns the old user object.",
          " */"
        ]
      ],
      "getGeometry": [
        "getGeometry(): mxGeometry;",
        [
          "/**",
          " * Returns the <mxGeometry> that describes the <geometry>.",
          " */"
        ]
      ],
      "setGeometry": [
        "setGeometry(geometry: mxGeometry): void;",
        [
          "/**",
          " * Sets the <mxGeometry> to be used as the <geometry>.",
          " */"
        ]
      ],
      "getStyle": [
        "getStyle(): string;",
        [
          "/**",
          " * Returns a string that describes the <style>.",
          " */"
        ]
      ],
      "setStyle": [
        "setStyle(style: string): void;",
        [
          "/**",
          " * Sets the string to be used as the <style>.",
          " */"
        ]
      ],
      "isVertex": [
        "isVertex(): boolean;",
        [
          "/**",
          " * Returns true if the cell is a vertex.",
          " */"
        ]
      ],
      "setVertex": [
        "setVertex(vertex: boolean): void;",
        [
          "/**",
          " * Specifies if the cell is a vertex. This should only be assigned at",
          " * construction of the cell and not be changed during its lifecycle.",
          " *",
          " * Parameters:",
          " *",
          " * @param vertex Boolean that specifies if the cell is a vertex.",
          " */"
        ]
      ],
      "isEdge": [
        "isEdge(): boolean;",
        [
          "/**",
          " * Returns true if the cell is an edge.",
          " */"
        ]
      ],
      "setEdge": [
        "setEdge(edge: boolean): void;",
        [
          "/**",
          " * Specifies if the cell is an edge. This should only be assigned at",
          " * construction of the cell and not be changed during its lifecycle.",
          " *",
          " * Parameters:",
          " *",
          " * @param edge Boolean that specifies if the cell is an edge.",
          " */"
        ]
      ],
      "isConnectable": [
        "isConnectable(): boolean;",
        [
          "/**",
          " * Returns true if the cell is connectable.",
          " */"
        ]
      ],
      "setConnectable": [
        "setConnectable(connectable: boolean): void;",
        [
          "/**",
          " * Sets the connectable state.",
          " *",
          " * Parameters:",
          " *",
          " * @param connectable Boolean that specifies the new connectable state.",
          " */"
        ]
      ],
      "isVisible": [
        "isVisible(): boolean;",
        [
          "/**",
          " * Returns true if the cell is visibile.",
          " */"
        ]
      ],
      "setVisible": [
        "setVisible(visible: boolean): void;",
        [
          "/**",
          " * Specifies if the cell is visible.",
          " *",
          " * Parameters:",
          " *",
          " * @param visible Boolean that specifies the new visible state.",
          " */"
        ]
      ],
      "isCollapsed": [
        "isCollapsed(): boolean;",
        [
          "/**",
          " * Returns true if the cell is collapsed.",
          " */"
        ]
      ],
      "setCollapsed": [
        "setCollapsed(collapsed: boolean): void;",
        [
          "/**",
          " * Sets the collapsed state.",
          " *",
          " * Parameters:",
          " *",
          " * @param collapsed Boolean that specifies the new collapsed state.",
          " */"
        ]
      ],
      "getParent": [
        "getParent(): mxCell;",
        [
          "/**",
          " * Returns the cell's parent.",
          " */"
        ]
      ],
      "setParent": [
        "setParent(parent: mxCell): void;",
        [
          "/**",
          " * Sets the parent cell.",
          " *",
          " * Parameters:",
          " *",
          " * @param parent<mxCell> that represents the new parent.",
          " */"
        ]
      ],
      "getTerminal": [
        "getTerminal(source: boolean): mxCell;",
        [
          "/**",
          " * Returns the source or target terminal.",
          " *",
          " * Parameters:",
          " *",
          " * @param source Boolean that specifies if the source terminal should be",
          " * returned.",
          " */"
        ]
      ],
      "setTerminal": [
        "setTerminal(terminal: mxCell, isSource: boolean): mxCell;",
        [
          "/**",
          " * Sets the source or target terminal and returns the new terminal.",
          " *",
          " * @param {mxCell} terminal     mxCell that represents the new source or target terminal.",
          " * @param {boolean} isSource  boolean that specifies if the source or target terminal",
          " * should be set.",
          " */"
        ]
      ],
      "getChildCount": [
        "getChildCount(): number;",
        [
          "/**",
          " * Returns the number of child cells.",
          " */"
        ]
      ],
      "getIndex": [
        "getIndex(child: mxCell): number;",
        [
          "/**",
          " * Returns the index of the specified child in the child array.",
          " *",
          " * Parameters:",
          " *",
          " * @param childChild whose index should be returned.",
          " */"
        ]
      ],
      "getChildAt": [
        "getChildAt(index: number): mxCell;",
        [
          "/**",
          " * Returns the child at the specified index.",
          " *",
          " * Parameters:",
          " *",
          " * @param indexInteger that specifies the child to be returned.",
          " */"
        ]
      ],
      "insert": [
        "insert(child: mxCell, index: number): mxCell;",
        [
          "/**",
          " * Inserts the specified child into the child array at the specified index",
          " * and updates the parent reference of the child. If not childIndex is",
          " * specified then the child is appended to the child array. Returns the",
          " * inserted child.",
          " *",
          " * Parameters:",
          " *",
          " * @param child<mxCell> to be inserted or appended to the child array.",
          " * @param indexOptional integer that specifies the index at which the child",
          " * should be inserted into the child array.",
          " */"
        ]
      ],
      "remove": [
        "remove(index: number): mxCell;",
        [
          "/**",
          " * Removes the child at the specified index from the child array and",
          " * returns the child that was removed. Will remove the parent reference of",
          " * the child.",
          " *",
          " * Parameters:",
          " *",
          " * @param indexInteger that specifies the index of the child to be",
          " * removed.",
          " */"
        ]
      ],
      "removeFromParent": [
        "removeFromParent(): mxCell;",
        [
          "/**",
          " * Removes the cell from its parent.",
          " */"
        ]
      ],
      "getEdgeCount": [
        "getEdgeCount(): number;",
        [
          "/**",
          " * Returns the number of edges in the edge array.",
          " */"
        ]
      ],
      "getEdgeIndex": [
        "getEdgeIndex(edge: mxCell): number;",
        [
          "/**",
          " * Returns the index of the specified edge in <edges>.",
          " *",
          " * Parameters:",
          " *",
          " * @param edge<mxCell> whose index in <edges> should be returned.",
          " */"
        ]
      ],
      "getEdgeAt": [
        "getEdgeAt(index: number): mxCell;",
        [
          "/**",
          " * Returns the edge at the specified index in <edges>.",
          " *",
          " * Parameters:",
          " *",
          " * @param indexInteger that specifies the index of the edge to be returned.",
          " */"
        ]
      ],
      "insertEdge": [
        "insertEdge(edge: mxCell, isOutgoing: boolean): mxCell;",
        [
          "/**",
          " * Inserts the specified edge into the edge array and returns the edge.",
          " * Will update the respective terminal reference of the edge.",
          " *",
          " * Parameters:",
          " *",
          " * @param edge              <mxCell> to be inserted into the edge array.",
          " * @param isOutgoing Boolean that specifies if the edge is outgoing.",
          " */"
        ]
      ],
      "removeEdge": [
        "removeEdge(edge: mxCell, isOutgoing: boolean): mxCell;",
        [
          "/**",
          " * Removes the specified edge from the edge array and returns the edge.",
          " * Will remove the respective terminal reference from the edge.",
          " *",
          " * Parameters:",
          " *",
          " * @param edge<mxCell> to be removed from the edge array.",
          " * @param isOutgoing Boolean that specifies if the edge is outgoing.",
          " */"
        ]
      ],
      "removeFromTerminal": [
        "removeFromTerminal(isSource: boolean): mxCell;",
        [
          "/**",
          " * Removes the edge from its source or target terminal.",
          " *",
          " * Parameters:",
          " *",
          " * @param isSource Boolean that specifies if the edge should be removed from its source or target terminal.",
          " */"
        ]
      ],
      "hasAttribute": [
        "hasAttribute(name: string): boolean;",
        [
          "/**",
          " * Returns true if the user object is an XML node that contains the given",
          " * attribute.",
          " *",
          " * Parameters:",
          " *",
          " * @param nameName nameName of the attribute.",
          " */"
        ]
      ],
      "getAttribute": [
        "getAttribute(name: string, defaultValue: any): any;",
        [
          "/**",
          " * Returns the specified attribute from the user object if it is an XML",
          " * node.",
          " *",
          " * Parameters:",
          " *",
          " * @param nameName              of the attribute whose value should be returned.",
          " * @param defaultValueOptional  default value to use if the attribute has no",
          " * value.",
          " */"
        ]
      ],
      "setAttribute": [
        "setAttribute(name: string, value: any): void;",
        [
          "/**",
          " * Sets the specified attribute on the user object if it is an XML node.",
          " *",
          " * Parameters:",
          " *",
          " * @param nameName    of the attribute whose value should be set.",
          " * @param valueNew    value of the attribute.",
          " */"
        ]
      ],
      "clone": [
        "clone(): mxCell;",
        [
          "/**",
          " * Returns a clone of the cell. Uses <cloneValue> to clone",
          " * the user object. All fields in <mxTransient> are ignored",
          " * during the cloning.",
          " */"
        ]
      ],
      "cloneValue": [
        "cloneValue(): any;",
        [
          "/**",
          " * Returns a clone of the cell's user object.",
          " */"
        ]
      ],
      "key": [
        "[key: string]: any;",
        [
          "/**",
          " * Returns a clone of the cell's user object.",
          " */"
        ]
      ]
    }
  ],
  "mxElbowEdgeHandler": [
    null,
    {
      "constructor": [
        "constructor(state: mxCellState);",
        null
      ],
      "flipEnabled": [
        "flipEnabled: boolean;",
        [
          "/**",
          " * Specifies if a double click on the middle handle should call",
          " * <mxGraph.flipEdge>. Default is true.",
          " */"
        ]
      ],
      "doubleClickOrientationResource": [
        "doubleClickOrientationResource: string;",
        [
          "/**",
          " * Variable: doubleClickOrientationResource",
          " *",
          " * Specifies the resource key for the tooltip to be displayed on the single",
          " * control point for routed edges. If the resource for this key does not",
          " * exist then the value is used as the error message. Default is",
          " * 'doubleClickOrientation'.",
          " */"
        ]
      ],
      "// createBends": [
        "// createBends(): mxShape[];",
        [
          "/**",
          " * Function: createBends",
          " *",
          " * Overrides <mxEdgeHandler.createBends> to create custom bends.",
          " */"
        ]
      ],
      "createVirtualBend": [
        "createVirtualBend(dblClickHandler: (evt: Event) => void): mxRectangleShape;",
        [
          "/**",
          " * Function: createVirtualBend",
          " *",
          " * Creates a virtual bend that supports double clicking and calls",
          " * <mxGraph.flipEdge>.",
          " */"
        ]
      ],
      "getCursorForBend": [
        "getCursorForBend(): string;",
        [
          "/**",
          " * Function: getCursorForBend",
          " *",
          " * Returns the cursor to be used for the bend.",
          " */"
        ]
      ],
      "getTooltipForNode": [
        "getTooltipForNode(node: Element): string;",
        [
          "/**",
          " * Function: getTooltipForNode",
          " *",
          " * Returns the tooltip for the given node.",
          " */"
        ]
      ],
      "convertPoint": [
        "convertPoint(point: mxPoint, gridEnabled: boolean): mxPoint;",
        [
          "/**",
          " * Function: convertPoint",
          " *",
          " * Converts the given point in-place from screen to unscaled, untranslated",
          " * graph coordinates and applies the grid.",
          " *",
          " * Parameters:",
          " *",
          " * point - <mxPoint> to be converted.",
          " * gridEnabled - Boolean that specifies if the grid should be applied.",
          " */"
        ]
      ],
      "redrawInnerBends": [
        "redrawInnerBends(p0: mxPoint, pe: mxPoint): void;",
        [
          "/**",
          " * Function: redrawInnerBends",
          " *",
          " * Updates and redraws the inner bends.",
          " *",
          " * Parameters:",
          " *",
          " * p0 - <mxPoint> that represents the location of the first point.",
          " * pe - <mxPoint> that represents the location of the last point.",
          " */"
        ]
      ]
    }
  ],
  "mxCellHighlight": [
    [
      "/**",
      " * A helper class to highlight cells. Here is an example for a given cell.",
      " *",
      " * @example",
      " * ```javascript",
      " * var highlight = new mxCellHighlight(graph, '#ff0000', 2);",
      " * highlight.highlight(graph.view.getState(cell)));",
      " * ```",
      " */"
    ],
    {
      "constructor": [
        "constructor(graph: mxGraph, highlightColor?: string, strokeWidth?: number, dashed?: boolean);",
        [
          "/**",
          " * Constructs a cell highlight.",
          " *",
          " * @param graph",
          " * @param highlightColor  default {@link mxConstants.DEFAULT_VALID_COLOR}",
          " * @param strokeWidth     default {@link mxConstants.HIGHLIGHT_STROKEWIDTH}",
          " * @param dashed          default false",
          " */"
        ]
      ],
      "keepOnTop": [
        "keepOnTop: boolean;",
        [
          "/**",
          " * Specifies if the highlights should appear on top of everything else in the overlay pane.",
          " * @default false",
          " */"
        ]
      ],
      "graph": [
        "graph: boolean;",
        [
          "/**",
          " * Reference to the enclosing {@link mxGraph}.",
          " * @default true",
          " */"
        ]
      ],
      "state": [
        "state: mxCellState;",
        [
          "/**",
          " * Reference to the {@link mxCellState}.",
          " * @default null",
          " */"
        ]
      ],
      "spacing": [
        "spacing: number;",
        [
          "/**",
          " * Specifies the spacing between the highlight for vertices and the vertex.",
          " * @default 2",
          " */"
        ]
      ],
      "resetHandler": [
        "resetHandler: any;",
        [
          "/**",
          " * Holds the handler that automatically invokes reset if the highlight should be hidden.",
          " * @default null",
          " */"
        ]
      ],
      "setHighlightColor": [
        "setHighlightColor(color: string): void;",
        [
          "/**",
          " * Sets the color of the rectangle used to highlight drop targets.",
          " *",
          " * @param {string} color - String that represents the new highlight color.",
          " */"
        ]
      ],
      "drawHighlight": [
        "drawHighlight(): void;",
        [
          "/**",
          " * Creates and returns the highlight shape for the given state.",
          " */"
        ]
      ],
      "createShape": [
        "createShape(): mxShape;",
        [
          "/**",
          " * Creates and returns the highlight shape for the given state.",
          " */"
        ]
      ],
      "getStrokeWidth": [
        "getStrokeWidth(state: mxCellState): number;",
        [
          "/**",
          " * Updates the highlight after a change of the model or view.",
          " */"
        ]
      ],
      "repaint": [
        "repaint(): void;",
        [
          "/**",
          " * Updates the highlight after a change of the model or view.",
          " */"
        ]
      ],
      "hide": [
        "hide(): void;",
        [
          "/**",
          " * Resets the state of the cell marker.",
          " */"
        ]
      ],
      "highlight": [
        "highlight(state: mxCellState): void;",
        [
          "/**",
          " * Marks the <markedState> and fires a <mark> event.",
          " */"
        ]
      ],
      "isHighlightAt": [
        "isHighlightAt(x: number, y: number): boolean;",
        [
          "/**",
          " * Returns true if this highlight is at the given position.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Destroys the handler and all its resources and DOM nodes.",
          " */"
        ]
      ]
    }
  ],
  "mxGraphHandler": [
    null,
    {
      "cell": [
        "cell: mxCell;",
        null
      ],
      "cells": [
        "cells: Array<mxCell>;",
        null
      ],
      "first": [
        "first: mxPoint;",
        null
      ],
      "bounds": [
        "bounds: mxRectangle;",
        null
      ],
      "pBounds": [
        "pBounds: mxRectangle;",
        null
      ],
      "allCells": [
        "allCells: mxDictionary<any>;",
        null
      ],
      "cloning": [
        "cloning: boolean;",
        null
      ],
      "cellCount": [
        "cellCount: number;",
        null
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Variable: graph",
          " *",
          " * Reference to the enclosing <mxGraph>.",
          " */"
        ]
      ],
      "maxCells": [
        "maxCells: number;",
        [
          "/**",
          " * Variable: maxCells",
          " *",
          " * Defines the maximum number of cells to paint subhandles",
          " * for. Default is 50 for Firefox and 20 for IE. Set this",
          " * to 0 if you want an unlimited number of handles to be",
          " * displayed. This is only recommended if the number of",
          " * cells in the graph is limited to a small number, eg.",
          " * 500.",
          " */"
        ]
      ],
      "enabled": [
        "enabled: boolean;",
        [
          "/**",
          " * Variable: enabled",
          " *",
          " * Specifies if events are handled. Default is true.",
          " */"
        ]
      ],
      "highlightEnabled": [
        "highlightEnabled: boolean;",
        [
          "/**",
          " * Variable: highlightEnabled",
          " *",
          " * Specifies if drop targets under the mouse should be enabled. Default is",
          " * true.",
          " */"
        ]
      ],
      "cloneEnabled": [
        "cloneEnabled: boolean;",
        [
          "/**",
          " * Variable: cloneEnabled",
          " *",
          " * Specifies if cloning by control-drag is enabled. Default is true.",
          " */"
        ]
      ],
      "moveEnabled": [
        "moveEnabled: boolean;",
        [
          "/**",
          " * Variable: moveEnabled",
          " *",
          " * Specifies if moving is enabled. Default is true.",
          " */"
        ]
      ],
      "guidesEnabled": [
        "guidesEnabled: boolean;",
        [
          "/**",
          " * Variable: guidesEnabled",
          " *",
          " * Specifies if other cells should be used for snapping the right, center or",
          " * left side of the current selection. Default is false.",
          " */"
        ]
      ],
      "guide": [
        "guide: mxGuide;",
        [
          "/**",
          " * Variable: guide",
          " *",
          " * Holds the <mxGuide> instance that is used for alignment.",
          " */"
        ]
      ],
      "currentDx": [
        "currentDx: number;",
        [
          "/**",
          " * Variable: currentDx",
          " *",
          " * Stores the x-coordinate of the current mouse move.",
          " */"
        ]
      ],
      "currentDy": [
        "currentDy: number;",
        [
          "/**",
          " * Variable: currentDy",
          " *",
          " * Stores the y-coordinate of the current mouse move.",
          " */"
        ]
      ],
      "updateCursor": [
        "updateCursor: boolean;",
        [
          "/**",
          " * Variable: updateCursor",
          " *",
          " * Specifies if a move cursor should be shown if the mouse is over a movable",
          " * cell. Default is true.",
          " */"
        ]
      ],
      "selectEnabled": [
        "selectEnabled: boolean;",
        [
          "/**",
          " * Variable: selectEnabled",
          " *",
          " * Specifies if selecting is enabled. Default is true.",
          " */"
        ]
      ],
      "removeCellsFromParent": [
        "removeCellsFromParent: boolean;",
        [
          "/**",
          " * Variable: removeCellsFromParent",
          " *",
          " * Specifies if cells may be moved out of their parents. Default is true.",
          " */"
        ]
      ],
      "connectOnDrop": [
        "connectOnDrop: boolean;",
        [
          "/**",
          " * Variable: connectOnDrop",
          " *",
          " * Specifies if drop events are interpreted as new connections if no other",
          " * drop action is defined. Default is false.",
          " */"
        ]
      ],
      "scrollOnMove": [
        "scrollOnMove: boolean;",
        [
          "/**",
          " * Variable: scrollOnMove",
          " *",
          " * Specifies if the view should be scrolled so that a moved cell is",
          " * visible. Default is true.",
          " */"
        ]
      ],
      "minimumSize": [
        "minimumSize: number;",
        [
          "/**",
          " * Variable: minimumSize",
          " *",
          " * Specifies the minimum number of pixels for the width and height of a",
          " * selection border. Default is 6.",
          " */"
        ]
      ],
      "previewColor": [
        "previewColor: string;",
        [
          "/**",
          " * Variable: previewColor",
          " *",
          " * Specifies the color of the preview shape. Default is black.",
          " */"
        ]
      ],
      "htmlPreview": [
        "htmlPreview: boolean;",
        [
          "/**",
          " * Variable: htmlPreview",
          " *",
          " * Specifies if the graph container should be used for preview. If this is used",
          " * then drop target detection relies entirely on <mxGraph.getCellAt> because",
          " * the HTML preview does not \"let events through\". Default is false.",
          " */"
        ]
      ],
      "shape": [
        "shape: mxShape;",
        [
          "/**",
          " * Variable: shape",
          " *",
          " * Reference to the <mxShape> that represents the preview.",
          " */"
        ]
      ],
      "scaleGrid": [
        "scaleGrid: boolean;",
        [
          "/**",
          " * Variable: scaleGrid",
          " *",
          " * Specifies if the grid should be scaled. Default is false.",
          " */"
        ]
      ],
      "rotationEnabled": [
        "rotationEnabled: boolean;",
        [
          "/**",
          " * Variable: rotationEnabled",
          " *",
          " * Specifies if the bounding box should allow for rotation. Default is true.",
          " */"
        ]
      ],
      "maxLivePreview": [
        "maxLivePreview: number;",
        [
          "/**",
          " * Variable: maxLivePreview",
          " *",
          " * Maximum number of cells for which live preview should be used.  Default is 0 which means no live preview.",
          " */"
        ]
      ],
      "allowLivePreview": [
        "allowLivePreview: boolean;",
        [
          "/**",
          " * Variable allowLivePreview",
          " *",
          " * If live preview is allowed on this system.  Default is true for systems with SVG support.",
          " */"
        ]
      ],
      "constructor": [
        "constructor(graph: mxGraph);",
        [
          "/**",
          " * Variable allowLivePreview",
          " *",
          " * If live preview is allowed on this system.  Default is true for systems with SVG support.",
          " */"
        ]
      ],
      "isEnabled": [
        "isEnabled(): boolean;",
        [
          "/**",
          " * Function: isEnabled",
          " *",
          " * Returns <enabled>.",
          " */"
        ]
      ],
      "setEnabled": [
        "setEnabled(value: boolean): void;",
        [
          "/**",
          " * Function: setEnabled",
          " *",
          " * Sets <enabled>.",
          " */"
        ]
      ],
      "isCloneEnabled": [
        "isCloneEnabled(): boolean;",
        [
          "/**",
          " * Function: isCloneEnabled",
          " *",
          " * Returns <cloneEnabled>.",
          " */"
        ]
      ],
      "setCloneEnabled": [
        "setCloneEnabled(value: boolean): void;",
        [
          "/**",
          " * Function: setCloneEnabled",
          " *",
          " * Sets <cloneEnabled>.",
          " *",
          " * Parameters:",
          " *",
          " * value - Boolean that specifies the new clone enabled state.",
          " */"
        ]
      ],
      "isMoveEnabled": [
        "isMoveEnabled(): boolean;",
        [
          "/**",
          " * Function: isMoveEnabled",
          " *",
          " * Returns <moveEnabled>.",
          " */"
        ]
      ],
      "setMoveEnabled": [
        "setMoveEnabled(value: boolean): void;",
        [
          "/**",
          " * Function: setMoveEnabled",
          " *",
          " * Sets <moveEnabled>.",
          " */"
        ]
      ],
      "isSelectEnabled": [
        "isSelectEnabled(): boolean;",
        [
          "/**",
          " * Function: isSelectEnabled",
          " *",
          " * Returns <selectEnabled>.",
          " */"
        ]
      ],
      "setSelectEnabled": [
        "setSelectEnabled(value: boolean): void;",
        [
          "/**",
          " * Function: setSelectEnabled",
          " *",
          " * Sets <selectEnabled>.",
          " */"
        ]
      ],
      "isRemoveCellsFromParent": [
        "isRemoveCellsFromParent(): boolean;",
        [
          "/**",
          " * Function: isRemoveCellsFromParent",
          " *",
          " * Returns <removeCellsFromParent>.",
          " */"
        ]
      ],
      "setRemoveCellsFromParent": [
        "setRemoveCellsFromParent(value: boolean): void;",
        [
          "/**",
          " * Function: setRemoveCellsFromParent",
          " *",
          " * Sets <removeCellsFromParent>.",
          " */"
        ]
      ],
      "getInitialCellForEvent": [
        "getInitialCellForEvent(me: mxMouseEvent): mxCell;",
        [
          "/**",
          " * Function: getInitialCellForEvent",
          " *",
          " * Hook to return initial cell for the given event.",
          " */"
        ]
      ],
      "isDelayedSelection": [
        "isDelayedSelection(cell: mxCell, me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Function: isDelayedSelection",
          " *",
          " * Hook to return true for delayed selections.",
          " */"
        ]
      ],
      "consumeMouseEvent": [
        "consumeMouseEvent(evtName: string, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: consumeMouseEvent",
          " *",
          " * Consumes the given mouse event. NOTE: This may be used to enable click",
          " * events for links in labels on iOS as follows as consuming the initial",
          " * touchStart disables firing the subsequent click evnent on the link.",
          " *",
          " * <code>",
          " * consumeMouseEvent(evtName, me)",
          " * {",
          " *   var source = mxEvent.getSource(me.getEvent());",
          " *",
          " *   if (!mxEvent.isTouchEvent(me.getEvent()) || source.nodeName != 'A')",
          " *   {",
          " *     me.consume();",
          " *   }",
          " * }",
          " * </code>",
          " */"
        ]
      ],
      "mouseDown": [
        "mouseDown(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseDown",
          " *",
          " * Handles the event by selecing the given cell and creating a handle for",
          " * it. By consuming the event all subsequent events of the gesture are",
          " * redirected to this handler.",
          " */"
        ]
      ],
      "addStates": [
        "addStates(cell: mxCell, dict: any): number;",
        [
          "/**",
          " * Adds the states for the given cell recursively to the given dictionary.",
          " * @param cell",
          " * @param dict",
          " */"
        ]
      ],
      "getGuideStates": [
        "getGuideStates(): Array<mxCellState | mxPoint>;",
        [
          "/**",
          " * Function: getGuideStates",
          " *",
          " * Creates an array of cell states which should be used as guides.",
          " */"
        ]
      ],
      "getCells": [
        "getCells(initialCell: mxCell): mxCell[];",
        [
          "/**",
          " * Function: getCells",
          " *",
          " * Returns the cells to be modified by this handler. This implementation",
          " * returns all selection cells that are movable, or the given initial cell if",
          " * the given cell is not selected and movable. This handles the case of moving",
          " * unselectable or unselected cells.",
          " *",
          " * Parameters:",
          " *",
          " * initialCell - <mxCell> that triggered this handler.",
          " */"
        ]
      ],
      "getPreviewBounds": [
        "getPreviewBounds(cells: mxCell[]): mxRectangle;",
        [
          "/**",
          " * Function: getPreviewBounds",
          " *",
          " * Returns the <mxRectangle> used as the preview bounds for",
          " * moving the given cells.",
          " */"
        ]
      ],
      "getBoundingBox": [
        "getBoundingBox(cells: mxCell[]): mxRectangle;",
        [
          "/**",
          " * Function: getBoundingBox",
          " *",
          " * Returns the union of the <mxCellStates> for the given array of <mxCells>.",
          " * For vertices, this method uses the bounding box of the corresponding shape",
          " * if one exists. The bounding box of the corresponding text label and all",
          " * controls and overlays are ignored. See also: <mxGraphView.getBounds> and",
          " * <mxGraph.getBoundingBox>.",
          " *",
          " * Parameters:",
          " *",
          " * cells - Array of <mxCells> whose bounding box should be returned.",
          " */"
        ]
      ],
      "createPreviewShape": [
        "createPreviewShape(bounds: mxRectangle): mxRectangleShape;",
        [
          "/**",
          " * Function: createPreviewShape",
          " *",
          " * Creates the shape used to draw the preview for the given bounds.",
          " */"
        ]
      ],
      "start": [
        "start(cell: mxCell, x: number, y: number): void;",
        [
          "/**",
          " * Function: start",
          " *",
          " * Starts the handling of the mouse gesture.",
          " */"
        ]
      ],
      "useGuidesForEvent": [
        "useGuidesForEvent(me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Function: useGuidesForEvent",
          " *",
          " * Returns true if the guides should be used for the given <mxMouseEvent>.",
          " * This implementation returns <mxGuide.isEnabledForEvent>.",
          " */"
        ]
      ],
      "snap": [
        "snap(vector: mxPoint): mxPoint;",
        [
          "/**",
          " * Function: snap",
          " *",
          " * Snaps the given vector to the grid and returns the given mxPoint instance.",
          " */"
        ]
      ],
      "getDelta": [
        "getDelta(me: mxMouseEvent): mxPoint;",
        [
          "/**",
          " * Function: getDelta",
          " *",
          " * Returns an <mxPoint> that represents the vector for moving the cells",
          " * for the given <mxMouseEvent>.",
          " */"
        ]
      ],
      "updateHint": [
        "updateHint(me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: updateHint",
          " *",
          " * Hook for subclassers do show details while the handler is active.",
          " */"
        ]
      ],
      "removeHint": [
        "removeHint(): void;",
        [
          "/**",
          " * Function: removeHint",
          " *",
          " * Hooks for subclassers to hide details when the handler gets inactive.",
          " */"
        ]
      ],
      "roundLength": [
        "roundLength(length: number): number;",
        [
          "/**",
          " * Function: roundLength",
          " *",
          " * Hook for rounding the unscaled vector. This uses Math.round.",
          " */"
        ]
      ],
      "mouseMove": [
        "mouseMove(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseMove",
          " *",
          " * Handles the event by highlighting possible drop targets and updating the",
          " * preview.",
          " */"
        ]
      ],
      "updatePreviewShape": [
        "updatePreviewShape(): void;",
        [
          "/**",
          " * Function: updatePreviewShape",
          " *",
          " * Updates the bounds of the preview shape.",
          " */"
        ]
      ],
      "setHighlightColor": [
        "setHighlightColor(color: string): void;",
        [
          "/**",
          " * Function: setHighlightColor",
          " *",
          " * Sets the color of the rectangle used to highlight drop targets.",
          " *",
          " * Parameters:",
          " *",
          " * color - String that represents the new highlight color.",
          " */"
        ]
      ],
      "mouseUp": [
        "mouseUp(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseUp",
          " *",
          " * Handles the event by applying the changes to the selection cells.",
          " */"
        ]
      ],
      "selectDelayed": [
        "selectDelayed(me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: selectDelayed",
          " *",
          " * Implements the delayed selection for the given mouse event.",
          " */"
        ]
      ],
      "reset": [
        "reset(): void;",
        [
          "/**",
          " * Function: reset",
          " *",
          " * Resets the state of this handler.",
          " */"
        ]
      ],
      "shouldRemoveCellsFromParent": [
        "shouldRemoveCellsFromParent(parent: mxCell, cells: mxCell[], evt: Event): boolean;",
        [
          "/**",
          " * Function: shouldRemoveCellsFromParent",
          " *",
          " * Returns true if the given cells should be removed from the parent for the specified",
          " * mousereleased event.",
          " */"
        ]
      ],
      "moveCells": [
        "moveCells(cells: mxCell[], dx: number, dy: number, clone: boolean, target: mxCell, evt: Event): void;",
        [
          "/**",
          " * Function: moveCells",
          " *",
          " * Moves the given cells by the specified amount.",
          " */"
        ]
      ],
      "destroyShapes": [
        "destroyShapes(): void;",
        [
          "/**",
          " * Function: destroyShapes",
          " *",
          " * Destroy the preview and highlight shapes.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Function: destroy",
          " *",
          " * Destroys the handler and all its resources and DOM nodes.",
          " */"
        ]
      ]
    }
  ],
  "mxEdgeHandler": [
    [
      "/**",
      " * Graph event handler that reconnects edges and modifies control points and the edge",
      " * label location.",
      " * Uses <mxTerminalMarker> for finding and highlighting new source and target vertices.",
      " * This handler is automatically created in mxGraph.createHandler for each selected edge.",
      " * **To enable adding/removing control points, the following code can be used**",
      " * @example",
      " * ```",
      " * mxEdgeHandler.prototype.addEnabled = true;",
      " * mxEdgeHandler.prototype.removeEnabled = true;",
      " * ```",
      " * Note: This experimental feature is not recommended for production use.",
      " * @class mxEdgeHandler",
      " */"
    ],
    {
      "labelHandleImage": [
        "labelHandleImage: mxImage;",
        null
      ],
      "constructor": [
        "constructor(state: mxCellState);",
        null
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Variable: graph",
          " *",
          " * Reference to the enclosing <mxGraph>.",
          " */"
        ]
      ],
      "state": [
        "state: mxCellState;",
        [
          "/**",
          " * Variable: state",
          " *",
          " * Reference to the <mxCellState> being modified.",
          " */"
        ]
      ],
      "marker": [
        "marker: any;",
        [
          "/**",
          " * Variable: marker",
          " *",
          " * Holds the <mxTerminalMarker> which is used for highlighting terminals.",
          " */"
        ]
      ],
      "constraintHandler": [
        "constraintHandler: mxConstraintHandler;",
        [
          "/**",
          " * Variable: constraintHandler",
          " *",
          " * Holds the <mxConstraintHandler> used for drawing and highlighting",
          " * constraints.",
          " */"
        ]
      ],
      "error": [
        "error: string;",
        [
          "/**",
          " * Variable: error",
          " *",
          " * Holds the current validation error while a connection is being changed.",
          " */"
        ]
      ],
      "shape": [
        "shape: mxShape;",
        [
          "/**",
          " * Variable: shape",
          " *",
          " * Holds the <mxShape> that represents the preview edge.",
          " */"
        ]
      ],
      "bends": [
        "bends: mxShape[];",
        [
          "/**",
          " * Variable: bends",
          " *",
          " * Holds the <mxShapes> that represent the points.",
          " */"
        ]
      ],
      "labelShape": [
        "labelShape: mxShape;",
        [
          "/**",
          " * Variable: labelShape",
          " *",
          " * Holds the <mxShape> that represents the label position.",
          " */"
        ]
      ],
      "cloneEnabled": [
        "cloneEnabled: boolean;",
        [
          "/**",
          " * Variable: cloneEnabled",
          " *",
          " * Specifies if cloning by control-drag is enabled. Default is true.",
          " */"
        ]
      ],
      "addEnabled": [
        "addEnabled: boolean;",
        [
          "/**",
          " * Variable: addEnabled",
          " *",
          " * Specifies if adding bends by shift-click is enabled. Default is false.",
          " * Note: This experimental feature is not recommended for production use.",
          " */"
        ]
      ],
      "removeEnabled": [
        "removeEnabled: boolean;",
        [
          "/**",
          " * Variable: removeEnabled",
          " *",
          " * Specifies if removing bends by shift-click is enabled. Default is false.",
          " * Note: This experimental feature is not recommended for production use.",
          " */"
        ]
      ],
      "dblClickRemoveEnabled": [
        "dblClickRemoveEnabled: boolean;",
        [
          "/**",
          " * Variable: dblClickRemoveEnabled",
          " *",
          " * Specifies if removing bends by double click is enabled. Default is false.",
          " */"
        ]
      ],
      "mergeRemoveEnabled": [
        "mergeRemoveEnabled: boolean;",
        [
          "/**",
          " * Variable: mergeRemoveEnabled",
          " *",
          " * Specifies if removing bends by dropping them on other bends is enabled.",
          " * Default is false.",
          " */"
        ]
      ],
      "straightRemoveEnabled": [
        "straightRemoveEnabled: boolean;",
        [
          "/**",
          " * Variable: straightRemoveEnabled",
          " *",
          " * Specifies if removing bends by creating straight segments should be enabled.",
          " * If enabled, this can be overridden by holding down the alt key while moving.",
          " * Default is false.",
          " */"
        ]
      ],
      "virtualBendsEnabled": [
        "virtualBendsEnabled: boolean;",
        [
          "/**",
          " * Variable: virtualBendsEnabled",
          " *",
          " * Specifies if virtual bends should be added in the center of each",
          " * segments. These bends can then be used to add new waypoints.",
          " * Default is false.",
          " */"
        ]
      ],
      "virtualBendOpacity": [
        "virtualBendOpacity: number;",
        [
          "/**",
          " * Variable: virtualBendOpacity",
          " *",
          " * Opacity to be used for virtual bends (see <virtualBendsEnabled>).",
          " * Default is 20.",
          " */"
        ]
      ],
      "parentHighlightEnabled": [
        "parentHighlightEnabled: boolean;",
        [
          "/**",
          " * Variable: parentHighlightEnabled",
          " *",
          " * Specifies if the parent should be highlighted if a child cell is selected.",
          " * Default is false.",
          " */"
        ]
      ],
      "preferHtml": [
        "preferHtml: boolean;",
        [
          "/**",
          " * Variable: preferHtml",
          " *",
          " * Specifies if bends should be added to the graph container. This is updated",
          " * in <init> based on whether the edge or one of its terminals has an HTML",
          " * label in the container.",
          " */"
        ]
      ],
      "allowHandleBoundsCheck": [
        "allowHandleBoundsCheck: boolean;",
        [
          "/**",
          " * Variable: allowHandleBoundsCheck",
          " *",
          " * Specifies if the bounds of handles should be used for hit-detection in IE",
          " * Default is true.",
          " */"
        ]
      ],
      "snapToTerminals": [
        "snapToTerminals: boolean;",
        [
          "/**",
          " * Variable: snapToTerminals",
          " *",
          " * Specifies if waypoints should snap to the routing centers of terminals.",
          " * Default is false.",
          " */"
        ]
      ],
      "handleImage": [
        "handleImage: mxImage;",
        [
          "/**",
          " * Variable: handleImage",
          " *",
          " * Optional <mxImage> to be used as handles. Default is null.",
          " */"
        ]
      ],
      "tolerance": [
        "tolerance: number;",
        [
          "/**",
          " * Variable: tolerance",
          " *",
          " * Optional tolerance for hit-detection in <getHandleForEvent>. Default is 0.",
          " */"
        ]
      ],
      "outlineConnect": [
        "outlineConnect: boolean;",
        [
          "/**",
          " * Variable: outlineConnect",
          " *",
          " * Specifies if connections to the outline of a highlighted target should be",
          " * enabled. This will allow to place the connection point along the outline of",
          " * the highlighted target. Default is false.",
          " */"
        ]
      ],
      "manageLabelHandle": [
        "manageLabelHandle: boolean;",
        [
          "/**",
          " * Variable: manageLabelHandle",
          " *",
          " * Specifies if the label handle should be moved if it intersects with another",
          " * handle. Uses <checkLabelHandle> for checking and moving. Default is false.",
          " */"
        ]
      ],
      "init": [
        "init(): void;",
        [
          "/**",
          " * Function: init",
          " *",
          " * Initializes the shapes required for this edge handler.",
          " */"
        ]
      ],
      "createCustomHandles": [
        "createCustomHandles(): any[];",
        [
          "/**",
          " * Function: createCustomHandles",
          " *",
          " * Returns an array of custom handles. This implementation returns null.",
          " */"
        ]
      ],
      "isVirtualBendsEnabled": [
        "isVirtualBendsEnabled(evt: Event): boolean;",
        [
          "/**",
          " * Function: isVirtualBendsEnabled",
          " *",
          " * Returns true if virtual bends should be added. This returns true if",
          " * <virtualBendsEnabled> is true and the current style allows and",
          " * renders custom waypoints.",
          " */"
        ]
      ],
      "isAddPointEvent": [
        "isAddPointEvent(evt: Event): boolean;",
        [
          "/**",
          " * Function: isAddPointEvent",
          " *",
          " * Returns true if the given event is a trigger to add a new point. This",
          " * implementation returns true if shift is pressed.",
          " */"
        ]
      ],
      "isRemovePointEvent": [
        "isRemovePointEvent(evt: Event): boolean;",
        [
          "/**",
          " * Function: isRemovePointEvent",
          " *",
          " * Returns true if the given event is a trigger to remove a point. This",
          " * implementation returns true if shift is pressed.",
          " */"
        ]
      ],
      "getSelectionPoints": [
        "getSelectionPoints(state: mxCellState): mxPoint[];",
        [
          "/**",
          " * Function: getSelectionPoints",
          " *",
          " * Returns the list of points that defines the selection stroke.",
          " */"
        ]
      ],
      "createParentHighlightShape": [
        "createParentHighlightShape(bounds: mxRectangle): mxRectangleShape;",
        [
          "/**",
          " * Function: createSelectionShape",
          " *",
          " * Creates the shape used to draw the selection border.",
          " */"
        ]
      ],
      "createSelectionShape": [
        "createSelectionShape(points: mxPoint[]): mxShape;",
        [
          "/**",
          " * Function: createSelectionShape",
          " *",
          " * Creates the shape used to draw the selection border.",
          " */"
        ]
      ],
      "getSelectionColor": [
        "getSelectionColor(): string;",
        [
          "/**",
          " * Function: getSelectionColor",
          " *",
          " * Returns <mxConstants.EDGE_SELECTION_COLOR>.",
          " */"
        ]
      ],
      "getSelectionStrokeWidth": [
        "getSelectionStrokeWidth(): number;",
        [
          "/**",
          " * Function: getSelectionStrokeWidth",
          " *",
          " * Returns <mxConstants.EDGE_SELECTION_STROKEWIDTH>.",
          " */"
        ]
      ],
      "isSelectionDashed": [
        "isSelectionDashed(): boolean;",
        [
          "/**",
          " * Function: isSelectionDashed",
          " *",
          " * Returns <mxConstants.EDGE_SELECTION_DASHED>.",
          " */"
        ]
      ],
      "isConnectableCell": [
        "isConnectableCell(cell: mxCell): boolean;",
        [
          "/**",
          " * Function: isConnectableCell",
          " *",
          " * Returns true if the given cell is connectable. This is a hook to",
          " * disable floating connections. This implementation returns true.",
          " */"
        ]
      ],
      "getCellAt": [
        "getCellAt(x: number, y: number): mxCell;",
        [
          "/**",
          " * Function: getCellAt",
          " *",
          " * Creates and returns the <mxCellMarker> used in <marker>.",
          " */"
        ]
      ],
      "createMarker": [
        "createMarker(): mxCellMarker;",
        [
          "/**",
          " * Function: createMarker",
          " *",
          " * Creates and returns the <mxCellMarker> used in <marker>.",
          " */"
        ]
      ],
      "validateConnection": [
        "validateConnection(source: mxCell, target: mxCell): string;",
        [
          "/**",
          " * Function: validateConnection",
          " *",
          " * Returns the error message or an empty string if the connection for the",
          " * given source, target pair is not valid. Otherwise it returns null. This",
          " * implementation uses <mxGraph.getEdgeValidationError>.",
          " *",
          " * Parameters:",
          " *",
          " * source - <mxCell> that represents the source terminal.",
          " * target - <mxCell> that represents the target terminal.",
          " */"
        ]
      ],
      "createBends": [
        "createBends(): mxRectangleShape[];",
        [
          "/**",
          " * Function: createBends",
          " *",
          " * Creates and returns the bends used for modifying the edge. This is",
          " * typically an array of <mxRectangleShapes>.",
          " */"
        ]
      ],
      "createVirtualBends": [
        "createVirtualBends(): mxRectangleShape[];",
        [
          "/**",
          " * Function: createVirtualBends",
          " *",
          " * Creates and returns the bends used for modifying the edge. This is",
          " * typically an array of <mxRectangleShapes>.",
          " */"
        ]
      ],
      "isHandleEnabled": [
        "isHandleEnabled(index: number): boolean;",
        [
          "/**",
          " * Function: isHandleEnabled",
          " *",
          " * Creates the shape used to display the given bend.",
          " */"
        ]
      ],
      "isHandleVisible": [
        "isHandleVisible(index: number): boolean;",
        [
          "/**",
          " * Function: isHandleVisible",
          " *",
          " * Returns true if the handle at the given index is visible.",
          " */"
        ]
      ],
      "createHandleShape": [
        "createHandleShape(index: number): mxRectangleShape;",
        [
          "/**",
          " * Function: createHandleShape",
          " *",
          " * Creates the shape used to display the given bend. Note that the index may be",
          " * null for special cases, such as when called from",
          " * <mxElbowEdgeHandler.createVirtualBend>. Only images and rectangles should be",
          " * returned if support for HTML labels with not foreign objects is required.",
          " * Index if null for virtual handles.",
          " */"
        ]
      ],
      "createLabelHandleShape": [
        "createLabelHandleShape(): mxRectangleShape;",
        [
          "/**",
          " * Function: createLabelHandleShape",
          " *",
          " * Creates the shape used to display the the label handle.",
          " */"
        ]
      ],
      "initBend": [
        "initBend(bend: mxShape, dblClick: (evt: Event) => void): boolean;",
        [
          "/**",
          " * Function: initBend",
          " *",
          " * Helper method to initialize the given bend.",
          " *",
          " * Parameters:",
          " *",
          " * bend - <mxShape> that represents the bend to be initialized.",
          " */"
        ]
      ],
      "getHandleForEvent": [
        "getHandleForEvent(me: mxMouseEvent): number | boolean;",
        [
          "/**",
          " * Function: getHandleForEvent",
          " *",
          " * Returns the index of the handle for the given event.",
          " */"
        ]
      ],
      "isAddVirtualBendEvent": [
        "isAddVirtualBendEvent(me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Function: isAddVirtualBendEvent",
          " *",
          " * Returns true if the given event allows virtual bends to be added. This",
          " * implementation returns true.",
          " */"
        ]
      ],
      "isCustomHandleEvent": [
        "isCustomHandleEvent(me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Function: isCustomHandleEvent",
          " *",
          " * Returns true if the given event allows custom handles to be changed. This",
          " * implementation returns true.",
          " */"
        ]
      ],
      "mouseDown": [
        "mouseDown(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseDown",
          " *",
          " * Handles the event by checking if a special element of the handler",
          " * was clicked, in which case the index parameter is non-null. The",
          " * indices may be one of <LABEL_HANDLE> or the number of the respective",
          " * control point. The source and target points are used for reconnecting",
          " * the edge.",
          " */"
        ]
      ],
      "start": [
        "start(x: number, y: number, index: number): void;",
        [
          "/**",
          " * Function: start",
          " *",
          " * Starts the handling of the mouse gesture.",
          " */"
        ]
      ],
      "clonePreviewState": [
        "clonePreviewState(point: mxPoint, terminal: mxCell): mxCellState;",
        [
          "/**",
          " * Function: clonePreviewState",
          " *",
          " * Returns a clone of the current preview state for the given point and terminal.",
          " */"
        ]
      ],
      "getSnapToTerminalTolerance": [
        "getSnapToTerminalTolerance(): number;",
        [
          "/**",
          " * Function: getSnapToTerminalTolerance",
          " *",
          " * Returns the tolerance for the guides. Default value is",
          " * gridSize * scale / 2.",
          " */"
        ]
      ],
      "updateHint": [
        "updateHint(me: mxMouseEvent, point: mxPoint): void;",
        [
          "/**",
          " * Function: updateHint",
          " *",
          " * Hook for subclassers do show details while the handler is active.",
          " */"
        ]
      ],
      "removeHint": [
        "removeHint(): void;",
        [
          "/**",
          " * Function: removeHint",
          " *",
          " * Hooks for subclassers to hide details when the handler gets inactive.",
          " */"
        ]
      ],
      "roundLength": [
        "roundLength(length: number): number;",
        [
          "/**",
          " * Function: roundLength",
          " *",
          " * Hook for rounding the unscaled width or height. This uses Math.round.",
          " */"
        ]
      ],
      "isSnapToTerminalsEvent": [
        "isSnapToTerminalsEvent(me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Function: isSnapToTerminalsEvent",
          " *",
          " * Returns true if <snapToTerminals> is true and if alt is not pressed.",
          " */"
        ]
      ],
      "getPointForEvent": [
        "getPointForEvent(me: mxMouseEvent): mxPoint;",
        [
          "/**",
          " * Function: getPointForEvent",
          " *",
          " * Returns the point for the given event.",
          " */"
        ]
      ],
      "getPreviewTerminalState": [
        "getPreviewTerminalState(me: mxMouseEvent): mxCellState;",
        [
          "/**",
          " * Function: getPreviewTerminalState",
          " *",
          " * Updates the given preview state taking into account the state of the constraint handler.",
          " */"
        ]
      ],
      "getPreviewPoints": [
        "getPreviewPoints(pt: mxPoint, me?: mxMouseEvent): mxPoint[];",
        [
          "/**",
          " * Function: getPreviewPoints",
          " *",
          " * Updates the given preview state taking into account the state of the constraint handler.",
          " *",
          " * Parameters:",
          " *",
          " * pt - <mxPoint> that contains the current pointer position.",
          " * me - Optional <mxMouseEvent> that contains the current event.",
          " */"
        ]
      ],
      "isOutlineConnectEvent": [
        "isOutlineConnectEvent(me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Function: isOutlineConnectEvent",
          " *",
          " * Returns true if <outlineConnect> is true and the source of the event is the outline shape",
          " * or shift is pressed.",
          " */"
        ]
      ],
      ")": [
        "): void;",
        [
          "/**",
          " * Function: updatePreviewState",
          " *",
          " * Updates the given preview state taking into account the state of the constraint handler.",
          " */"
        ]
      ],
      "mouseMove": [
        "mouseMove(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseMove",
          " *",
          " * Handles the event by updating the preview.",
          " */"
        ]
      ],
      "mouseUp": [
        "mouseUp(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseUp",
          " *",
          " * Handles the event to applying the previewed changes on the edge by",
          " * using <moveLabel>, <connect> or <changePoints>.",
          " */"
        ]
      ],
      "reset": [
        "reset(): void;",
        [
          "/**",
          " * Function: reset",
          " *",
          " * Resets the state of this handler.",
          " */"
        ]
      ],
      "setPreviewColor": [
        "setPreviewColor(color: string): void;",
        [
          "/**",
          " * Function: setPreviewColor",
          " *",
          " * Sets the color of the preview to the given value.",
          " */"
        ]
      ],
      "convertPoint": [
        "convertPoint(point: mxPoint, gridEnabled: boolean): void;",
        [
          "/**",
          " * Function: convertPoint",
          " *",
          " * Converts the given point in-place from screen to unscaled, untranslated",
          " * graph coordinates and applies the grid. Returns the given, modified",
          " * point instance.",
          " *",
          " * Parameters:",
          " *",
          " * point - <mxPoint> to be converted.",
          " * gridEnabled - Boolean that specifies if the grid should be applied.",
          " */"
        ]
      ],
      "moveLabel": [
        "moveLabel(edgeState: mxCellState, x: number, y: number): void;",
        [
          "/**",
          " * Function: moveLabel",
          " *",
          " * Changes the coordinates for the label of the given edge.",
          " *",
          " * Parameters:",
          " *",
          " * edge - <mxCell> that represents the edge.",
          " * x - Integer that specifies the x-coordinate of the new location.",
          " * y - Integer that specifies the y-coordinate of the new location.",
          " */"
        ]
      ],
      "connect": [
        "connect(edge: mxCell, terminal: mxCell, isSource: boolean, isClone: boolean, me: mxMouseEvent): mxCell;",
        [
          "/**",
          " * Function: connect",
          " *",
          " * Changes the terminal or terminal point of the given edge in the graph",
          " * model.",
          " *",
          " * Parameters:",
          " *",
          " * edge - <mxCell> that represents the edge to be reconnected.",
          " * terminal - <mxCell> that represents the new terminal.",
          " * isSource - Boolean indicating if the new terminal is the source or",
          " * target terminal.",
          " * isClone - Boolean indicating if the new connection should be a clone of",
          " * the old edge.",
          " * me - <mxMouseEvent> that contains the mouse up event.",
          " */"
        ]
      ],
      "changeTerminalPoint": [
        "changeTerminalPoint(edge: mxCell, point: mxPoint, isSource: boolean, clone: boolean): mxCell;",
        [
          "/**",
          " * Function: changeTerminalPoint",
          " *",
          " * Changes the terminal point of the given edge.",
          " */"
        ]
      ],
      "changePoints": [
        "changePoints(edge: mxCell, points: mxPoint[], clone: boolean): mxCell;",
        [
          "/**",
          " * Function: changePoints",
          " *",
          " * Changes the control points of the given edge in the graph model.",
          " */"
        ]
      ],
      "addPoint": [
        "addPoint(state: mxCellState, evt: Event): void;",
        [
          "/**",
          " * Function: addPoint",
          " *",
          " * Adds a control point for the given state and event.",
          " */"
        ]
      ],
      "addPointAt": [
        "addPointAt(state: mxCellState, x: number, y: number): void;",
        [
          "/**",
          " * Function: addPointAt",
          " *",
          " * Adds a control point at the given point.",
          " */"
        ]
      ],
      "removePoint": [
        "removePoint(state: mxCellState, index: number): void;",
        [
          "/**",
          " * Function: removePoint",
          " *",
          " * Removes the control point at the given index from the given state.",
          " */"
        ]
      ],
      "getHandleFillColor": [
        "getHandleFillColor(index: number): string;",
        [
          "/**",
          " * Function: getHandleFillColor",
          " *",
          " * Returns the fillcolor for the handle at the given index.",
          " */"
        ]
      ],
      "redraw": [
        "redraw(): void;",
        [
          "/**",
          " * Function: redraw",
          " *",
          " * Redraws the preview, and the bends- and label control points.",
          " */"
        ]
      ],
      "redrawHandles": [
        "redrawHandles(): void;",
        [
          "/**",
          " * Function: redrawHandles",
          " *",
          " * Redraws the handles.",
          " */"
        ]
      ],
      "setHandlesVisible": [
        "setHandlesVisible(visible: boolean): void;",
        [
          "/**",
          " * Function: hideHandles",
          " *",
          " * Shortcut to <hideSizers>.",
          " */"
        ]
      ],
      "redrawInnerBends": [
        "redrawInnerBends(p0: mxPoint, pe: mxPoint): void;",
        [
          "/**",
          " * Function: redrawInnerBends",
          " *",
          " * Updates and redraws the inner bends.",
          " *",
          " * Parameters:",
          " *",
          " * p0 - <mxPoint> that represents the location of the first point.",
          " * pe - <mxPoint> that represents the location of the last point.",
          " */"
        ]
      ],
      "checkLabelHandle": [
        "checkLabelHandle(b: mxRectangle): void;",
        [
          "/**",
          " * Function: checkLabelHandle",
          " *",
          " * Checks if the label handle intersects the given bounds and moves it if it",
          " * intersects.",
          " */"
        ]
      ],
      "drawPreview": [
        "drawPreview(): void;",
        [
          "/**",
          " * Function: drawPreview",
          " *",
          " * Redraws the preview.",
          " */"
        ]
      ],
      "refresh": [
        "refresh(): void;",
        [
          "/**",
          " * Function: refresh",
          " *",
          " * Refreshes the bends of this handler.",
          " */"
        ]
      ],
      "destroyBends": [
        "destroyBends(bends: mxShape[]): void;",
        [
          "/**",
          " * Function: destroyBends",
          " *",
          " * Destroys all elements in <bends>.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Function: destroy",
          " *",
          " * Destroys the handler and all its resources and DOM nodes. This does",
          " * normally not need to be called as handlers are destroyed automatically",
          " * when the corresponding cell is deselected.",
          " */"
        ]
      ]
    }
  ],
  "mxEdgeSegmentHandler": [
    null,
    {
      "constructor": [
        "constructor(state: mxCellState);",
        null
      ],
      "getCurrentPoints": [
        "getCurrentPoints(): mxPoint[];",
        [
          "/**",
          " * Function: getCurrentPoints",
          " *",
          " * Returns the current absolute points.",
          " */"
        ]
      ],
      "getPreviewPoints": [
        "getPreviewPoints(point: mxPoint): mxPoint[];",
        [
          "/**",
          " * Function: getPreviewPoints",
          " *",
          " * Updates the given preview state taking into account the state of the constraint handler.",
          " */"
        ]
      ],
      "updatePreviewState": [
        "updatePreviewState(edge: mxCell, point: mxPoint, terminalState: mxCellState, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: updatePreviewState",
          " *",
          " * Overridden to perform optimization of the edge style result.",
          " */"
        ]
      ],
      "connect": [
        "connect(edge: mxCell, terminal: mxCell, isSource: boolean, isClone: boolean, me: mxMouseEvent): mxCell;",
        [
          "/**",
          " * Overriden to merge edge segments.",
          " */"
        ]
      ],
      "getTooltipForNode": [
        "getTooltipForNode(node: any): string;",
        [
          "/**",
          " * Function: getTooltipForNode",
          " *",
          " * Returns no tooltips.",
          " */"
        ]
      ],
      "start": [
        "start(x: number, y: number, index: number): void;",
        [
          "/**",
          " * Function: createBends",
          " *",
          " * Adds custom bends for the center of each segment.",
          " */"
        ]
      ],
      "// createBends": [
        "// createBends(): mxShape[];",
        [
          "/**",
          " * Function: createBends",
          " *",
          " * Adds custom bends for the center of each segment.",
          " */"
        ]
      ],
      "redraw": [
        "redraw(): void;",
        [
          "/**",
          " * Function: redraw",
          " *",
          " * Overridden to invoke <refresh> before the redraw.",
          " */"
        ]
      ],
      "redrawInnerBends": [
        "redrawInnerBends(p0: mxPoint, pe: mxPoint): void;",
        [
          "/**",
          " * Function: redrawInnerBends",
          " *",
          " * Updates the position of the custom bends.",
          " */"
        ]
      ]
    }
  ],
  "mxRubberband": [
    [
      "/**",
      " * Event handler that selects rectangular regions.",
      " * This is not built-into [mxGraph].",
      " * To enable rubberband selection in a graph, use the following code.",
      " */"
    ],
    {
      "graph": [
        "graph: mxGraph;",
        null
      ],
      "fadeOut": [
        "fadeOut: boolean;",
        [
          "/**",
          " * Optional fade out effect.  Default is false.",
          " */"
        ]
      ],
      "defaultOpacity": [
        "defaultOpacity: number;",
        [
          "/**",
          " * Specifies the default opacity to be used for the rubberband div.  Default is 20.",
          " */"
        ]
      ],
      "constructor": [
        "constructor(graph: mxGraph);",
        [
          "/**",
          " * Constructs an event handler that selects rectangular regions in the graph using rubberband selection.",
          " */"
        ]
      ],
      "createShape": [
        "createShape(): HTMLElement;",
        [
          "/**",
          " * Creates the rubberband selection shape.",
          " */"
        ]
      ],
      "isEnabled": [
        "isEnabled(): boolean;",
        [
          "/**",
          " * Creates the rubberband selection shape.",
          " */"
        ]
      ],
      "start": [
        "start(x: number, y: number): void;",
        [
          "/**",
          " * Creates the rubberband selection shape.",
          " */"
        ]
      ]
    }
  ],
  "mxPanningHandler": [
    null,
    {
      "constructor": [
        "constructor(graph: mxGraph);",
        null
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Variable: graph",
          " *",
          " * Reference to the enclosing <mxGraph>.",
          " */"
        ]
      ],
      "useLeftButtonForPanning": [
        "useLeftButtonForPanning: boolean;",
        [
          "/**",
          " * Variable: useLeftButtonForPanning",
          " *",
          " * Specifies if panning should be active for the left mouse button.",
          " * Setting this to true may conflict with <mxRubberband>. Default is false.",
          " */"
        ]
      ],
      "usePopupTrigger": [
        "usePopupTrigger: boolean;",
        [
          "/**",
          " * Variable: usePopupTrigger",
          " *",
          " * Specifies if <mxEvent.isPopupTrigger> should also be used for panning.",
          " */"
        ]
      ],
      "ignoreCell": [
        "ignoreCell: boolean;",
        [
          "/**",
          " * Variable: ignoreCell",
          " *",
          " * Specifies if panning should be active even if there is a cell under the",
          " * mousepointer. Default is false.",
          " */"
        ]
      ],
      "previewEnabled": [
        "previewEnabled: boolean;",
        [
          "/**",
          " * Variable: previewEnabled",
          " *",
          " * Specifies if the panning should be previewed. Default is true.",
          " */"
        ]
      ],
      "useGrid": [
        "useGrid: boolean;",
        [
          "/**",
          " * Variable: useGrid",
          " *",
          " * Specifies if the panning steps should be aligned to the grid size.",
          " * Default is false.",
          " */"
        ]
      ],
      "panningEnabled": [
        "panningEnabled: boolean;",
        [
          "/**",
          " * Variable: panningEnabled",
          " *",
          " * Specifies if panning should be enabled. Default is true.",
          " */"
        ]
      ],
      "pinchEnabled": [
        "pinchEnabled: boolean;",
        [
          "/**",
          " * Variable: pinchEnabled",
          " *",
          " * Specifies if pinch gestures should be handled as zoom. Default is true.",
          " */"
        ]
      ],
      "maxScale": [
        "maxScale: number;",
        [
          "/**",
          " * Variable: maxScale",
          " *",
          " * Specifies the maximum scale. Default is 8.",
          " */"
        ]
      ],
      "minScale": [
        "minScale: number;",
        [
          "/**",
          " * Variable: minScale",
          " *",
          " * Specifies the minimum scale. Default is 0.01.",
          " */"
        ]
      ],
      "dx": [
        "dx: number;",
        [
          "/**",
          " * Variable: dx",
          " *",
          " * Holds the current horizontal offset.",
          " */"
        ]
      ],
      "dy": [
        "dy: number;",
        [
          "/**",
          " * Variable: dy",
          " *",
          " * Holds the current vertical offset.",
          " */"
        ]
      ],
      "startX": [
        "startX: number;",
        [
          "/**",
          " * Variable: startX",
          " *",
          " * Holds the x-coordinate of the start point.",
          " */"
        ]
      ],
      "startY": [
        "startY: number;",
        [
          "/**",
          " * Variable: startY",
          " *",
          " * Holds the y-coordinate of the start point.",
          " */"
        ]
      ],
      "isActive": [
        "isActive(): boolean;",
        [
          "/**",
          " * Function: isActive",
          " *",
          " * Returns true if the handler is currently active.",
          " */"
        ]
      ],
      "isPanningEnabled": [
        "isPanningEnabled(): boolean;",
        [
          "/**",
          " * Function: isPanningEnabled",
          " *",
          " * Returns <panningEnabled>.",
          " */"
        ]
      ],
      "setPanningEnabled": [
        "setPanningEnabled(value: boolean): void;",
        [
          "/**",
          " * Function: setPanningEnabled",
          " *",
          " * Sets <panningEnabled>.",
          " */"
        ]
      ],
      "isPinchEnabled": [
        "isPinchEnabled(): boolean;",
        [
          "/**",
          " * Function: isPinchEnabled",
          " *",
          " * Returns <pinchEnabled>.",
          " */"
        ]
      ],
      "setPinchEnabled": [
        "setPinchEnabled(value: boolean): void;",
        [
          "/**",
          " * Function: setPinchEnabled",
          " *",
          " * Sets <pinchEnabled>.",
          " */"
        ]
      ],
      "isPanningTrigger": [
        "isPanningTrigger(me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Function: isPanningTrigger",
          " *",
          " * Returns true if the given event is a panning trigger for the optional",
          " * given cell. This returns true if control-shift is pressed or if",
          " * <usePopupTrigger> is true and the event is a popup trigger.",
          " */"
        ]
      ],
      "isForcePanningEvent": [
        "isForcePanningEvent(me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Function: isForcePanningEvent",
          " *",
          " * Returns true if the given <mxMouseEvent> should start panning. This",
          " * implementation always returns true if <ignoreCell> is true or for",
          " * multi touch events.",
          " */"
        ]
      ],
      "mouseDown": [
        "mouseDown(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseDown",
          " *",
          " * Handles the event by initiating the panning. By consuming the event all",
          " * subsequent events of the gesture are redirected to this handler.",
          " */"
        ]
      ],
      "start": [
        "start(me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: start",
          " *",
          " * Starts panning at the given event.",
          " */"
        ]
      ],
      "consumePanningTrigger": [
        "consumePanningTrigger(me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: consumePanningTrigger",
          " *",
          " * Consumes the given <mxMouseEvent> if it was a panning trigger in",
          " * <mouseDown>. The default is to invoke <mxMouseEvent.consume>. Note that this",
          " * will block any further event processing. If you haven't disabled built-in",
          " * context menus and require immediate selection of the cell on mouseDown in",
          " * Safari and/or on the Mac, then use the following code:",
          " *",
          " * (code)",
          " * consumePanningTrigger(me)",
          " * {",
          " *   if (me.evt.preventDefault)",
          " *   {",
          " *     me.evt.preventDefault();",
          " *   }",
          " *",
          " *   // Stops event processing in IE",
          " *   me.evt.returnValue = false;",
          " *",
          " *   // Sets local consumed state",
          " *   if (!mxClient.IS_SF && !mxClient.IS_MAC)",
          " *   {",
          " *     me.consumed = true;",
          " *   }",
          " * };",
          " * (end)",
          " */"
        ]
      ],
      "mouseMove": [
        "mouseMove(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseMove",
          " *",
          " * Handles the event by updating the panning on the graph.",
          " */"
        ]
      ],
      "mouseUp": [
        "mouseUp(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseUp",
          " *",
          " * Handles the event by setting the translation on the view or showing the",
          " * popupmenu.",
          " */"
        ]
      ],
      "reset": [
        "reset(): void;",
        [
          "/**",
          " * Function: mouseUp",
          " *",
          " * Handles the event by setting the translation on the view or showing the",
          " * popupmenu.",
          " */"
        ]
      ],
      "panGraph": [
        "panGraph(dx: number, dy: number): void;",
        [
          "/**",
          " * Function: panGraph",
          " *",
          " * Pans <graph> by the given amount.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Function: destroy",
          " *",
          " * Destroys the handler and all its resources and DOM nodes.",
          " */"
        ]
      ]
    }
  ],
  "mxConnectionHandler": [
    null,
    {
      "sourceConstraint": [
        "sourceConstraint: mxConnectionConstraint;",
        null
      ],
      "constructor": [
        "constructor(graph: mxGraph, factoryMethod?: (source: mxCell, target: mxCell, style?: string) => mxCell);",
        null
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Variable: graph",
          " *",
          " * Reference to the enclosing <mxGraph>.",
          " */"
        ]
      ],
      "factoryMethod": [
        "factoryMethod: (source: mxCell, target: mxCell, style?: string) => mxCell;",
        [
          "/**",
          " * Variable: factoryMethod",
          " *",
          " * Function that is used for creating new edges. The function takes the",
          " * source and target <mxCell> as the first and second argument and returns",
          " * a new <mxCell> that represents the edge. This is used in <createEdge>.",
          " */"
        ]
      ],
      "moveIconFront": [
        "moveIconFront: boolean;",
        [
          "/**",
          " * Variable: moveIconFront",
          " *",
          " * Specifies if icons should be displayed inside the graph container instead",
          " * of the overlay pane. This is used for HTML labels on vertices which hide",
          " * the connect icon. This has precendence over <moveIconBack> when set",
          " * to true. Default is false.",
          " */"
        ]
      ],
      "moveIconBack": [
        "moveIconBack: boolean;",
        [
          "/**",
          " * Variable: moveIconBack",
          " *",
          " * Specifies if icons should be moved to the back of the overlay pane. This can",
          " * be set to true if the icons of the connection handler conflict with other",
          " * handles, such as the vertex label move handle. Default is false.",
          " */"
        ]
      ],
      "connectImage": [
        "connectImage: mxImage;",
        [
          "/**",
          " * Variable: connectImage",
          " *",
          " * <mxImage> that is used to trigger the creation of a new connection. This",
          " * is used in <createIcons>. Default is null.",
          " */"
        ]
      ],
      "targetConnectImage": [
        "targetConnectImage: boolean;",
        [
          "/**",
          " * Variable: targetConnectImage",
          " *",
          " * Specifies if the connect icon should be centered on the target state",
          " * while connections are being previewed. Default is false.",
          " */"
        ]
      ],
      "enabled": [
        "enabled: boolean;",
        [
          "/**",
          " * Variable: enabled",
          " *",
          " * Specifies if events are handled. Default is true.",
          " */"
        ]
      ],
      "select": [
        "select: boolean;",
        [
          "/**",
          " * Variable: select",
          " *",
          " * Specifies if new edges should be selected. Default is true.",
          " */"
        ]
      ],
      "createTarget": [
        "createTarget: boolean;",
        [
          "/**",
          " * Variable: createTarget",
          " *",
          " * Specifies if <createTargetVertex> should be called if no target was under the",
          " * mouse for the new connection. Setting this to true means the connection",
          " * will be drawn as valid if no target is under the mouse, and",
          " * <createTargetVertex> will be called before the connection is created between",
          " * the source cell and the newly created vertex in <createTargetVertex>, which",
          " * can be overridden to create a new target. Default is false.",
          " */"
        ]
      ],
      "marker": [
        "marker: any;",
        [
          "/**",
          " * Variable: marker",
          " *",
          " * Holds the <mxTerminalMarker> used for finding source and target cells.",
          " */"
        ]
      ],
      "constraintHandler": [
        "constraintHandler: mxConstraintHandler;",
        [
          "/**",
          " * Variable: constraintHandler",
          " *",
          " * Holds the <mxConstraintHandler> used for drawing and highlighting",
          " * constraints.",
          " */"
        ]
      ],
      "error": [
        "error: any;",
        [
          "/**",
          " * Variable: error",
          " *",
          " * Holds the current validation error while connections are being created.",
          " */"
        ]
      ],
      "waypointsEnabled": [
        "waypointsEnabled: boolean;",
        [
          "/**",
          " * Variable: waypointsEnabled",
          " *",
          " * Specifies if single clicks should add waypoints on the new edge. Default is",
          " * false.",
          " */"
        ]
      ],
      "ignoreMouseDown": [
        "ignoreMouseDown: boolean;",
        [
          "/**",
          " * Variable: ignoreMouseDown",
          " *",
          " * Specifies if the connection handler should ignore the state of the mouse",
          " * button when highlighting the source. Default is false, that is, the",
          " * handler only highlights the source if no button is being pressed.",
          " */"
        ]
      ],
      "first": [
        "first: mxPoint;",
        [
          "/**",
          " * Variable: first",
          " *",
          " * Holds the <mxPoint> where the mouseDown took place while the handler is",
          " * active.",
          " */"
        ]
      ],
      "connectIconOffset": [
        "connectIconOffset: mxPoint;",
        [
          "/**",
          " * Variable: connectIconOffset",
          " *",
          " * Holds the offset for connect icons during connection preview.",
          " * Default is mxPoint(0, <mxConstants.TOOLTIP_VERTICAL_OFFSET>).",
          " * Note that placing the icon under the mouse pointer with an",
          " * offset of (0,0) will affect hit detection.",
          " */"
        ]
      ],
      "edgeState": [
        "edgeState: mxCellState;",
        [
          "/**",
          " * Variable: edgeState",
          " *",
          " * Optional <mxCellState> that represents the preview edge while the",
          " * handler is active. This is created in <createEdgeState>.",
          " */"
        ]
      ],
      "changeHandler": [
        "changeHandler: any;",
        [
          "/**",
          " * Variable: changeHandler",
          " *",
          " * Holds the change event listener for later removal.",
          " */"
        ]
      ],
      "drillHandler": [
        "drillHandler: any;",
        [
          "/**",
          " * Variable: drillHandler",
          " *",
          " * Holds the drill event listener for later removal.",
          " */"
        ]
      ],
      "mouseDownCounter": [
        "mouseDownCounter: number;",
        [
          "/**",
          " * Variable: mouseDownCounter",
          " *",
          " * Counts the number of mouseDown events since the start. The initial mouse",
          " * down event counts as 1.",
          " */"
        ]
      ],
      "movePreviewAway": [
        "movePreviewAway: boolean;",
        [
          "/**",
          " * Variable: movePreviewAway",
          " *",
          " * Switch to enable moving the preview away from the mousepointer. This is required in browsers",
          " * where the preview cannot be made transparent to events and if the built-in hit detection on",
          " * the HTML elements in the page should be used. Default is the value of <mxClient.IS_VML>.",
          " */"
        ]
      ],
      "outlineConnect": [
        "outlineConnect: boolean;",
        [
          "/**",
          " * Variable: outlineConnect",
          " *",
          " * Specifies if connections to the outline of a highlighted target should be",
          " * enabled. This will allow to place the connection point along the outline of",
          " * the highlighted target. Default is false.",
          " */"
        ]
      ],
      "livePreview": [
        "livePreview: boolean;",
        [
          "/**",
          " * Variable: livePreview",
          " *",
          " * Specifies if the actual shape of the edge state should be used for the preview.",
          " * Default is false. (Ignored if no edge state is created in <createEdgeState>.)",
          " */"
        ]
      ],
      "cursor": [
        "cursor: string;",
        [
          "/**",
          " * Variable: cursor",
          " *",
          " * Specifies the cursor to be used while the handler is active. Default is null.",
          " */"
        ]
      ],
      "insertBeforeSource": [
        "insertBeforeSource: boolean;",
        [
          "/**",
          " * Variable: insertBeforeSource",
          " *",
          " * Specifies if new edges should be inserted before the source vertex in the",
          " * cell hierarchy. Default is false for backwards compatibility.",
          " */"
        ]
      ],
      "isEnabled": [
        "isEnabled(): boolean;",
        [
          "/**",
          " * Function: isEnabled",
          " *",
          " * Returns true if events are handled. This implementation",
          " * returns <enabled>.",
          " */"
        ]
      ],
      "setEnabled": [
        "setEnabled(enabled: boolean): void;",
        [
          "/**",
          " * Function: setEnabled",
          " *",
          " * Enables or disables event handling. This implementation",
          " * updates <enabled>.",
          " *",
          " * Parameters:",
          " *",
          " * enabled - Boolean that specifies the new enabled state.",
          " */"
        ]
      ],
      "isInsertBefore": [
        "isInsertBefore(edge: mxCell, source: mxCell, target: mxCell, evt: MouseEvent, dropTarget: mxCell): boolean;",
        [
          "/**",
          " * Function: isInsertBefore",
          " *",
          " * Returns <insertBeforeSource> for non-loops and false for loops.",
          " *",
          " * Parameters:",
          " *",
          " * edge - <mxCell> that represents the edge to be inserted.",
          " * source - <mxCell> that represents the source terminal.",
          " * target - <mxCell> that represents the target terminal.",
          " * evt - Mousedown event of the connect gesture.",
          " * dropTarget - <mxCell> that represents the cell under the mouse when it was",
          " * released.",
          " */"
        ]
      ],
      "isCreateTarget": [
        "isCreateTarget(evt: Event): boolean;",
        [
          "/**",
          " * Function: isCreateTarget",
          " *",
          " * Returns <createTarget>.",
          " *",
          " * Parameters:",
          " *",
          " * evt - Current active native pointer event.",
          " */"
        ]
      ],
      "setCreateTarget": [
        "setCreateTarget(value: boolean): void;",
        [
          "/**",
          " * Function: setCreateTarget",
          " *",
          " * Sets <createTarget>.",
          " */"
        ]
      ],
      "createShape": [
        "createShape(): mxShape;",
        [
          "/**",
          " * Function: createShape",
          " *",
          " * Creates the preview shape for new connections.",
          " */"
        ]
      ],
      "init": [
        "init(): void;",
        [
          "/**",
          " * Function: init",
          " *",
          " * Initializes the shapes required for this connection handler. This should",
          " * be invoked if <mxGraph.container> is assigned after the connection",
          " * handler has been created.",
          " */"
        ]
      ],
      "isConnectableCell": [
        "isConnectableCell(cell: mxCell): boolean;",
        [
          "/**",
          " * Function: isConnectableCell",
          " *",
          " * Returns true if the given cell is connectable. This is a hook to",
          " * disable floating connections. This implementation returns true.",
          " */"
        ]
      ],
      "createMarker": [
        "createMarker(): mxCellMarker;",
        [
          "/**",
          " * Function: createMarker",
          " *",
          " * Creates and returns the <mxCellMarker> used in <marker>.",
          " */"
        ]
      ],
      "start": [
        "start(state: mxCellState, x: number, y: number, edgeState: mxCellState): void;",
        [
          "/**",
          " * Function: start",
          " *",
          " * Starts a new connection for the given state and coordinates.",
          " */"
        ]
      ],
      "isConnecting": [
        "isConnecting(): boolean;",
        [
          "/**",
          " * Function: isConnecting",
          " *",
          " * Returns true if the source terminal has been clicked and a new",
          " * connection is currently being previewed.",
          " */"
        ]
      ],
      "isValidSource": [
        "isValidSource(cell: mxCell, me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Function: isValidSource",
          " *",
          " * Returns <mxGraph.isValidSource> for the given source terminal.",
          " *",
          " * Parameters:",
          " *",
          " * cell - <mxCell> that represents the source terminal.",
          " * me - <mxMouseEvent> that is associated with this call.",
          " */"
        ]
      ],
      "isValidTarget": [
        "isValidTarget(cell: mxCell): boolean;",
        [
          "/**",
          " * Function: isValidTarget",
          " *",
          " * Returns true. The call to <mxGraph.isValidTarget> is implicit by calling",
          " * <mxGraph.getEdgeValidationError> in <validateConnection>. This is an",
          " * additional hook for disabling certain targets in this specific handler.",
          " *",
          " * Parameters:",
          " *",
          " * cell - <mxCell> that represents the target terminal.",
          " */"
        ]
      ],
      "validateConnection": [
        "validateConnection(source: mxCell, target: mxCell): string;",
        [
          "/**",
          " * Function: validateConnection",
          " *",
          " * Returns the error message or an empty string if the connection for the",
          " * given source target pair is not valid. Otherwise it returns null. This",
          " * implementation uses <mxGraph.getEdgeValidationError>.",
          " *",
          " * Parameters:",
          " *",
          " * source - <mxCell> that represents the source terminal.",
          " * target - <mxCell> that represents the target terminal.",
          " */"
        ]
      ],
      "getConnectImage": [
        "getConnectImage(state: mxCellState): mxImage;",
        [
          "/**",
          " * Function: getConnectImage",
          " *",
          " * Hook to return the <mxImage> used for the connection icon of the given",
          " * <mxCellState>. This implementation returns <connectImage>.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> whose connect image should be returned.",
          " */"
        ]
      ],
      "isMoveIconToFrontForState": [
        "isMoveIconToFrontForState(state: mxCellState): boolean;",
        [
          "/**",
          " * Function: isMoveIconToFrontForState",
          " *",
          " * Returns true if the state has a HTML label in the graph's container, otherwise",
          " * it returns <moveIconFront>.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> whose connect icons should be returned.",
          " */"
        ]
      ],
      "createIcons": [
        "createIcons(state: mxCellState): mxImageShape[];",
        [
          "/**",
          " * Function: createIcons",
          " *",
          " * Creates the array <mxImageShapes> that represent the connect icons for",
          " * the given <mxCellState>.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> whose connect icons should be returned.",
          " */"
        ]
      ],
      "redrawIcons": [
        "redrawIcons(icons?: mxImageShape[], state?: mxCellState): void;",
        [
          "/**",
          " * Function: redrawIcons",
          " *",
          " * Redraws the given array of <mxImageShapes>.",
          " *",
          " * Parameters:",
          " *",
          " * icons - Optional array of <mxImageShapes> to be redrawn.",
          " */"
        ]
      ],
      "getIconPosition": [
        "getIconPosition(icon?: mxImageShape[], state?: mxCellState): mxPoint;",
        [
          "/**",
          " * Function: redrawIcons",
          " *",
          " * Redraws the given array of <mxImageShapes>.",
          " *",
          " * Parameters:",
          " *",
          " * icons - Optional array of <mxImageShapes> to be redrawn.",
          " */"
        ]
      ],
      "destroyIcons": [
        "destroyIcons(): void;",
        [
          "/**",
          " * Function: destroyIcons",
          " *",
          " * Destroys the connect icons and resets the respective state.",
          " */"
        ]
      ],
      "isStartEvent": [
        "isStartEvent(me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Function: isStartEvent",
          " *",
          " * Returns true if the given mouse down event should start this handler. The",
          " * This implementation returns true if the event does not force marquee",
          " * selection, and the currentConstraint and currentFocus of the",
          " * <constraintHandler> are not null, or <previous> and <error> are not null and",
          " * <icons> is null or <icons> and <icon> are not null.",
          " */"
        ]
      ],
      "mouseDown": [
        "mouseDown(sender: Event, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseDown",
          " *",
          " * Handles the event by initiating a new connection.",
          " */"
        ]
      ],
      "isImmediateConnectSource": [
        "isImmediateConnectSource(state: mxCellState): boolean;",
        [
          "/**",
          " * Function: isImmediateConnectSource",
          " *",
          " * Returns true if a tap on the given source state should immediately start",
          " * connecting. This implementation returns true if the state is not movable",
          " * in the graph.",
          " */"
        ]
      ],
      "createEdgeState": [
        "createEdgeState(me: mxMouseEvent): mxCellState;",
        [
          "/**",
          " * Function: createEdgeState",
          " *",
          " * Hook to return an <mxCellState> which may be used during the preview.",
          " * This implementation returns null.",
          " *",
          " * Use the following code to create a preview for an existing edge style:",
          " *",
          " * (code)",
          " * graph.connectionHandler.createEdgeState(me)",
          " * {",
          " *   var edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=elbowEdgeStyle');",
          " *",
          " *   return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));",
          " * };",
          " * (end)",
          " */"
        ]
      ],
      "isOutlineConnectEvent": [
        "isOutlineConnectEvent(me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Function: isOutlineConnectEvent",
          " *",
          " * Returns true if <outlineConnect> is true and the source of the event is the outline shape",
          " * or shift is pressed.",
          " */"
        ]
      ],
      "updateCurrentState": [
        "updateCurrentState(me: mxMouseEvent, point: mxPoint): void;",
        [
          "/**",
          " * Function: updateCurrentState",
          " *",
          " * Updates the current state for a given mouse move event by using",
          " * the <marker>.",
          " */"
        ]
      ],
      "isCellEnabled": [
        "isCellEnabled(cell: mxCell): boolean;",
        [
          "/**",
          " * Function: isCellEnabled",
          " *",
          " * Returns true if the given cell does not allow new connections to be created.",
          " */"
        ]
      ],
      "convertWaypoint": [
        "convertWaypoint(point: mxPoint): void;",
        [
          "/**",
          " * Function: convertWaypoint",
          " *",
          " * Converts the given point from screen coordinates to model coordinates.",
          " */"
        ]
      ],
      "snapToPreview": [
        "snapToPreview(me: mxMouseEvent, point: mxPoint): void;",
        [
          "/**",
          " * Function: snapToPreview",
          " *",
          " * Called to snap the given point to the current preview. This snaps to the",
          " * first point of the preview if alt is not pressed.",
          " */"
        ]
      ],
      "mouseMove": [
        "mouseMove(sender: mxMouseEvent, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseMove",
          " *",
          " * Handles the event by updating the preview edge or by highlighting",
          " * a possible source or target terminal.",
          " */"
        ]
      ],
      "updateEdgeState": [
        "updateEdgeState(current: mxCellState, constraint: mxCellState): void;",
        [
          "/**",
          " * Function: updateEdgeState",
          " *",
          " * Updates <edgeState>.",
          " */"
        ]
      ],
      "getTargetPerimeterPoint": [
        "getTargetPerimeterPoint(state: mxCellState, me: mxMouseEvent): mxPoint;",
        [
          "/**",
          " * Function: getTargetPerimeterPoint",
          " *",
          " * Returns the perimeter point for the given target state.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> that represents the target cell state.",
          " * me - <mxMouseEvent> that represents the mouse move.",
          " */"
        ]
      ],
      "getSourcePerimeterPoint": [
        "getSourcePerimeterPoint(state: mxCellState, next: mxPoint, me: mxMouseEvent): mxPoint;",
        [
          "/**",
          " * Function: getSourcePerimeterPoint",
          " *",
          " * Hook to update the icon position(s) based on a mouseOver event. This is",
          " * an empty implementation.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> that represents the target cell state.",
          " * next - <mxPoint> that represents the next point along the previewed edge.",
          " * me - <mxMouseEvent> that represents the mouse move.",
          " */"
        ]
      ],
      "updateIcons": [
        "updateIcons(state: mxCellState, icons: string[], me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: updateIcons",
          " *",
          " * Hook to update the icon position(s) based on a mouseOver event. This is",
          " * an empty implementation.",
          " *",
          " * Parameters:",
          " *",
          " * state - <mxCellState> under the mouse.",
          " * icons - Array of currently displayed icons.",
          " * me - <mxMouseEvent> that contains the mouse event.",
          " */"
        ]
      ],
      "isStopEvent": [
        "isStopEvent(me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: isStopEvent",
          " *",
          " * Returns true if the given mouse up event should stop this handler. The",
          " * connection will be created if <error> is null. Note that this is only",
          " * called if <waypointsEnabled> is true. This implemtation returns true",
          " * if there is a cell state in the given event.",
          " */"
        ]
      ],
      "addWaypointForEvent": [
        "addWaypointForEvent(me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: addWaypoint",
          " *",
          " * Adds the waypoint for the given event to <waypoints>.",
          " */"
        ]
      ],
      "mouseUp": [
        "mouseUp(sender: mxMouseEvent, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseUp",
          " *",
          " * Handles the event by inserting the new connection.",
          " */"
        ]
      ],
      "reset": [
        "reset(): void;",
        [
          "/**",
          " * Function: reset",
          " *",
          " * Resets the state of this handler.",
          " */"
        ]
      ],
      "drawPreview": [
        "drawPreview(): void;",
        [
          "/**",
          " * Function: drawPreview",
          " *",
          " * Redraws the preview edge using the color and width returned by",
          " * <getEdgeColor> and <getEdgeWidth>.",
          " */"
        ]
      ],
      "updatePreview": [
        "updatePreview(valid: boolean): void;",
        [
          "/**",
          " * Function: getEdgeColor",
          " *",
          " * Returns the color used to draw the preview edge. This returns green if",
          " * there is no edge validation error and red otherwise.",
          " *",
          " * Parameters:",
          " *",
          " * valid - Boolean indicating if the color for a valid edge should be",
          " * returned.",
          " */"
        ]
      ],
      "getEdgeColor": [
        "getEdgeColor(valid: boolean): string;",
        [
          "/**",
          " * Function: getEdgeColor",
          " *",
          " * Returns the color used to draw the preview edge. This returns green if",
          " * there is no edge validation error and red otherwise.",
          " *",
          " * Parameters:",
          " *",
          " * valid - Boolean indicating if the color for a valid edge should be",
          " * returned.",
          " */"
        ]
      ],
      "getEdgeWidth": [
        "getEdgeWidth(valid: boolean): number;",
        [
          "/**",
          " * Function: getEdgeWidth",
          " *",
          " * Returns the width used to draw the preview edge. This returns 3 if",
          " * there is no edge validation error and 1 otherwise.",
          " *",
          " * Parameters:",
          " *",
          " * valid - Boolean indicating if the width for a valid edge should be",
          " * returned.",
          " */"
        ]
      ],
      "connect": [
        "connect(source: mxCell, target: mxCell, evt: MouseEvent, dropTarget: mxCell): void;",
        [
          "/**",
          " * Function: connect",
          " *",
          " * Connects the given source and target using a new edge. This",
          " * implementation uses <createEdge> to create the edge.",
          " *",
          " * Parameters:",
          " *",
          " * source - <mxCell> that represents the source terminal.",
          " * target - <mxCell> that represents the target terminal.",
          " * evt - Mousedown event of the connect gesture.",
          " * dropTarget - <mxCell> that represents the cell under the mouse when it was",
          " * released.",
          " */"
        ]
      ],
      "selectCells": [
        "selectCells(edge: mxCell, target: mxCell): void;",
        [
          "/**",
          " * Function: selectCells",
          " *",
          " * Selects the given edge after adding a new connection. The target argument",
          " * contains the target vertex if one has been inserted.",
          " */"
        ]
      ],
      "insertEdge": [
        "insertEdge(parent: mxCell, id: string, value: any, source: mxCell, target: mxCell, style: string): mxCell;",
        [
          "/**",
          " * Function: insertEdge",
          " *",
          " * Creates, inserts and returns the new edge for the given parameters. This",
          " * implementation does only use <createEdge> if <factoryMethod> is defined,",
          " * otherwise <mxGraph.insertEdge> will be used.",
          " */"
        ]
      ],
      "createTargetVertex": [
        "createTargetVertex(evt: MouseEvent, source: mxCell): mxCell;",
        [
          "/**",
          " * Function: createTargetVertex",
          " *",
          " * Hook method for creating new vertices on the fly if no target was",
          " * under the mouse. This is only called if <createTarget> is true and",
          " * returns null.",
          " *",
          " * Parameters:",
          " *",
          " * evt - Mousedown event of the connect gesture.",
          " * source - <mxCell> that represents the source terminal.",
          " */"
        ]
      ],
      "getAlignmentTolerance": [
        "getAlignmentTolerance(evt: MouseEvent): number;",
        [
          "/**",
          " * Function: getAlignmentTolerance",
          " *",
          " * Returns the tolerance for aligning new targets to sources. This returns the grid size / 2.",
          " */"
        ]
      ],
      "createEdge": [
        "createEdge(value?: any, source?: mxCell, target?: mxCell, style?: string): mxCell;",
        [
          "/**",
          " * Function: createEdge",
          " *",
          " * Creates and returns a new edge using <factoryMethod> if one exists. If",
          " * no factory method is defined, then a new default edge is returned. The",
          " * source and target arguments are informal, the actual connection is",
          " * setup later by the caller of this function.",
          " *",
          " * Parameters:",
          " *",
          " * value - Value to be used for creating the edge.",
          " * source - <mxCell> that represents the source terminal.",
          " * target - <mxCell> that represents the target terminal.",
          " * style - Optional style from the preview edge.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Function: destroy",
          " *",
          " * Destroys the handler and all its resources and DOM nodes. This should be",
          " * called on all instances. It is called automatically for the built-in",
          " * instance created for each <mxGraph>.",
          " */"
        ]
      ]
    }
  ],
  "mxSelectionCellsHandler": [
    null,
    {
      "constructor": [
        "constructor(graph: mxGraph);",
        null
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Variable: graph",
          " *",
          " * Reference to the enclosing <mxGraph>.",
          " */"
        ]
      ],
      "enabled": [
        "enabled: boolean;",
        [
          "/**",
          " * Variable: enabled",
          " *",
          " * Specifies if events are handled. Default is true.",
          " */"
        ]
      ],
      "refreshHandler": [
        "refreshHandler: any;",
        [
          "/**",
          " * Variable: refreshHandler",
          " *",
          " * Keeps a reference to an event listener for later removal.",
          " */"
        ]
      ],
      "maxHandlers": [
        "maxHandlers: number;",
        [
          "/**",
          " * Variable: maxHandlers",
          " *",
          " * Defines the maximum number of handlers to paint individually. Default is 100.",
          " */"
        ]
      ],
      "handlers": [
        "handlers: mxDictionary<any>;",
        [
          "/**",
          " * Variable: handlers",
          " *",
          " * <mxDictionary> that maps from cells to handlers.",
          " */"
        ]
      ],
      "isEnabled": [
        "isEnabled(): boolean;",
        [
          "/**",
          " * Function: isEnabled",
          " *",
          " * Returns <enabled>.",
          " */"
        ]
      ],
      "setEnabled": [
        "setEnabled(value: boolean): void;",
        [
          "/**",
          " * Function: setEnabled",
          " *",
          " * Sets <enabled>.",
          " */"
        ]
      ],
      "getHandler": [
        "getHandler(cell: mxCell): any;",
        [
          "/**",
          " * Function: getHandler",
          " *",
          " * Returns the handler for the given cell.",
          " */"
        ]
      ],
      "reset": [
        "reset(): void;",
        [
          "/**",
          " * Function: reset",
          " *",
          " * Resets all handlers.",
          " */"
        ]
      ],
      "refresh": [
        "refresh(): void;",
        [
          "/**",
          " * Function: refresh",
          " *",
          " * Reloads or updates all handlers.",
          " */"
        ]
      ],
      "isHandlerActive": [
        "isHandlerActive(handler: any): boolean;",
        [
          "/**",
          " * Function: isHandlerActive",
          " *",
          " * Returns true if the given handler is active and should not be redrawn.",
          " */"
        ]
      ],
      "updateHandler": [
        "updateHandler(state: mxCellState): void;",
        [
          "/**",
          " * Function: updateHandler",
          " *",
          " * Updates the handler for the given shape if one exists.",
          " */"
        ]
      ],
      "mouseDown": [
        "mouseDown(sender: Event, me: Event): void;",
        [
          "/**",
          " * Function: mouseDown",
          " *",
          " * Redirects the given event to the handlers.",
          " */"
        ]
      ],
      "mouseMove": [
        "mouseMove(sender: Event, me: Event): void;",
        [
          "/**",
          " * Function: mouseMove",
          " *",
          " * Redirects the given event to the handlers.",
          " */"
        ]
      ],
      "mouseUp": [
        "mouseUp(sender: Event, me: Event): void;",
        [
          "/**",
          " * Function: mouseUp",
          " *",
          " * Redirects the given event to the handlers.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Function: destroy",
          " *",
          " * Destroys the handler and all its resources and DOM nodes.",
          " */"
        ]
      ]
    }
  ],
  "mxHandle": [
    [
      "/**",
      " * Implements a single custom handle for vertices.",
      " *",
      " * @class mxHandle",
      " */"
    ],
    {
      "constructor": [
        "constructor(state: mxCellState, cursor: string, image: mxImage, shape: mxShape);",
        [
          "/**",
          " * Constructs a new handle for the given state.",
          " *",
          " * @param {mxCellState} state   {@link mxCellState} of the cell to be handled.",
          " * @param {string} cursor",
          " * @param {mxImage} image",
          " * @param {mxShape} shape",
          " * @memberof mxHandle",
          " */"
        ]
      ],
      "cursor": [
        "cursor: string;",
        [
          "/**",
          " * Specifies the cursor to be used for this handle. Default is 'default'.",
          " */"
        ]
      ],
      "image": [
        "image: mxImage;",
        [
          "/**",
          " * Specifies the <mxImage> to be used to render the handle. Default is null.",
          " */"
        ]
      ],
      "ignoreGrid": [
        "ignoreGrid: boolean;",
        [
          "/**",
          " * Default is false.",
          " */"
        ]
      ],
      "getPosition": [
        "getPosition(bounds: mxRectangle): any;",
        [
          "/**",
          " * Hook for subclassers to return the current position of the handle.",
          " */"
        ]
      ],
      "setPosition": [
        "setPosition(bounds: mxRectangle, pt: any, me: any): any;",
        [
          "/**",
          " * Hooks for subclassers to update the style in the <state>.",
          " */"
        ]
      ],
      "execute": [
        "execute(me: mxMouseEvent): void;",
        [
          "/**",
          " * Hook for subclassers to execute the handle.",
          " */"
        ]
      ],
      "copyStyle": [
        "copyStyle(key: string): void;",
        [
          "/**",
          " * Sets the cell style with the given name to the corresponding value in <state>.",
          " */"
        ]
      ],
      "processEvent": [
        "processEvent(me: mxMouseEvent): void;",
        [
          "/**",
          " * Processes the given <mxMouseEvent> and invokes <setPosition>.",
          " */"
        ]
      ],
      "positionChanged": [
        "positionChanged(): void;",
        [
          "/**",
          " * Should be called after <setPosition> in <processEvent>.",
          " * This repaints the state using <mxCellRenderer>.",
          " */"
        ]
      ],
      "getRotation": [
        "getRotation(): number;",
        [
          "/**",
          " * Returns the rotation defined in the style of the cell.",
          " */"
        ]
      ],
      "getTotalRotation": [
        "getTotalRotation(): number;",
        [
          "/**",
          " * Returns the rotation from the style and the rotation from the direction of",
          " * the cell.",
          " */"
        ]
      ],
      "init": [
        "init(): void;",
        [
          "/**",
          " * Creates and initializes the shapes required for this handle.",
          " */"
        ]
      ],
      "createShape": [
        "createShape(html: any): mxShape;",
        [
          "/**",
          " * Creates and returns the shape for this handle.",
          " */"
        ]
      ],
      "initShape": [
        "initShape(html: any): void;",
        [
          "/**",
          " * Initializes <shape> and sets its cursor.",
          " */"
        ]
      ],
      "redraw": [
        "redraw(): void;",
        [
          "/**",
          " * Renders the shape for this handle.",
          " */"
        ]
      ],
      "isHtmlRequired": [
        "isHtmlRequired(): boolean;",
        [
          "/**",
          " * Returns true if this handle should be rendered in HTML. This returns true if",
          " * the text node is in the graph container.",
          " */"
        ]
      ],
      "rotatePoint": [
        "rotatePoint(pt: mxPoint, alpha: boolean): mxPoint;",
        [
          "/**",
          " * Rotates the point by the given angle.",
          " */"
        ]
      ],
      "flipPoint": [
        "flipPoint(pt: mxPoint): mxPoint;",
        [
          "/**",
          " * Flips the given point vertically and/or horizontally.",
          " */"
        ]
      ],
      "snapPoint": [
        "snapPoint(pt: mxPoint, ignore: boolean): mxPoint;",
        [
          "/**",
          " * Snaps the given point to the grid if ignore is false. This modifies",
          " * the given point in-place and also returns it.",
          " */"
        ]
      ],
      "setVisible": [
        "setVisible(visible: boolean): void;",
        [
          "/**",
          " * Shows or hides this handle.",
          " */"
        ]
      ],
      "reset": [
        "reset(): void;",
        [
          "/**",
          " * Resets the state of this handle by setting its visibility to true.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Destroys this handle.",
          " */"
        ]
      ]
    }
  ],
  "mxKeyHandler": [
    null,
    {
      "constructor": [
        "constructor(graph: mxGraph, target?: EventTarget);",
        [
          "/**",
          " * Constructs an event handler that executes functions bound to specific keystrokes.",
          " * @author  <hungtcs@163.com>",
          " * @date 2020-01-09",
          " * @param {mxGraph} graph Reference to the associated mxGraph.",
          " * @param {*} target      Optional reference to the event target.",
          " *                        If null, the document element is used as the event target, that is,",
          " *                        the object where the key event listener is installed.",
          " */"
        ]
      ],
      "public graph": [
        "public graph: mxGraph;",
        [
          "/**",
          " * Reference to the mxGraph associated with this handler.",
          " */"
        ]
      ],
      "public target": [
        "public target: EventTarget;",
        [
          "/**",
          " * Reference to the target DOM, that is, the DOM node where the key event listeners are installed.",
          " */"
        ]
      ],
      "public normalKeys": [
        "public normalKeys: [(event: KeyboardEvent) => void];",
        [
          "/**",
          " * Maps from keycodes to functions for non-pressed control keys.",
          " */"
        ]
      ],
      "public shiftKeys": [
        "public shiftKeys: [(event: KeyboardEvent) => void];",
        [
          "/**",
          " * Maps from keycodes to functions for pressed shift keys.",
          " */"
        ]
      ],
      "public controlKeys": [
        "public controlKeys: [(event: KeyboardEvent) => void];",
        [
          "/**",
          " * Maps from keycodes to functions for pressed control keys.",
          " */"
        ]
      ],
      "public controlShiftKeys": [
        "public controlShiftKeys: [(event: KeyboardEvent) => void];",
        [
          "/**",
          " * Maps from keycodes to functions for pressed control and shift keys.",
          " */"
        ]
      ],
      "public enabled": [
        "public enabled: boolean;",
        [
          "/**",
          " * Specifies if events are handled.  Default is true.",
          " */"
        ]
      ],
      "public isEnabled": [
        "public isEnabled(): boolean;",
        [
          "/**",
          " * Returns true if events are handled.  This implementation returns enabled.",
          " */"
        ]
      ],
      "public setEnabled": [
        "public setEnabled(enabled: boolean): void;",
        [
          "/**",
          " * Enables or disables event handling by updating enabled.",
          " */"
        ]
      ],
      "public bindKey": [
        "public bindKey(code: number, funct: (event: KeyboardEvent) => void): void;",
        [
          "/**",
          " * Binds the specified keycode to the given function.  This binding is used if the control key is not pressed.",
          " */"
        ]
      ],
      "public bindShiftKey": [
        "public bindShiftKey(code: number, funct: (event: KeyboardEvent) => void): void;",
        [
          "/**",
          " * Binds the specified keycode to the given function.  This binding is used if the shift key is pressed.",
          " */"
        ]
      ],
      "public bindControlKey": [
        "public bindControlKey(code: number, funct: (event: KeyboardEvent) => void): void;",
        [
          "/**",
          " * Binds the specified keycode to the given function.  This binding is used if the control key is pressed.",
          " */"
        ]
      ],
      "public bindControlShiftKey": [
        "public bindControlShiftKey(code: number, funct: (event: KeyboardEvent) => void): number;",
        [
          "/**",
          " * Binds the specified keycode to the given function.  This binding is used if the control and shift key are pressed.",
          " */"
        ]
      ],
      "public isControlDown": [
        "public isControlDown(evt: KeyboardEvent): boolean;",
        [
          "/**",
          " * Returns true if the control key is pressed.  This uses mxEvent.isControlDown.",
          " */"
        ]
      ],
      "public getFunction": [
        "public getFunction(evt: KeyboardEvent): (event: KeyboardEvent) => void;",
        [
          "/**",
          " * Returns the function associated with the given key event or null if no function is associated with the given event.",
          " */"
        ]
      ],
      "public isGraphEvent": [
        "public isGraphEvent(evt: KeyboardEvent): boolean;",
        [
          "/**",
          " * Returns true if the event should be processed by this handler, that is, if the event source is either the target, one of its direct children, a descendant of the <mxGraph.container>, or the mxGraph.cellEditor of the graph.",
          " */"
        ]
      ],
      "public keyDown": [
        "public keyDown(evt: KeyboardEvent): boolean;",
        [
          "/**",
          " * Handles the event by invoking the function bound to the respective keystroke if isEnabledForEvent returns true for the given event and if isEventIgnored returns false, except for escape for which isEventIgnored is not invoked.",
          " */"
        ]
      ],
      "public isEnabledForEvent": [
        "public isEnabledForEvent(evt: KeyboardEvent): boolean;",
        [
          "/**",
          " * Returns true if the given event should be handled.  isEventIgnored is called later if the event is not an escape key stroke, in which case escape is called.  This implementation returns true if isEnabled returns true for both, this handler and graph, if the event is not consumed and if isGraphEvent returns true.",
          " */"
        ]
      ],
      "public isEventIgnored": [
        "public isEventIgnored(evt: KeyboardEvent): boolean;",
        [
          "/**",
          " * Returns true if the given keystroke should be ignored.  This returns graph.isEditing().",
          " */"
        ]
      ],
      "public escape": [
        "public escape(evt: KeyboardEvent): void;",
        [
          "/**",
          " * Hook to process ESCAPE keystrokes.  This implementation invokes mxGraph.stopEditing to cancel the current editing, connecting and/or other ongoing modifications.",
          " */"
        ]
      ],
      "public destroy": [
        "public destroy(): void;",
        [
          "/**",
          " * Destroys the handler and all its references into the DOM.  This does normally not need to be called, it is called automatically when the window unloads (in IE).",
          " */"
        ]
      ]
    }
  ],
  "mxPopupMenuHandler": [
    null,
    {
      "constructor": [
        "constructor(graph: mxGraph, factoryMethod?: (handler: mxPopupMenuHandler, cell: mxCell, me: mxMouseEvent) => any);",
        null
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Variable: graph",
          " *",
          " * Reference to the enclosing <mxGraph>.",
          " */"
        ]
      ],
      "selectOnPopup": [
        "selectOnPopup: boolean;",
        [
          "/**",
          " * Variable: selectOnPopup",
          " *",
          " * Specifies if cells should be selected if a popupmenu is displayed for",
          " * them. Default is true.",
          " */"
        ]
      ],
      "clearSelectionOnBackground": [
        "clearSelectionOnBackground: boolean;",
        [
          "/**",
          " * Variable: clearSelectionOnBackground",
          " *",
          " * Specifies if cells should be deselected if a popupmenu is displayed for",
          " * the diagram background. Default is true.",
          " */"
        ]
      ],
      "triggerX": [
        "triggerX: number;",
        [
          "/**",
          " * Variable: triggerX",
          " *",
          " * X-coordinate of the mouse down event.",
          " */"
        ]
      ],
      "triggerY": [
        "triggerY: number;",
        [
          "/**",
          " * Variable: triggerY",
          " *",
          " * Y-coordinate of the mouse down event.",
          " */"
        ]
      ],
      "screenX": [
        "screenX: number;",
        [
          "/**",
          " * Variable: screenX",
          " *",
          " * Screen X-coordinate of the mouse down event.",
          " */"
        ]
      ],
      "screenY": [
        "screenY: number;",
        [
          "/**",
          " * Variable: screenY",
          " *",
          " * Screen Y-coordinate of the mouse down event.",
          " */"
        ]
      ],
      "init": [
        "init(): void;",
        [
          "/**",
          " * Function: init",
          " *",
          " * Initializes the shapes required for this vertex handler.",
          " */"
        ]
      ],
      "isSelectOnPopup": [
        "isSelectOnPopup(me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Function: isSelectOnPopup",
          " *",
          " * Hook for returning if a cell should be selected for a given <mxMouseEvent>.",
          " * This implementation returns <selectOnPopup>.",
          " */"
        ]
      ],
      "mouseDown": [
        "mouseDown(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseDown",
          " *",
          " * Handles the event by initiating the panning. By consuming the event all",
          " * subsequent events of the gesture are redirected to this handler.",
          " */"
        ]
      ],
      "mouseMove": [
        "mouseMove(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseMove",
          " *",
          " * Handles the event by updating the panning on the graph.",
          " */"
        ]
      ],
      "mouseUp": [
        "mouseUp(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseUp",
          " *",
          " * Handles the event by setting the translation on the view or showing the",
          " * popupmenu.",
          " */"
        ]
      ],
      "getCellForPopupEvent": [
        "getCellForPopupEvent(me: mxMouseEvent): mxCell;",
        [
          "/**",
          " * Function: getCellForPopupEvent",
          " *",
          " * Hook to return the cell for the mouse up popup trigger handling.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Function: destroy",
          " *",
          " * Destroys the handler and all its resources and DOM nodes.",
          " */"
        ]
      ]
    }
  ],
  "mxConstraintHandler": [
    [
      "/**",
      " * Handles constraints on connection targets. This class is in charge of",
      " * showing fixed points when the mouse is over a vertex and handles constraints",
      " * to establish new connections.",
      " *",
      " * @class mxConstraintHandler",
      " */"
    ],
    {
      "constructor": [
        "constructor(graph: mxGraph, factoryMethod?: (source: mxCell, target: mxCell) => mxCell);",
        [
          "/**",
          " * Constructs an new constraint handler.",
          " *",
          " * @param {mxGraph} graph - Reference to the enclosing {@link mxGraph}.",
          " * @param {(source: mxCell, target: mxCell) => mxCell} [factoryMethod] - Optional function to create the edge.",
          " * The function takes the source and target {@link mxCell} as the first and second argument and",
          " * returns the {@link mxCell} that represents the new edge.",
          " */"
        ]
      ],
      "currentConstraint": [
        "currentConstraint: mxConnectionConstraint;",
        [
          "/**",
          " *",
          " * @type {mxConnectionConstraint}",
          " */"
        ]
      ],
      "currentFocusArea": [
        "currentFocusArea: mxRectangle;",
        [
          "/**",
          " *",
          " *",
          " * @type {mxRectangle}",
          " */"
        ]
      ],
      "currentPoint": [
        "currentPoint: mxPoint;",
        [
          "/**",
          " *",
          " *",
          " * @type {mxPoint}",
          " */"
        ]
      ],
      "currentFocus": [
        "currentFocus: mxCellState;",
        [
          "/**",
          " *",
          " *",
          " * @type {mxCellState}",
          " */"
        ]
      ],
      "focusPoints": [
        "focusPoints: mxPoint[];",
        [
          "/**",
          " *",
          " *",
          " * @type {mxPoint[]}",
          " */"
        ]
      ],
      "constraints": [
        "constraints: mxConnectionConstraint[];",
        [
          "/**",
          " *",
          " *",
          " * @type {mxConnectionConstraint[]}",
          " */"
        ]
      ],
      "pointImage": [
        "pointImage: mxImage;",
        [
          "/**",
          " * {@link mxImage} to be used as the image for fixed connection points.",
          " */"
        ]
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Reference to the enclosing {@link mxGraph}.",
          " */"
        ]
      ],
      "enabled": [
        "enabled: boolean;",
        [
          "/**",
          " * Specifies if events are handled. Default is true.",
          " */"
        ]
      ],
      "highlightColor": [
        "highlightColor: string;",
        [
          "/**",
          " * Specifies the color for the highlight. Default is {@link mxConstants.DEFAULT_VALID_COLOR}.",
          " */"
        ]
      ],
      "isEnabled": [
        "isEnabled(): boolean;",
        [
          "/**",
          " * Returns true if events are handled. This implementation",
          " * returns {@link enabled}.",
          " */"
        ]
      ],
      "setEnabled": [
        "setEnabled(enabled: boolean): void;",
        [
          "/**",
          " * Enables or disables event handling. This implementation",
          " * updates {@link enabled}.",
          " *",
          " * Parameters:",
          " *",
          " * @param {boolean} enabled - Boolean that specifies the new enabled state.",
          " */"
        ]
      ],
      "reset": [
        "reset(): void;",
        [
          "/**",
          " * Resets the state of this handler.",
          " */"
        ]
      ],
      "getTolerance": [
        "getTolerance(me: mxMouseEvent): number;",
        [
          "/**",
          " * Returns the tolerance to be used for intersecting connection points. This",
          " * implementation returns {@link mxGraph.tolerance}.",
          " *",
          " * Parameters:",
          " *",
          " * me - {@link mxMouseEvent} whose tolerance should be returned.",
          " */"
        ]
      ],
      "getImageForConstraint": [
        "getImageForConstraint(state: mxCellState, constraint: mxConnectionConstraint, point: mxPoint): mxImage;",
        [
          "/**",
          " * Returns the tolerance to be used for intersecting connection points.",
          " */"
        ]
      ],
      "isEventIgnored": [
        "isEventIgnored(me: mxMouseEvent, source: boolean): boolean;",
        [
          "/**",
          " * Returns true if the given {@link mxMouseEvent} should be ignored in {@link update}. This",
          " * implementation always returns false.",
          " */"
        ]
      ],
      "isStateIgnored": [
        "isStateIgnored(state: mxCellState, source: boolean): boolean;",
        [
          "/**",
          " * Returns true if the given state should be ignored. This always returns false.",
          " */"
        ]
      ],
      "destroyIcons": [
        "destroyIcons(): void;",
        [
          "/**",
          " * Destroys the {@link focusIcons} if they exist.",
          " */"
        ]
      ],
      "destroyFocusHighlight": [
        "destroyFocusHighlight(): void;",
        [
          "/**",
          " * Destroys the {@link focusHighlight} if one exists.",
          " */"
        ]
      ],
      "isKeepFocusEvent": [
        "isKeepFocusEvent(me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Returns true if the current focused state should not be changed for the given event.",
          " * This returns true if shift and alt are pressed.",
          " */"
        ]
      ],
      "getCellForEvent": [
        "getCellForEvent(me: mxMouseEvent, point: mxPoint): mxCell;",
        [
          "/**",
          " * Returns the cell for the given event.",
          " */"
        ]
      ],
      "update": [
        "update(me: mxMouseEvent, source: mxCell, existingEdge: mxCell, point: mxPoint): void;",
        [
          "/**",
          " * Updates the state of this handler based on the given {@link mxMouseEvent}.",
          " * Source is a boolean indicating if the cell is a source or target.",
          " */"
        ]
      ],
      "redraw": [
        "redraw(): void;",
        [
          "/**",
          " * Transfers the focus to the given state as a source or target terminal. If",
          " * the handler is not enabled then the outline is painted, but the constraints",
          " * are ignored.",
          " */"
        ]
      ],
      "setFocus": [
        "setFocus(me: mxMouseEvent, state: mxCellState, source: mxCell): void;",
        [
          "/**",
          " * Transfers the focus to the given state as a source or target terminal. If",
          " * the handler is not enabled then the outline is painted, but the constraints",
          " * are ignored.",
          " */"
        ]
      ],
      "createHighlightShape": [
        "createHighlightShape(): mxShape;",
        [
          "/**",
          " * Create the shape used to paint the highlight.",
          " *",
          " * Returns true if the given icon intersects the given point.",
          " */"
        ]
      ],
      "intersects": [
        "intersects(icon: mxShape, mouse: mxRectangle, source: mxCell, existingEdge: mxCell): boolean;",
        [
          "/**",
          " * Returns true if the given icon intersects the given rectangle.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Destroy this handler.",
          " */"
        ]
      ]
    }
  ],
  "mxCellMarker": [
    null,
    {
      "constructor": [
        "constructor(graph: mxGraph, validColor: string, invalidColor: string, hotspot: number);",
        null
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Variable: graph",
          " *",
          " * Reference to the enclosing <mxGraph>.",
          " */"
        ]
      ],
      "enabled": [
        "enabled: boolean;",
        [
          "/**",
          " * Variable: enabled",
          " *",
          " * Specifies if the marker is enabled. Default is true.",
          " */"
        ]
      ],
      "hotspot": [
        "hotspot: number;",
        [
          "/**",
          " * Variable: hotspot",
          " *",
          " * Specifies the portion of the width and height that should trigger",
          " * a highlight. The area around the center of the cell to be marked is used",
          " * as the hotspot. Possible values are between 0 and 1. Default is",
          " * mxConstants.DEFAULT_HOTSPOT.",
          " */"
        ]
      ],
      "hotspotEnabled": [
        "hotspotEnabled: boolean;",
        [
          "/**",
          " * Variable: hotspotEnabled",
          " *",
          " * Specifies if the hotspot is enabled. Default is false.",
          " */"
        ]
      ],
      "validColor": [
        "validColor: string;",
        [
          "/**",
          " * Variable: validColor",
          " *",
          " * Holds the valid marker color.",
          " */"
        ]
      ],
      "invalidColor": [
        "invalidColor: string;",
        [
          "/**",
          " * Variable: invalidColor",
          " *",
          " * Holds the invalid marker color.",
          " */"
        ]
      ],
      "currentColor": [
        "currentColor: string;",
        [
          "/**",
          " * Variable: currentColor",
          " *",
          " * Holds the current marker color.",
          " */"
        ]
      ],
      "validState": [
        "validState: mxCellState;",
        [
          "/**",
          " * Variable: validState",
          " *",
          " * Holds the marked <mxCellState> if it is valid.",
          " */"
        ]
      ],
      "markedState": [
        "markedState: mxCellState;",
        [
          "/**",
          " * Variable: markedState",
          " *",
          " * Holds the marked <mxCellState>.",
          " */"
        ]
      ],
      "setEnabled": [
        "setEnabled(enabled: boolean): void;",
        [
          "/**",
          " * Function: setEnabled",
          " *",
          " * Enables or disables event handling. This implementation",
          " * updates <enabled>.",
          " *",
          " * Parameters:",
          " *",
          " * enabled - Boolean that specifies the new enabled state.",
          " */"
        ]
      ],
      "isEnabled": [
        "isEnabled(): boolean;",
        [
          "/**",
          " * Function: isEnabled",
          " *",
          " * Returns true if events are handled. This implementation",
          " * returns <enabled>.",
          " */"
        ]
      ],
      "setHotspot": [
        "setHotspot(hotspot: number): void;",
        [
          "/**",
          " * Function: setHotspot",
          " *",
          " * Sets the <hotspot>.",
          " */"
        ]
      ],
      "getHotspot": [
        "getHotspot(): number;",
        [
          "/**",
          " * Function: getHotspot",
          " *",
          " * Returns the <hotspot>.",
          " */"
        ]
      ],
      "setHotspotEnabled": [
        "setHotspotEnabled(enabled: boolean): void;",
        [
          "/**",
          " * Function: setHotspotEnabled",
          " *",
          " * Specifies whether the hotspot should be used in <intersects>.",
          " */"
        ]
      ],
      "isHotspotEnabled": [
        "isHotspotEnabled(): boolean;",
        [
          "/**",
          " * Function: isHotspotEnabled",
          " *",
          " * Returns true if hotspot is used in <intersects>.",
          " */"
        ]
      ],
      "hasValidState": [
        "hasValidState(): boolean;",
        [
          "/**",
          " * Function: hasValidState",
          " *",
          " * Returns true if <validState> is not null.",
          " */"
        ]
      ],
      "getValidState": [
        "getValidState(): mxCellState;",
        [
          "/**",
          " * Function: getValidState",
          " *",
          " * Returns the <validState>.",
          " */"
        ]
      ],
      "getMarkedState": [
        "getMarkedState(): mxCellState;",
        [
          "/**",
          " * Function: getMarkedState",
          " *",
          " * Returns the <markedState>.",
          " */"
        ]
      ],
      "reset": [
        "reset(): void;",
        [
          "/**",
          " * Function: reset",
          " *",
          " * Resets the state of the cell marker.",
          " */"
        ]
      ],
      "process": [
        "process(me: mxMouseEvent): mxCellState;",
        [
          "/**",
          " * Function: process",
          " *",
          " * Processes the given event and cell and marks the state returned by",
          " * <getState> with the color returned by <getMarkerColor>. If the",
          " * markerColor is not null, then the state is stored in <markedState>. If",
          " * <isValidState> returns true, then the state is stored in <validState>",
          " * regardless of the marker color. The state is returned regardless of the",
          " * marker color and valid state.",
          " */"
        ]
      ],
      "setCurrentState": [
        "setCurrentState(state: mxCellState, me: mxMouseEvent, color: string): void;",
        [
          "/**",
          " * Function: setCurrentState",
          " *",
          " * Sets and marks the current valid state.",
          " */"
        ]
      ],
      "markCell": [
        "markCell(cell: mxCell, color: string): void;",
        [
          "/**",
          " * Function: markCell",
          " *",
          " * Marks the given cell using the given color, or <validColor> if no color is specified.",
          " */"
        ]
      ],
      "mark": [
        "mark(): void;",
        [
          "/**",
          " * Function: mark",
          " *",
          " * Marks the <markedState> and fires a <mark> event.",
          " */"
        ]
      ],
      "unmark": [
        "unmark(): void;",
        [
          "/**",
          " * Function: unmark",
          " *",
          " * Hides the marker and fires a <mark> event.",
          " */"
        ]
      ],
      "isValidState": [
        "isValidState(state: mxCellState): boolean;",
        [
          "/**",
          " * Function: isValidState",
          " *",
          " * Returns true if the given <mxCellState> is a valid state. If this",
          " * returns true, then the state is stored in <validState>. The return value",
          " * of this method is used as the argument for <getMarkerColor>.",
          " */"
        ]
      ],
      "getMarkerColor": [
        "getMarkerColor(evt: Event, state: mxCellState, isValid: boolean): string;",
        [
          "/**",
          " * Function: getMarkerColor",
          " *",
          " * Returns the valid- or invalidColor depending on the value of isValid.",
          " * The given <mxCellState> is ignored by this implementation.",
          " */"
        ]
      ],
      "getState": [
        "getState(me: mxMouseEvent): mxCellState;",
        [
          "/**",
          " * Function: getState",
          " *",
          " * Uses <getCell>, <getStateToMark> and <intersects> to return the",
          " * <mxCellState> for the given <mxMouseEvent>.",
          " */"
        ]
      ],
      "getCell": [
        "getCell(me: mxMouseEvent): mxCell;",
        [
          "/**",
          " * Function: getCell",
          " *",
          " * Returns the <mxCell> for the given event and cell. This returns the",
          " * given cell.",
          " */"
        ]
      ],
      "getStateToMark": [
        "getStateToMark(state: mxCellState): mxCellState;",
        [
          "/**",
          " * Function: getStateToMark",
          " *",
          " * Returns the <mxCellState> to be marked for the given <mxCellState> under",
          " * the mouse. This returns the given state.",
          " */"
        ]
      ],
      "intersects": [
        "intersects(state: mxCellState, me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Function: intersects",
          " *",
          " * Returns true if the given coordinate pair intersects the given state.",
          " * This returns true if the <hotspot> is 0 or the coordinates are inside",
          " * the hotspot for the given cell state.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Function: destroy",
          " *",
          " * Destroys the handler and all its resources and DOM nodes.",
          " */"
        ]
      ]
    }
  ],
  "mxVertexHandler": [
    null,
    {
      "constructor": [
        "constructor(state: mxCellState);",
        null
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Variable: graph",
          " *",
          " * Reference to the enclosing <mxGraph>.",
          " */"
        ]
      ],
      "state": [
        "state: mxCellState;",
        [
          "/**",
          " * Variable: state",
          " *",
          " * Reference to the <mxCellState> being modified.",
          " */"
        ]
      ],
      "bounds": [
        "bounds: mxRectangle;",
        [
          "/**",
          " * Variable: state",
          " *",
          " * Reference to the <mxCellState> being modified.",
          " */"
        ]
      ],
      "singleSizer": [
        "singleSizer: boolean;",
        [
          "/**",
          " * Variable: singleSizer",
          " *",
          " * Specifies if only one sizer handle at the bottom, right corner should be",
          " * used. Default is false.",
          " */"
        ]
      ],
      "index": [
        "index: number;",
        [
          "/**",
          " * Variable: index",
          " *",
          " * Holds the index of the current handle.",
          " */"
        ]
      ],
      "allowHandleBoundsCheck": [
        "allowHandleBoundsCheck: boolean;",
        [
          "/**",
          " * Variable: allowHandleBoundsCheck",
          " *",
          " * Specifies if the bounds of handles should be used for hit-detection in IE or",
          " * if <tolerance> > 0. Default is true.",
          " */"
        ]
      ],
      "handleImage": [
        "handleImage: mxImage;",
        [
          "/**",
          " * Variable: handleImage",
          " *",
          " * Optional <mxImage> to be used as handles. Default is null.",
          " */"
        ]
      ],
      "tolerance": [
        "tolerance: number;",
        [
          "/**",
          " * Variable: tolerance",
          " *",
          " * Optional tolerance for hit-detection in <getHandleForEvent>. Default is 0.",
          " */"
        ]
      ],
      "rotationEnabled": [
        "rotationEnabled: boolean;",
        [
          "/**",
          " * Variable: rotationEnabled",
          " *",
          " * Specifies if a rotation handle should be visible. Default is false.",
          " */"
        ]
      ],
      "parentHighlightEnabled": [
        "parentHighlightEnabled: boolean;",
        [
          "/**",
          " * Variable: parentHighlightEnabled",
          " *",
          " * Specifies if the parent should be highlighted if a child cell is selected.",
          " * Default is false.",
          " */"
        ]
      ],
      "rotationRaster": [
        "rotationRaster: boolean;",
        [
          "/**",
          " * Variable: rotationRaster",
          " *",
          " * Specifies if rotation steps should be \"rasterized\" depening on the distance",
          " * to the handle. Default is true.",
          " */"
        ]
      ],
      "rotationCursor": [
        "rotationCursor: string;",
        [
          "/**",
          " * Variable: rotationCursor",
          " *",
          " * Specifies the cursor for the rotation handle. Default is 'crosshair'.",
          " */"
        ]
      ],
      "livePreview": [
        "livePreview: boolean;",
        [
          "/**",
          " * Variable: livePreview",
          " *",
          " * Specifies if resize should change the cell in-place. This is an experimental",
          " * feature for non-touch devices. Default is false.",
          " */"
        ]
      ],
      "manageSizers": [
        "manageSizers: boolean;",
        [
          "/**",
          " * Variable: manageSizers",
          " *",
          " * Specifies if sizers should be hidden and spaced if the vertex is small.",
          " * Default is false.",
          " */"
        ]
      ],
      "constrainGroupByChildren": [
        "constrainGroupByChildren: boolean;",
        [
          "/**",
          " * Variable: constrainGroupByChildren",
          " *",
          " * Specifies if the size of groups should be constrained by the children.",
          " * Default is false.",
          " */"
        ]
      ],
      "rotationHandleVSpacing": [
        "rotationHandleVSpacing: number;",
        [
          "/**",
          " * Variable: rotationHandleVSpacing",
          " *",
          " * Vertical spacing for rotation icon. Default is -16.",
          " */"
        ]
      ],
      "horizontalOffset": [
        "horizontalOffset: number;",
        [
          "/**",
          " * Variable: horizontalOffset",
          " *",
          " * The horizontal offset for the handles. This is updated in <redrawHandles>",
          " * if <manageSizers> is true and the sizers are offset horizontally.",
          " */"
        ]
      ],
      "verticalOffset": [
        "verticalOffset: number;",
        [
          "/**",
          " * Variable: verticalOffset",
          " *",
          " * The horizontal offset for the handles. This is updated in <redrawHandles>",
          " * if <manageSizers> is true and the sizers are offset vertically.",
          " */"
        ]
      ],
      "init": [
        "init(): void;",
        [
          "/**",
          " * Function: init",
          " *",
          " * Initializes the shapes required for this vertex handler.",
          " */"
        ]
      ],
      "isRotationHandleVisible": [
        "isRotationHandleVisible(): boolean;",
        [
          "/**",
          " * Function: isRotationHandleVisible",
          " *",
          " * Returns true if the rotation handle should be showing.",
          " */"
        ]
      ],
      "isConstrainedEvent": [
        "isConstrainedEvent(me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Function: isConstrainedEvent",
          " *",
          " * Returns true if the aspect ratio if the cell should be maintained.",
          " */"
        ]
      ],
      "isCenteredEvent": [
        "isCenteredEvent(state: mxCellState, me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Function: isCenteredEvent",
          " *",
          " * Returns true if the center of the vertex should be maintained during the resize.",
          " */"
        ]
      ],
      "createCustomHandles": [
        "createCustomHandles(): any[];",
        [
          "/**",
          " * Function: createCustomHandles",
          " *",
          " * Returns an array of custom handles. This implementation returns null.",
          " */"
        ]
      ],
      "updateMinBounds": [
        "updateMinBounds(): void;",
        [
          "/**",
          " * Function: updateMinBounds",
          " *",
          " * Initializes the shapes required for this vertex handler.",
          " */"
        ]
      ],
      "getSelectionBounds": [
        "getSelectionBounds(state: mxCellState): mxRectangle;",
        [
          "/**",
          " * Function: getSelectionBounds",
          " *",
          " * Returns the mxRectangle that defines the bounds of the selection",
          " * border.",
          " */"
        ]
      ],
      "createParentHighlightShape": [
        "createParentHighlightShape(bounds: mxRectangle): mxRectangleShape;",
        [
          "/**",
          " * Function: createParentHighlightShape",
          " *",
          " * Creates the shape used to draw the selection border.",
          " */"
        ]
      ],
      "createSelectionShape": [
        "createSelectionShape(bounds: mxRectangle): mxRectangleShape;",
        [
          "/**",
          " * Function: createSelectionShape",
          " *",
          " * Creates the shape used to draw the selection border.",
          " */"
        ]
      ],
      "getSelectionColor": [
        "getSelectionColor(): string;",
        [
          "/**",
          " * Function: getSelectionColor",
          " *",
          " * Returns <mxConstants.VERTEX_SELECTION_COLOR>.",
          " */"
        ]
      ],
      "getSelectionStrokeWidth": [
        "getSelectionStrokeWidth(): number;",
        [
          "/**",
          " * Function: getSelectionStrokeWidth",
          " *",
          " * Returns <mxConstants.VERTEX_SELECTION_STROKEWIDTH>.",
          " */"
        ]
      ],
      "isSelectionDashed": [
        "isSelectionDashed(): boolean;",
        [
          "/**",
          " * Function: isSelectionDashed",
          " *",
          " * Returns <mxConstants.VERTEX_SELECTION_DASHED>.",
          " */"
        ]
      ],
      "createSizer": [
        "createSizer(cursor: string, index: number, size: number, fillColor: string): mxRectangleShape;",
        [
          "/**",
          " * Function: createSizer",
          " *",
          " * Creates a sizer handle for the specified cursor and index and returns",
          " * the new <mxRectangleShape> that represents the handle.",
          " */"
        ]
      ],
      "isSizerVisible": [
        "isSizerVisible(index: number): boolean;",
        [
          "/**",
          " * Function: isSizerVisible",
          " *",
          " * Returns true if the sizer for the given index is visible.",
          " * This returns true for all given indices.",
          " */"
        ]
      ],
      "createSizerShape": [
        "createSizerShape(bounds: mxRectangle, index: number, fillColor: string): mxShape;",
        [
          "/**",
          " * Function: createSizerShape",
          " *",
          " * Creates the shape used for the sizer handle for the specified bounds an",
          " * index. Only images and rectangles should be returned if support for HTML",
          " * labels with not foreign objects is required.",
          " */"
        ]
      ],
      "moveSizerTo": [
        "moveSizerTo(shape: mxRectangleShape, x: number, y: number): void;",
        [
          "/**",
          " * Function: createBounds",
          " *",
          " * Helper method to create an <mxRectangle> around the given centerpoint",
          " * with a width and height of 2*s or 6, if no s is given.",
          " */"
        ]
      ],
      "getHandleForEvent": [
        "getHandleForEvent(me: mxMouseEvent): number;",
        [
          "/**",
          " * Function: getHandleForEvent",
          " *",
          " * Returns the index of the handle for the given event. This returns the index",
          " * of the sizer from where the event originated or <mxEvent.LABEL_INDEX>.",
          " */"
        ]
      ],
      "isCustomHandleEvent": [
        "isCustomHandleEvent(me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Function: isCustomHandleEvent",
          " *",
          " * Returns true if the given event allows custom handles to be changed. This",
          " * implementation returns true.",
          " */"
        ]
      ],
      "mouseDown": [
        "mouseDown(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseDown",
          " *",
          " * Handles the event if a handle has been clicked. By consuming the",
          " * event all subsequent events of the gesture are redirected to this",
          " * handler.",
          " */"
        ]
      ],
      "isLivePreviewBorder": [
        "isLivePreviewBorder(): boolean;",
        [
          "/**",
          " * Function: isLivePreviewBorder",
          " *",
          " * Called if <livePreview> is enabled to check if a border should be painted.",
          " * This implementation returns true if the shape is transparent.",
          " */"
        ]
      ],
      "start": [
        "start(x: number, y: number, index: number): void;",
        [
          "/**",
          " * Function: start",
          " *",
          " * Starts the handling of the mouse gesture.",
          " */"
        ]
      ],
      "setHandlesVisible": [
        "setHandlesVisible(visible: boolean): void;",
        [
          "/**",
          " * Function: hideHandles",
          " *",
          " * Shortcut to <hideSizers>.",
          " */"
        ]
      ],
      "hideSizers": [
        "hideSizers(): void;",
        [
          "/**",
          " * Function: hideSizers",
          " *",
          " * Hides all sizers except.",
          " *",
          " * Starts the handling of the mouse gesture.",
          " */"
        ]
      ],
      "checkTolerance": [
        "checkTolerance(me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: checkTolerance",
          " *",
          " * Checks if the coordinates for the given event are within the",
          " * <mxGraph.tolerance>. If the event is a mouse event then the tolerance is",
          " * ignored.",
          " */"
        ]
      ],
      "updateHint": [
        "updateHint(me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: updateHint",
          " *",
          " * Hook for subclassers do show details while the handler is active.",
          " */"
        ]
      ],
      "removeHint": [
        "removeHint(): void;",
        [
          "/**",
          " * Function: removeHint",
          " *",
          " * Hooks for subclassers to hide details when the handler gets inactive.",
          " */"
        ]
      ],
      "roundAngle": [
        "roundAngle(angle: number): number;",
        [
          "/**",
          " * Function: roundAngle",
          " *",
          " * Hook for rounding the angle. This uses Math.round.",
          " */"
        ]
      ],
      "roundLength": [
        "roundLength(length: number): number;",
        [
          "/**",
          " * Function: roundLength",
          " *",
          " * Hook for rounding the unscaled width or height. This uses Math.round.",
          " */"
        ]
      ],
      "mouseMove": [
        "mouseMove(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseMove",
          " *",
          " * Handles the event by updating the preview.",
          " */"
        ]
      ],
      "moveLabel": [
        "moveLabel(me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: rotateVertex",
          " *",
          " * Rotates the vertex.",
          " */"
        ]
      ],
      "rotateVertex": [
        "rotateVertex(me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: rotateVertex",
          " *",
          " * Rotates the vertex.",
          " */"
        ]
      ],
      "resizeVertex": [
        "resizeVertex(me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: rotateVertex",
          " *",
          " * Rotates the vertex.",
          " */"
        ]
      ],
      "updateLivePreview": [
        "updateLivePreview(me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: updateLivePreview",
          " *",
          " * Repaints the live preview.",
          " */"
        ]
      ],
      "mouseUp": [
        "mouseUp(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseUp",
          " *",
          " * Handles the event by applying the changes to the geometry.",
          " */"
        ]
      ],
      "isRecursiveResize": [
        "isRecursiveResize(state: mxCellState, me: mxMouseEvent): boolean;",
        [
          "/**",
          " * Function: rotateCell",
          " *",
          " * Rotates the given cell to the given rotation.",
          " */"
        ]
      ],
      "rotateClick": [
        "rotateClick(): void;",
        [
          "/**",
          " * Function: rotateClick",
          " *",
          " * Hook for subclassers to implement a single click on the rotation handle.",
          " * This code is executed as part of the model transaction. This implementation",
          " * is empty.",
          " */"
        ]
      ],
      "rotateCell": [
        "rotateCell(cell: mxCell, angle: number, parent: mxCell): void;",
        [
          "/**",
          " * Function: rotateCell",
          " *",
          " * Rotates the given cell and its children by the given angle in degrees.",
          " *",
          " * Parameters:",
          " *",
          " * cell - <mxCell> to be rotated.",
          " * angle - Angle in degrees.",
          " */"
        ]
      ],
      "reset": [
        "reset(): void;",
        [
          "/**",
          " * Function: reset",
          " *",
          " * Resets the state of this handler.",
          " */"
        ]
      ],
      ")": [
        "): void;",
        [
          "/**",
          " * Function: union",
          " *",
          " * Returns the union of the given bounds and location for the specified",
          " * handle index.",
          " *",
          " * To override this to limit the size of vertex via a minWidth/-Height style,",
          " * the following code can be used.",
          " *",
          " * (code)",
          " * var vertexHandlerUnion = union;",
          " * union(bounds, dx, dy, index, gridEnabled, scale, tr, constrained)",
          " * {",
          " *   var result = vertexHandlerUnion.apply(this, arguments);",
          " *",
          " *   result.width = Math.max(result.width, mxUtils.getNumber(this.state.style, 'minWidth', 0));",
          " *   result.height = Math.max(result.height, mxUtils.getNumber(this.state.style, 'minHeight', 0));",
          " *",
          " *   return result;",
          " * };",
          " * (end)",
          " *",
          " * The minWidth/-Height style can then be used as follows:",
          " *",
          " * (code)",
          " * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'minWidth=100;minHeight=100;');",
          " * (end)",
          " *",
          " * To override this to update the height for a wrapped text if the width of a vertex is",
          " * changed, the following can be used.",
          " *",
          " * (code)",
          " * var mxVertexHandlerUnion = union;",
          " * union(bounds, dx, dy, index, gridEnabled, scale, tr, constrained)",
          " * {",
          " *   var result = mxVertexHandlerUnion.apply(this, arguments);",
          " *   var s = this.state;",
          " *",
          " *   if (this.graph.isHtmlLabel(s.cell) && (index == 3 || index == 4) &&",
          " *       s.text != null && s.style.whiteSpace == 'wrap')",
          " *   {",
          " *     var label = this.graph.getLabel(s.cell);",
          " *     var fontSize = mxUtils.getNumber(s.style, 'fontSize', mxConstants.DEFAULT_FONTSIZE);",
          " *     var ww = result.width / s.view.scale - s.text.spacingRight - s.text.spacingLeft",
          " *",
          " *     result.height = mxUtils.getSizeForString(label, fontSize, s.style.fontFamily, ww).height;",
          " *   }",
          " *",
          " *   return result;",
          " * };",
          " * (end)",
          " */"
        ]
      ],
      "moveChildren": [
        "moveChildren(cell: mxCell, dx: number, dy: number): void;",
        [
          "/**",
          " * Function: moveChildren",
          " *",
          " * Moves the children of the given cell by the given vector.",
          " */"
        ]
      ],
      "redraw": [
        "redraw(): void;",
        [
          "/**",
          " * Function: redraw",
          " *",
          " * Redraws the handles and the preview.",
          " */"
        ]
      ],
      "getHandlePadding": [
        "getHandlePadding(): mxPoint;",
        [
          "/**",
          " * Returns the padding to be used for drawing handles for the current <bounds>.",
          " */"
        ]
      ],
      "redrawHandles": [
        "redrawHandles(): void;",
        [
          "/**",
          " * Function: redrawHandles",
          " *",
          " * Redraws the handles. To hide certain handles the following code can be used.",
          " *",
          " * (code)",
          " * redrawHandles()",
          " * {",
          " *   mxVertexHandlerRedrawHandles.apply(this, arguments);",
          " *",
          " *   if (this.sizers != null && this.sizers.length > 7)",
          " *   {",
          " *     this.sizers[1].node.style.display = 'none';",
          " *     this.sizers[6].node.style.display = 'none';",
          " *   }",
          " * };",
          " * (end)",
          " */"
        ]
      ],
      "getRotationHandlePosition": [
        "getRotationHandlePosition(): mxPoint;",
        [
          "/**",
          " * Function: getRotationHandlePosition",
          " *",
          " * Returns an <mxPoint> that defines the rotation handle position.",
          " */"
        ]
      ],
      "updateParentHighlight": [
        "updateParentHighlight(): void;",
        [
          "/**",
          " * Function: updateParentHighlight",
          " *",
          " * Updates the highlight of the parent if <parentHighlightEnabled> is true.",
          " */"
        ]
      ],
      "drawPreview": [
        "drawPreview(): void;",
        [
          "/**",
          " * Function: drawPreview",
          " *",
          " * Redraws the preview.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Function: destroy",
          " *",
          " * Destroys the handler and all its resources and DOM nodes.",
          " */"
        ]
      ]
    }
  ],
  "mxTooltipHandler": [
    null,
    {
      "constructor": [
        "constructor(graph: mxGraph, delay?: number);",
        null
      ],
      "zIndex": [
        "zIndex: number;",
        [
          "/**",
          " * Variable: zIndex",
          " *",
          " * Specifies the zIndex for the tooltip and its shadow. Default is 10005.",
          " */"
        ]
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Variable: graph",
          " *",
          " * Reference to the enclosing <mxGraph>.",
          " */"
        ]
      ],
      "delay": [
        "delay: number;",
        [
          "/**",
          " * Variable: delay",
          " *",
          " * Delay to show the tooltip in milliseconds. Default is 500.",
          " */"
        ]
      ],
      "ignoreTouchEvents": [
        "ignoreTouchEvents: boolean;",
        [
          "/**",
          " * Variable: ignoreTouchEvents",
          " *",
          " * Specifies if touch and pen events should be ignored. Default is true.",
          " */"
        ]
      ],
      "hideOnHover": [
        "hideOnHover: boolean;",
        [
          "/**",
          " * Variable: hideOnHover",
          " *",
          " * Specifies if the tooltip should be hidden if the mouse is moved over the",
          " * current cell. Default is false.",
          " */"
        ]
      ],
      "destroyed": [
        "destroyed: boolean;",
        [
          "/**",
          " * Variable: destroyed",
          " *",
          " * True if this handler was destroyed using <destroy>.",
          " */"
        ]
      ],
      "enabled": [
        "enabled: boolean;",
        [
          "/**",
          " * Variable: enabled",
          " *",
          " * Specifies if events are handled. Default is true.",
          " */"
        ]
      ],
      "isEnabled": [
        "isEnabled(): boolean;",
        [
          "/**",
          " * Function: isEnabled",
          " *",
          " * Returns true if events are handled. This implementation",
          " * returns <enabled>.",
          " */"
        ]
      ],
      "setEnabled": [
        "setEnabled(enabled: boolean): void;",
        [
          "/**",
          " * Function: setEnabled",
          " *",
          " * Enables or disables event handling. This implementation",
          " * updates <enabled>.",
          " */"
        ]
      ],
      "isHideOnHover": [
        "isHideOnHover(): boolean;",
        [
          "/**",
          " * Function: isHideOnHover",
          " *",
          " * Returns <hideOnHover>.",
          " */"
        ]
      ],
      "setHideOnHover": [
        "setHideOnHover(value: boolean): void;",
        [
          "/**",
          " * Function: setHideOnHover",
          " *",
          " * Sets <hideOnHover>.",
          " */"
        ]
      ],
      "init": [
        "init(): void;",
        [
          "/**",
          " * Function: init",
          " *",
          " * Initializes the DOM nodes required for this tooltip handler.",
          " */"
        ]
      ],
      "getStateForEvent": [
        "getStateForEvent(me: mxMouseEvent): mxCellState;",
        [
          "/**",
          " * Function: getStateForEvent",
          " *",
          " * Returns the <mxCellState> to be used for showing a tooltip for this event.",
          " */"
        ]
      ],
      "mouseDown": [
        "mouseDown(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseDown",
          " *",
          " * Handles the event by initiating a rubberband selection. By consuming the",
          " * event all subsequent events of the gesture are redirected to this",
          " * handler.",
          " */"
        ]
      ],
      "mouseMove": [
        "mouseMove(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseMove",
          " *",
          " * Handles the event by updating the rubberband selection.",
          " */"
        ]
      ],
      "mouseUp": [
        "mouseUp(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Function: mouseUp",
          " *",
          " * Handles the event by resetting the tooltip timer or hiding the existing",
          " * tooltip.",
          " */"
        ]
      ],
      "resetTimer": [
        "resetTimer(): void;",
        [
          "/**",
          " * Function: resetTimer",
          " *",
          " * Resets the timer.",
          " */"
        ]
      ],
      "reset": [
        "reset(me: mxMouseEvent, restart: boolean, state: mxCellState): void;",
        [
          "/**",
          " * Function: reset",
          " *",
          " * Resets and/or restarts the timer to trigger the display of the tooltip.",
          " */"
        ]
      ],
      "hide": [
        "hide(): void;",
        [
          "/**",
          " * Function: hide",
          " *",
          " * Hides the tooltip and resets the timer.",
          " */"
        ]
      ],
      "hideTooltip": [
        "hideTooltip(): void;",
        [
          "/**",
          " * Function: hideTooltip",
          " *",
          " * Hides the tooltip.",
          " */"
        ]
      ],
      "show": [
        "show(tip: string, x: number, y: number): void;",
        [
          "/**",
          " * Function: show",
          " *",
          " * Shows the tooltip for the specified cell and optional index at the",
          " * specified location (with a vertical offset of 10 pixels).",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Function: destroy",
          " *",
          " * Destroys the handler and all its resources and DOM nodes.",
          " */"
        ]
      ]
    }
  ],
  "mxCellTracker": [
    [
      "/**",
      " * Event handler that highlights cells",
      " *",
      " * @example",
      " * ```javascript",
      " * new mxCellTracker(graph, '#00FF00');",
      " * ```",
      " *",
      " * For detecting dragEnter, dragOver and dragLeave on cells, the following code can be used:",
      " * @example",
      " * ```javascript",
      " * graph.addMouseListener(",
      " * {",
      " *   cell: null,",
      " *   mouseDown: function(sender, me) { },",
      " *   mouseMove: function(sender, me)",
      " *   {",
      " *     var tmp = me.getCell();",
      " *",
      " *     if (tmp != this.cell)",
      " *     {",
      " *       if (this.cell != null)",
      " *       {",
      " *         this.dragLeave(me.getEvent(), this.cell);",
      " *       }",
      " *",
      " *       this.cell = tmp;",
      " *",
      " *       if (this.cell != null)",
      " *       {",
      " *         this.dragEnter(me.getEvent(), this.cell);",
      " *       }",
      " *     }",
      " *",
      " *     if (this.cell != null)",
      " *     {",
      " *       this.dragOver(me.getEvent(), this.cell);",
      " *     }",
      " *   },",
      " *   mouseUp: function(sender, me) { },",
      " *   dragEnter: function(evt, cell)",
      " *   {",
      " *     mxLog.debug('dragEnter', cell.value);",
      " *   },",
      " *   dragOver: function(evt, cell)",
      " *   {",
      " *     mxLog.debug('dragOver', cell.value);",
      " *   },",
      " *   dragLeave: function(evt, cell)",
      " *   {",
      " *     mxLog.debug('dragLeave', cell.value);",
      " *   }",
      " * });",
      " * ```",
      " */"
    ],
    {
      "constructor": [
        "constructor(graph: mxGraph, color: string, funct?: Function);",
        [
          "/**",
          " * Constructs an event handler that highlights cells.",
          " *",
          " * @param graph   Reference to the enclosing {@link mxGraph}.",
          " * @param color   Color of the highlight. Default is blue.",
          " * @param funct   Optional JavaScript function that is used to override {@link mxCellMarker.getCell}.",
          " */"
        ]
      ],
      "mouseDown": [
        "mouseDown(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Ignores the event. The event is not consumed.",
          " */"
        ]
      ],
      "mouseMove": [
        "mouseMove(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Handles the event by highlighting the cell under the mousepointer if it",
          " * is over the hotspot region of the cell.",
          " */"
        ]
      ],
      "mouseUp": [
        "mouseUp(sender: any, me: mxMouseEvent): void;",
        [
          "/**",
          " * Handles the event by resetting the highlight.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Function: destroy",
          " *",
          " * Destroys the object and all its resources and DOM nodes. This doesn't",
          " * normally need to be called. It is called automatically when the window",
          " * unloads.",
          " */"
        ]
      ]
    }
  ],
  "mxCodecRegistry": [
    [
      "/**",
      " * Singleton class that acts as a global registry for codecs.",
      " *",
      " * ### Adding an <mxCodec>:",
      " *",
      " * 1. Define a default codec with a new instance of the object to be handled.",
      " *",
      " *     ```javascript",
      " *     var codec = new mxObjectCodec(new mxGraphModel());",
      " *     ```",
      " *",
      " * 2. Define the functions required for encoding and decoding objects.",
      " *",
      " *     ```javascript",
      " *     codec.encode = function(enc, obj) { ... }",
      " *     codec.decode = function(dec, node, into) { ... }",
      " *     ```",
      " *",
      " * 3. Register the codec in the <mxCodecRegistry>.",
      " *",
      " *     ```javascript",
      " *     mxCodecRegistry.register(codec);",
      " *     ```",
      " *",
      " * {@link mxObjectCodec.decode} may be used to either create a new",
      " * instance of an object or to configure an existing instance,",
      " * in which case the into argument points to the existing",
      " * object. In this case, we say the codec \"configures\" the",
      " * object.",
      " *",
      " * @class mxCodecRegistry",
      " */"
    ],
    {
      "static codecs": [
        "static codecs: { [key: string]: mxObjectCodec };",
        [
          "/**",
          " * Maps from constructor names to codecs.",
          " * @static",
          " */"
        ]
      ],
      "static aliases": [
        "static aliases: { [key: string]: any };",
        [
          "/**",
          " * Maps from classnames to codecnames.",
          " * @static",
          " */"
        ]
      ],
      "static register": [
        "static register(codec: mxObjectCodec): mxObjectCodec;",
        [
          "/**",
          " * Registers a new codec and associates the name of the template",
          " * constructor in the codec with the codec object.",
          " *",
          " * @static",
          " *",
          " * @param codec - {@link mxObjectCodec} to be registered.",
          " */"
        ]
      ],
      "static addAlias": [
        "static addAlias(classname: string, codecname: string): void;",
        [
          "/**",
          " * Adds an alias for mapping a classname to a codecname.",
          " * @static",
          " */"
        ]
      ],
      "static getCodec": [
        "static getCodec(ctor: any): mxObjectCodec;",
        [
          "/**",
          " * Returns a codec that handles objects that are constructed",
          " * using the given constructor.",
          " *",
          " * @static",
          " *",
          " * @param ctor - JavaScript constructor function.",
          " */"
        ]
      ]
    }
  ],
  "mxObjectCodec": [
    [
      "/**",
      " * Generic codec for JavaScript objects that implements a mapping between",
      " * JavaScript objects and XML nodes that maps each field or element to an",
      " * attribute or child node, and vice versa.",
      " *",
      " * ### Atomic Values",
      " *",
      " * Consider the following example.",
      " *",
      " * ```javascript",
      " * var obj = new Object();",
      " * obj.foo = \"Foo\";",
      " * obj.bar = \"Bar\";",
      " * ```",
      " *",
      " * This object is encoded into an XML node using the following.",
      " *",
      " * ```javascript",
      " * var enc = new mxCodec();",
      " * var node = enc.encode(obj);",
      " * ```",
      " *",
      " * The output of the encoding may be viewed using {@link mxLog} as follows.",
      " *",
      " * ```javascript",
      " * mxLog.show();",
      " * mxLog.debug(mxUtils.getPrettyXml(node));",
      " * ```",
      " *",
      " * Finally, the result of the encoding looks as follows.",
      " *",
      " * ```javascript",
      " * <Object foo=\"Foo\" bar=\"Bar\"/>",
      " * ```",
      " *",
      " * In the above output, the foo and bar fields have been mapped to attributes",
      " * with the same names, and the name of the constructor was used for the",
      " * nodename.",
      " *",
      " * ### Booleans",
      " *",
      " * Since booleans are numbers in JavaScript, all boolean values are encoded",
      " * into 1 for true and 0 for false. The decoder also accepts the string true",
      " * and false for boolean values.",
      " *",
      " * ### Objects",
      " *",
      " * The above scheme is applied to all atomic fields, that is, to all non-object",
      " * fields of an object. For object fields, a child node is created with a",
      " * special attribute that contains the fieldname. This special attribute is",
      " * called \"as\" and hence, as is a reserved word that should not be used for a",
      " * fieldname.",
      " *",
      " * Consider the following example where foo is an object and bar is an atomic",
      " * property of foo.",
      " *",
      " * ```javascript",
      " * var obj = {foo: {bar: \"Bar\"}};",
      " * ```",
      " *",
      " * This will be mapped to the following XML structure by mxObjectCodec.",
      " *",
      " * ```javascript",
      " * <Object>",
      " *   <Object bar=\"Bar\" as=\"foo\"/>",
      " * </Object>",
      " * ```",
      " *",
      " * In the above output, the inner Object node contains the as-attribute that",
      " * specifies the fieldname in the enclosing object. That is, the field foo was",
      " * mapped to a child node with an as-attribute that has the value foo.",
      " *",
      " * ### Arrays",
      " *",
      " * Arrays are special objects that are either associative, in which case each",
      " * key, value pair is treated like a field where the key is the fieldname, or",
      " * they are a sequence of atomic values and objects, which is mapped to a",
      " * sequence of child nodes. For object elements, the above scheme is applied",
      " * without the use of the special as-attribute for creating each child. For",
      " * atomic elements, a special add-node is created with the value stored in the",
      " * value-attribute.",
      " *",
      " * For example, the following array contains one atomic value and one object",
      " * with a field called bar. Furthermore it contains two associative entries",
      " * called bar with an atomic value, and foo with an object value.",
      " *",
      " * ```javascript",
      " * var obj = [\"Bar\", {bar: \"Bar\"}];",
      " * obj[\"bar\"] = \"Bar\";",
      " * obj[\"foo\"] = {bar: \"Bar\"};",
      " * ```",
      " *",
      " * This array is represented by the following XML nodes.",
      " *",
      " * ```javascript",
      " * <Array bar=\"Bar\">",
      " *   <add value=\"Bar\"/>",
      " *   <Object bar=\"Bar\"/>",
      " *   <Object bar=\"Bar\" as=\"foo\"/>",
      " * </Array>",
      " * ```",
      " *",
      " * The Array node name is the name of the constructor. The additional",
      " * as-attribute in the last child contains the key of the associative entry,",
      " * whereas the second last child is part of the array sequence and does not",
      " * have an as-attribute.",
      " *",
      " * ### References",
      " *",
      " * Objects may be represented as child nodes or attributes with ID values,",
      " * which are used to lookup the object in a table within {@link mxCodec}. The",
      " * {@link isReference} function is in charge of deciding if a specific field should",
      " * be encoded as a reference or not. Its default implementation returns true if",
      " * the fieldname is in {@link idrefs}, an array of strings that is used to configure",
      " * the {@link mxObjectCodec}.",
      " *",
      " * Using this approach, the mapping does not guarantee that the referenced",
      " * object itself exists in the document. The fields that are encoded as",
      " * references must be carefully chosen to make sure all referenced objects",
      " * exist in the document, or may be resolved by some other means if necessary.",
      " *",
      " * For example, in the case of the graph model all cells are stored in a tree",
      " * whose root is referenced by the model's root field. A tree is a structure",
      " * that is well suited for an XML representation, however, the additional edges",
      " * in the graph model have a reference to a source and target cell, which are",
      " * also contained in the tree. To handle this case, the source and target cell",
      " * of an edge are treated as references, whereas the children are treated as",
      " * objects. Since all cells are contained in the tree and no edge references a",
      " * source or target outside the tree, this setup makes sure all referenced",
      " * objects are contained in the document.",
      " *",
      " * In the case of a tree structure we must further avoid infinite recursion by",
      " * ignoring the parent reference of each child. This is done by returning true",
      " * in {@link isExcluded}, whose default implementation uses the array of excluded",
      " * fieldnames passed to the mxObjectCodec constructor.",
      " *",
      " * References are only used for cells in mxGraph. For defining other",
      " * referencable object types, the codec must be able to work out the ID of an",
      " * object. This is done by implementing {@link mxCodec.reference}. For decoding a",
      " * reference, the XML node with the respective id-attribute is fetched from the",
      " * document, decoded, and stored in a lookup table for later reference. For",
      " * looking up external objects, {@link mxCodec.lookup} may be implemented.",
      " *",
      " * ### Expressions",
      " *",
      " * For decoding JavaScript expressions, the add-node may be used with a text",
      " * content that contains the JavaScript expression. For example, the following",
      " * creates a field called foo in the enclosing object and assigns it the value",
      " * of {@link mxConstants.ALIGN_LEFT}.",
      " *",
      " * ```javascript",
      " * <Object>",
      " *   <add as=\"foo\">mxConstants.ALIGN_LEFT</add>",
      " * </Object>",
      " * ```",
      " *",
      " * The resulting object has a field called foo with the value \"left\". Its XML",
      " * representation looks as follows.",
      " *",
      " * ```javascript",
      " * <Object foo=\"left\"/>",
      " * ```",
      " *",
      " * This means the expression is evaluated at decoding time and the result of",
      " * the evaluation is stored in the respective field. Valid expressions are all",
      " * JavaScript expressions, including function definitions, which are mapped to",
      " * functions on the resulting object.",
      " *",
      " * Expressions are only evaluated if {@link allowEval} is true.",
      " *",
      " * @class mxObjectCodec",
      " */"
    ],
    {
      "constructor": [
        "constructor(template: any, exclude?: Array<string>, idrefs?: Array<string>, mapping?: { [key: string]: string });",
        [
          "/**",
          " * Constructs a new codec for the specified template object.",
          " * The variables in the optional exclude array are ignored by",
          " * the codec. Variables in the optional idrefs array are",
          " * turned into references in the XML. The optional mapping",
          " * may be used to map from variable names to XML attributes.",
          " * The argument is created as follows:",
          " *",
          " * ```javascript",
          " * var mapping = new Object();",
          " * mapping['variableName'] = 'attribute-name';",
          " * ```",
          " *",
          " * @param template Prototypical instance of the object to be",
          " * encoded/decoded.",
          " * @param exclude Optional array of fieldnames to be ignored.",
          " * @param idrefs Optional array of fieldnames to be converted to/from",
          " * references.",
          " * @param mapping Optional mapping from field- to attributenames.",
          " */"
        ]
      ],
      "static allowEval": [
        "static allowEval: boolean;",
        [
          "/**",
          " * Static global switch that specifies if expressions in arrays are allowed.",
          " * Default is false. NOTE: Enabling this carries a possible security risk.",
          " * @static",
          " */"
        ]
      ],
      "template": [
        "template: any;",
        [
          "/**",
          " * Holds the template object associated with this codec.",
          " */"
        ]
      ],
      "exclude": [
        "exclude: Array<string>;",
        [
          "/**",
          " * Array containing the variable names that should be",
          " * ignored by the codec.",
          " */"
        ]
      ],
      "idrefs": [
        "idrefs: Array<string>;",
        [
          "/**",
          " * Array containing the variable names that should be",
          " * turned into or converted from references. See",
          " * {@link mxCodec.getId} and {@link mxCodec.getObject}.",
          " */"
        ]
      ],
      "mapping": [
        "mapping: { [key: string]: string };",
        [
          "/**",
          " * Maps from from fieldnames to XML attribute names.",
          " */"
        ]
      ],
      "reverse": [
        "reverse: any;",
        [
          "/**",
          " * Maps from from XML attribute names to fieldnames.",
          " */"
        ]
      ],
      "getName": [
        "getName(): string;",
        [
          "/**",
          " * Returns the name used for the nodenames and lookup of the codec when",
          " * classes are encoded and nodes are decoded. For classes to work with",
          " * this the codec registry automatically adds an alias for the classname",
          " * if that is different than what this returns. The default implementation",
          " * returns the classname of the template class.",
          " */"
        ]
      ],
      "cloneTemplate": [
        "cloneTemplate(): any;",
        [
          "/**",
          " * Returns a new instance of the template for this codec.",
          " */"
        ]
      ],
      "getFieldName": [
        "getFieldName(attributename: string): string;",
        [
          "/**",
          " * Returns the fieldname for the given attributename.",
          " * Looks up the value in the {@link reverse} mapping or returns",
          " * the input if there is no reverse mapping for the",
          " * given name.",
          " */"
        ]
      ],
      "getAttributeName": [
        "getAttributeName(fieldname: string): string;",
        [
          "/**",
          " * Returns the attributename for the given fieldname.",
          " * Looks up the value in the {@link mapping} or returns",
          " * the input if there is no mapping for the",
          " * given name.",
          " */"
        ]
      ],
      "isExcluded": [
        "isExcluded(obj: any, attr: string, value: any, write?: boolean): boolean;",
        [
          "/**",
          " * Returns true if the given attribute is to be ignored by the codec. This",
          " * implementation returns true if the given fieldname is in {@link exclude} or",
          " * if the fieldname equals {@link mxObjectIdentity.FIELD_NAME}.",
          " *",
          " * @param obj Object instance that contains the field.",
          " * @param attr Fieldname of the field.",
          " * @param value Value of the field.",
          " * @param write Boolean indicating if the field is being encoded or decoded.",
          " * Write is true if the field is being encoded, else it is being decoded.",
          " */"
        ]
      ],
      "isReference": [
        "isReference(obj: any, attr: string, value: any, write?: boolean): boolean;",
        [
          "/**",
          " * Returns true if the given fieldname is to be treated",
          " * as a textual reference (ID). This implementation returns",
          " * true if the given fieldname is in {@link idrefs}.",
          " *",
          " * @param obj Object instance that contains the field.",
          " * @param attr Fieldname of the field.",
          " * @param value Value of the field.",
          " * @param write Boolean indicating if the field is being encoded or decoded.",
          " * Write is true if the field is being encoded, else it is being decoded.",
          " */"
        ]
      ],
      "encode": [
        "encode(enc: mxCodec, obj: any): Node;",
        [
          "/**",
          " * Encodes the specified object and returns a node",
          " * representing then given object. Calls {@link beforeEncode}",
          " * after creating the node and {@link afterEncode} with the",
          " * resulting node after processing.",
          " *",
          " * Enc is a reference to the calling encoder. It is used",
          " * to encode complex objects and create references.",
          " *",
          " * This implementation encodes all variables of an",
          " * object according to the following rules:",
          " *",
          " * - If the variable name is in {@link exclude} then it is ignored.",
          " * - If the variable name is in {@link idrefs} then {@link mxCodec.getId}",
          " * is used to replace the object with its ID.",
          " * - The variable name is mapped using {@link mapping}.",
          " * - If obj is an array and the variable name is numeric",
          " * (ie. an index) then it is not encoded.",
          " * - If the value is an object, then the codec is used to",
          " * create a child node with the variable name encoded into",
          " * the \"as\" attribute.",
          " * - Else, if {@link encodeDefaults} is true or the value differs",
          " * from the template value, then ...",
          " * - ... if obj is not an array, then the value is mapped to",
          " * an attribute.",
          " * - ... else if obj is an array, the value is mapped to an",
          " * add child with a value attribute or a text child node,",
          " * if the value is a function.",
          " *",
          " * If no ID exists for a variable in {@link idrefs} or if an object",
          " * cannot be encoded, a warning is issued using {@link mxLog.warn}.",
          " *",
          " * Returns the resulting XML node that represents the given",
          " * object.",
          " *",
          " * @param enc {@link mxCodec} that controls the encoding process.",
          " * @param obj Object to be encoded.",
          " */"
        ]
      ],
      "encodeObject": [
        "encodeObject(enc: mxCodec, obj: any, node: Node): void;",
        [
          "/**",
          " * Encodes the value of each member in then given obj into the given node using",
          " * {@link encodeValue}.",
          " *",
          " * @param enc {@link mxCodec} that controls the encoding process.",
          " * @param obj Object to be encoded.",
          " * @param node XML node that contains the encoded object.",
          " */"
        ]
      ],
      "encodeValue": [
        "encodeValue(enc: mxCodec, obj: any, name: string, value: any, node: Node): void;",
        [
          "/**",
          " * Converts the given value according to the mappings",
          " * and id-refs in this codec and uses {@link writeAttribute}",
          " * to write the attribute into the given node.",
          " *",
          " * @param enc {@link mxCodec} that controls the encoding process.",
          " * @param obj Object whose property is going to be encoded.",
          " * @param name XML node that contains the encoded object.",
          " * @param value Value of the property to be encoded.",
          " * @param node XML node that contains the encoded object.",
          " */"
        ]
      ],
      "writeAttribute": [
        "writeAttribute(enc: mxCodec, obj: any, name: string, value: any, node: Node): void;",
        [
          "/**",
          " * Writes the given value into node using {@link writePrimitiveAttribute}",
          " * or {@link writeComplexAttribute} depending on the type of the value.",
          " */"
        ]
      ],
      "writePrimitiveAttribute": [
        "writePrimitiveAttribute(enc: mxCodec, obj: any, name: string, value: any, node: Node): void;",
        [
          "/**",
          " * Writes the given value as an attribute of the given node.",
          " */"
        ]
      ],
      "writeComplexAttribute": [
        "writeComplexAttribute(enc: mxCodec, obj: any, name: string, value: any, node: Node): void;",
        [
          "/**",
          " * Writes the given value as a child node of the given node.",
          " */"
        ]
      ],
      "convertAttributeToXml": [
        "convertAttributeToXml(enc: mxCodec, obj: any, name: string, value: any): any;",
        [
          "/**",
          " * Converts true to \"1\" and false to \"0\" is {@link isBooleanAttribute} returns true.",
          " * All other values are not converted.",
          " *",
          " * @param enc {@link mxCodec} that controls the encoding process.",
          " * @param obj Objec to convert the attribute for.",
          " * @param name Name of the attribute to be converted.",
          " * @param value Value to be converted.",
          " */"
        ]
      ],
      "isBooleanAttribute": [
        "isBooleanAttribute(enc: mxCodec, obj: any, name: string, value: any): boolean;",
        [
          "/**",
          " * Returns true if the given object attribute is a boolean value.",
          " *",
          " * @param enc {@link mxCodec} that controls the encoding process.",
          " * @param obj Objec to convert the attribute for.",
          " * @param name Name of the attribute to be converted.",
          " * @param value Value of the attribute to be converted.",
          " */"
        ]
      ],
      "convertAttributeFromXml": [
        "convertAttributeFromXml(dec: mxCodec, attr: any, obj: any): any;",
        [
          "/**",
          " * Converts booleans and numeric values to the respective types. Values are",
          " * numeric if {@link isNumericAttribute} returns true.",
          " *",
          " * @param dec {@link mxCodec} that controls the decoding process.",
          " * @param attr XML attribute to be converted.",
          " * @param obj Objec to convert the attribute for.",
          " */"
        ]
      ],
      "isNumericAttribute": [
        "isNumericAttribute(dec: mxCodec, attr: any, obj: any): boolean;",
        [
          "/**",
          " * Returns true if the given XML attribute is or should be a numeric value.",
          " *",
          " * @param dec {@link mxCodec} that controls the decoding process.",
          " * @param attr XML attribute to be converted.",
          " * @param obj Objec to convert the attribute for.",
          " */"
        ]
      ],
      "beforeEncode": [
        "beforeEncode(enc: mxCodec, obj: any, node?: Node): any;",
        [
          "/**",
          " * Hook for subclassers to pre-process the object before",
          " * encoding. This returns the input object. The return",
          " * value of this function is used in {@link encode} to perform",
          " * the default encoding into the given node.",
          " *",
          " * @param enc {@link mxCodec} that controls the encoding process.",
          " * @param obj Object to be encoded.",
          " * @param node XML node to encode the object into.",
          " */"
        ]
      ],
      "afterEncode": [
        "afterEncode(enc: mxCodec, obj: any, node: Node): Node;",
        [
          "/**",
          " * Hook for subclassers to post-process the node",
          " * for the given object after encoding and return the",
          " * post-processed node. This implementation returns",
          " * the input node. The return value of this method",
          " * is returned to the encoder from {@link encode}.",
          " *",
          " * @param enc {@link mxCodec} that controls the encoding process.",
          " * @param obj Object to be encoded.",
          " * @param node XML node that represents the default encoding.",
          " */"
        ]
      ],
      "decode": [
        "decode(dec: mxCodec, node: Node, into?: any): any;",
        [
          "/**",
          " * Parses the given node into the object or returns a new object",
          " * representing the given node.",
          " *",
          " * Dec is a reference to the calling decoder. It is used to decode",
          " * complex objects and resolve references.",
          " *",
          " * If a node has an id attribute then the object cache is checked for the",
          " * object. If the object is not yet in the cache then it is constructed",
          " * using the constructor of {@link template} and cached in {@link mxCodec.objects}.",
          " *",
          " * This implementation decodes all attributes and childs of a node",
          " * according to the following rules:",
          " *",
          " * - If the variable name is in {@link exclude} or if the attribute name is \"id\"",
          " * or \"as\" then it is ignored.",
          " * - If the variable name is in {@link idrefs} then {@link mxCodec.getObject} is used",
          " * to replace the reference with an object.",
          " * - The variable name is mapped using a reverse {@link mapping}.",
          " * - If the value has a child node, then the codec is used to create a",
          " * child object with the variable name taken from the \"as\" attribute.",
          " * - If the object is an array and the variable name is empty then the",
          " * value or child object is appended to the array.",
          " * - If an add child has no value or the object is not an array then",
          " * the child text content is evaluated using {@link mxUtils.eval}.",
          " *",
          " * For add nodes where the object is not an array and the variable name",
          " * is defined, the default mechanism is used, allowing to override/add",
          " * methods as follows:",
          " *",
          " * ```javascript",
          " * <Object>",
          " *   <add as=\"hello\"><![CDATA[",
          " *     function(arg1) {",
          " *       mxUtils.alert('Hello '+arg1);",
          " *     }",
          " *   ]]></add>",
          " * </Object>",
          " * ```",
          " *",
          " * If no object exists for an ID in {@link idrefs} a warning is issued",
          " * using {@link mxLog.warn}.",
          " *",
          " * Returns the resulting object that represents the given XML node",
          " * or the object given to the method as the into parameter.",
          " *",
          " * @param dec {@link mxCodec} that controls the decoding process.",
          " * @param node XML node to be decoded.",
          " * @param into Optional objec to encode the node into.",
          " */"
        ]
      ],
      "decodeNode": [
        "decodeNode(dec: mxCodec, node: Node, obj: any): void;",
        [
          "/**",
          " * Calls {@link decodeAttributes} and {@link decodeChildren} for the given node.",
          " *",
          " * @param dec {@link mxCodec} that controls the decoding process.",
          " * @param node XML node to be decoded.",
          " * @param obj Objec to encode the node into.",
          " */"
        ]
      ],
      "decodeAttributes": [
        "decodeAttributes(dec: mxCodec, node: Node, obj: any): void;",
        [
          "/**",
          " * Decodes all attributes of the given node using {@link decodeAttribute}.",
          " *",
          " * @param dec {@link mxCodec} that controls the decoding process.",
          " * @param node XML node to be decoded.",
          " * @param obj Objec to encode the node into.",
          " */"
        ]
      ],
      "isIgnoredAttribute": [
        "isIgnoredAttribute(dec: mxCodec, attr: any, obj?: any): boolean;",
        [
          "/**",
          " * Returns true if the given attribute should be ignored. This implementation",
          " * returns true if the attribute name is \"as\" or \"id\".",
          " *",
          " * @param dec {@link mxCodec} that controls the decoding process.",
          " * @param attr XML attribute to be decoded.",
          " * @param obj Objec to encode the attribute into.",
          " */"
        ]
      ],
      "decodeAttribute": [
        "decodeAttribute(dec: mxCodec, attr: any, obj?: any): void;",
        [
          "/**",
          " * Reads the given attribute into the specified object.",
          " *",
          " * @param dec {@link mxCodec} that controls the decoding process.",
          " * @param attr XML attribute to be decoded.",
          " * @param obj Objec to encode the attribute into.",
          " */"
        ]
      ],
      "decodeChildren": [
        "decodeChildren(dec: mxCodec, node: Node, obj?: any): void;",
        [
          "/**",
          " * Decodes all children of the given node using {@link decodeChild}.",
          " *",
          " * @param dec {@link mxCodec} that controls the decoding process.",
          " * @param node XML node to be decoded.",
          " * @param obj Objec to encode the node into.",
          " */"
        ]
      ],
      "decodeChild": [
        "decodeChild(dec: mxCodec, child: Node, obj: any): void;",
        [
          "/**",
          " * Reads the specified child into the given object.",
          " *",
          " * @param dec {@link mxCodec} that controls the decoding process.",
          " * @param child XML child element to be decoded.",
          " * @param obj Objec to encode the node into.",
          " */"
        ]
      ],
      "getFieldTemplate": [
        "getFieldTemplate(obj: any, fieldname: string, child: Node): any;",
        [
          "/**",
          " * Returns the template instance for the given field. This returns the",
          " * value of the field, null if the value is an array or an empty collection",
          " * if the value is a collection. The value is then used to populate the",
          " * field for a new instance. For strongly typed languages it may be",
          " * required to override this to return the correct collection instance",
          " * based on the encoded child.",
          " */"
        ]
      ],
      "addObjectValue": [
        "addObjectValue(obj: any, fieldname: string, value: any, template: any): void;",
        [
          "/**",
          " * Sets the decoded child node as a value of the given object. If the",
          " * object is a map, then the value is added with the given fieldname as a",
          " * key. If the fieldname is not empty, then setFieldValue is called or",
          " * else, if the object is a collection, the value is added to the",
          " * collection. For strongly typed languages it may be required to",
          " * override this with the correct code to add an entry to an object.",
          " */"
        ]
      ],
      "processInclude": [
        "processInclude(dec: mxCodec, node: Node, into?: any): boolean;",
        [
          "/**",
          " * Returns true if the given node is an include directive and",
          " * executes the include by decoding the XML document. Returns",
          " * false if the given node is not an include directive.",
          " *",
          " * @param dec {@link mxCodec} that controls the encoding/decoding process.",
          " * @param node XML node to be checked.",
          " * @param into Optional object to pass-thru to the codec.",
          " */"
        ]
      ],
      "beforeDecode": [
        "beforeDecode(dec: mxCodec, node: Node, obj: any): Node;",
        [
          "/**",
          " * Hook for subclassers to pre-process the node for",
          " * the specified object and return the node to be",
          " * used for further processing by {@link decode}.",
          " * The object is created based on the template in the",
          " * calling method and is never null. This implementation",
          " * returns the input node. The return value of this",
          " * function is used in {@link decode} to perform",
          " * the default decoding into the given object.",
          " *",
          " * @param dec {@link mxCodec} that controls the decoding process.",
          " * @param node XML node to be decoded.",
          " * @param obj Object to encode the node into.",
          " */"
        ]
      ],
      "afterDecode": [
        "afterDecode(dec: mxCodec, node: Node, obj?: any): any;",
        [
          "/**",
          " * Hook for subclassers to post-process the object after",
          " * decoding. This implementation returns the given object",
          " * without any changes. The return value of this method",
          " * is returned to the decoder from {@link decode}.",
          " *",
          " * @param enc {@link mxCodec} that controls the encoding process.",
          " * @param node XML node to be decoded.",
          " * @param obj Object that represents the default decoding.",
          " */"
        ]
      ]
    }
  ],
  "mxCodec": [
    [
      "/**",
      " * XML codec for JavaScript object graphs. See {@link mxObjectCodec} for a",
      " * description of the general encoding/decoding scheme. This class uses the",
      " * codecs registered in {@link mxCodecRegistry} for encoding/decoding each object.",
      " *",
      " * ### References",
      " *",
      " * In order to resolve references, especially forward references, the mxCodec",
      " * constructor must be given the document that contains the referenced",
      " * elements.",
      " *",
      " * ### Examples",
      " *",
      " * The following code is used to encode a graph model.",
      " *",
      " * @example",
      " * ```javascript",
      " * var encoder = new mxCodec();",
      " * var result = encoder.encode(graph.getModel());",
      " * var xml = mxUtils.getXml(result);",
      " * ```",
      " *",
      " * #### Example",
      " *",
      " * Using the code below, an XML document is decoded into an existing model. The",
      " * document may be obtained using one of the functions in mxUtils for loading",
      " * an XML file, eg. {@link mxUtils.get}, or using {@link mxUtils.parseXml} for parsing an",
      " * XML string.",
      " *",
      " * @example",
      " * ```javascript",
      " * var doc = mxUtils.parseXml(xmlString);",
      " * var codec = new mxCodec(doc);",
      " * codec.decode(doc.documentElement, graph.getModel());",
      " * ```",
      " *",
      " * #### Example",
      " *",
      " * This example demonstrates parsing a list of isolated cells into an existing",
      " * graph model. Note that the cells do not have a parent reference so they can",
      " * be added anywhere in the cell hierarchy after parsing.",
      " *",
      " * @example",
      " * ```javascript",
      " * var xml = '<root><mxCell id=\"2\" value=\"Hello,\" vertex=\"1\"><mxGeometry x=\"20\" y=\"20\" width=\"80\" height=\"30\" as=\"geometry\"/></mxCell><mxCell id=\"3\" value=\"World!\" vertex=\"1\"><mxGeometry x=\"200\" y=\"150\" width=\"80\" height=\"30\" as=\"geometry\"/></mxCell><mxCell id=\"4\" value=\"\" edge=\"1\" source=\"2\" target=\"3\"><mxGeometry relative=\"1\" as=\"geometry\"/></mxCell></root>';",
      " * var doc = mxUtils.parseXml(xml);",
      " * var codec = new mxCodec(doc);",
      " * var elt = doc.documentElement.firstChild;",
      " * var cells = [];",
      " *",
      " * while (elt != null)",
      " * {",
      " *   cells.push(codec.decode(elt));",
      " *   elt = elt.nextSibling;",
      " * }",
      " *",
      " * graph.addCells(cells);",
      " * ```",
      " *",
      " * #### Example",
      " *",
      " * Using the following code, the selection cells of a graph are encoded and the",
      " * output is displayed in a dialog box.",
      " *",
      " * @example",
      " * ```javascript",
      " * var enc = new mxCodec();",
      " * var cells = graph.getSelectionCells();",
      " * mxUtils.alert(mxUtils.getPrettyXml(enc.encode(cells)));",
      " * ```",
      " *",
      " * Newlines in the XML can be converted to <br>, in which case a '<br>' argument",
      " * must be passed to {@link mxUtils.getXml} as the second argument.",
      " *",
      " * ### Debugging",
      " *",
      " * For debugging I/O you can use the following code to get the sequence of",
      " * encoded objects:",
      " *",
      " * @example",
      " * ```javascript",
      " * var oldEncode = encode;",
      " * encode(obj)",
      " * {",
      " *   mxLog.show();",
      " *   mxLog.debug('mxCodec.encode: obj='+mxUtils.getFunctionName(obj.constructor));",
      " *",
      " *   return oldEncode.apply(this, arguments);",
      " * };",
      " * ```",
      " *",
      " * Note that the I/O system adds object codecs for new object automatically. For",
      " * decoding those objects, the constructor should be written as follows:",
      " *",
      " * @example",
      " * ```javascript",
      " * var MyObj(name)",
      " * {",
      " *   // ...",
      " * };",
      " * ```",
      " *",
      " * @class mxCodec",
      " */"
    ],
    {
      "constructor": [
        "constructor(document?: XMLDocument);",
        [
          "/**",
          " * @constructor",
          " *",
          " * Constructs an XML encoder/decoder for the specified",
          " * owner document.",
          " *",
          " * @param document - Optional XML document that contains the data.",
          " * If no document is specified then a new document is created",
          " * using {@link mxUtils.createXmlDocument}.",
          " */"
        ]
      ],
      "document": [
        "document: XMLDocument;",
        [
          "/**",
          " * The owner document of the codec.",
          " */"
        ]
      ],
      "objects": [
        "objects: Array<string>;",
        [
          "/**",
          " * Maps from IDs to objects.",
          " */"
        ]
      ],
      "elements": [
        "elements: Array<any>;",
        [
          "/**",
          " * Lookup table for resolving IDs to elements.",
          " */"
        ]
      ],
      "encodeDefaults": [
        "encodeDefaults: boolean;",
        [
          "/**",
          " * Specifies if default values should be encoded. Default is false.",
          " */"
        ]
      ],
      "putObject": [
        "putObject(id: string, obj: any): any;",
        [
          "/**",
          " * Assoiates the given object with the given ID and returns the given object.",
          " *",
          " * @param id ID for the object to be associated with.",
          " * @param obj Object to be associated with the ID.",
          " */"
        ]
      ],
      "getObject": [
        "getObject(id: string): any;",
        [
          "/**",
          " * Returns the decoded object for the element with the specified ID in",
          " * {@link document}. If the object is not known then {@link lookup} is used to find an",
          " * object. If no object is found, then the element with the respective ID",
          " * from the document is parsed using {@link decode}.",
          " */"
        ]
      ],
      "lookup": [
        "lookup(id: string): any;",
        [
          "/**",
          " * Hook for subclassers to implement a custom lookup mechanism for cell IDs.",
          " * This implementation always returns null.",
          " *",
          " * Example:",
          " *",
          " * ```javascript",
          " * var codec = new mxCodec();",
          " * codec.lookup(id)",
          " * {",
          " *   return model.getCell(id);",
          " * };",
          " * ```",
          " *",
          " * @param id ID of the object to be returned.",
          " */"
        ]
      ],
      "getElementById": [
        "getElementById(id: string): Element;",
        [
          "/**",
          " * Returns the element with the given ID from {@link document}.",
          " *",
          " * @param id String that contains the ID.",
          " */"
        ]
      ],
      "updateElements": [
        "updateElements(): void;",
        [
          "/**",
          " * Returns the element with the given ID from {@link document}.",
          " *",
          " * @param id String that contains the ID.",
          " */"
        ]
      ],
      "addElement": [
        "addElement(node: Node): void;",
        [
          "/**",
          " * Adds the given element to {@link elements} if it has an ID.",
          " */"
        ]
      ],
      "getId": [
        "getId(obj: any): string;",
        [
          "/**",
          " * Returns the ID of the specified object. This implementation",
          " * calls {@link reference} first and if that returns null handles",
          " * the object as an {@link mxCell} by returning their IDs using",
          " * {@link mxCell.getId}. If no ID exists for the given cell, then",
          " * an on-the-fly ID is generated using {@link mxCellPath.create}.",
          " *",
          " * @param obj Object to return the ID for.",
          " */"
        ]
      ],
      "reference": [
        "reference(obj: any): any;",
        [
          "/**",
          " * Hook for subclassers to implement a custom method",
          " * for retrieving IDs from objects. This implementation",
          " * always returns null.",
          " *",
          " * Example:",
          " *",
          " * ```javascript",
          " * var codec = new mxCodec();",
          " * codec.reference(obj)",
          " * {",
          " *   return obj.getCustomId();",
          " * };",
          " * ```",
          " *",
          " * @param obj Object whose ID should be returned.",
          " */"
        ]
      ],
      "encode": [
        "encode(obj: any): XMLDocument;",
        [
          "/**",
          " * Encodes the specified object and returns the resulting",
          " * XML node.",
          " *",
          " * @param obj Object to be encoded.",
          " */"
        ]
      ],
      "decode": [
        "decode(node: Node, into?: any): any;",
        [
          "/**",
          " * Decodes the given XML node. The optional \"into\"",
          " * argument specifies an existing object to be",
          " * used. If no object is given, then a new instance",
          " * is created using the constructor from the codec.",
          " *",
          " * The function returns the passed in object or",
          " * the new instance if no object was given.",
          " *",
          " * @param node XML node to be decoded.",
          " * @param into Optional object to be decodec into.",
          " */"
        ]
      ],
      "encodeCell": [
        "encodeCell(cell: mxCell, node: Node, includeChildren?: boolean): void;",
        [
          "/**",
          " * Encoding of cell hierarchies is built-into the core, but",
          " * is a higher-level function that needs to be explicitely",
          " * used by the respective object encoders (eg. {@link mxModelCodec},",
          " * {@link mxChildChangeCodec} and {@link mxRootChangeCodec}). This",
          " * implementation writes the given cell and its children as a",
          " * (flat) sequence into the given node. The children are not",
          " * encoded if the optional includeChildren is false. The",
          " * function is in charge of adding the result into the",
          " * given node and has no return value.",
          " *",
          " * @param cell {@link mxCell} to be encoded.",
          " * @param node Parent XML node to add the encoded cell into.",
          " * @param includeChildren Optional boolean indicating if the",
          " * function should include all descendents. Default is true.",
          " */"
        ]
      ],
      "isCellCodec": [
        "isCellCodec(codec: mxCodec): boolean;",
        [
          "/**",
          " * Returns true if the given codec is a cell codec. This uses",
          " * {@link mxCellCodec.isCellCodec} to check if the codec is of the",
          " * given type.",
          " */"
        ]
      ],
      "decodeCell": [
        "decodeCell(node: Node, restoreStructures?: boolean): mxCell;",
        [
          "/**",
          " * Decodes cells that have been encoded using inversion, ie.",
          " * where the user object is the enclosing node in the XML,",
          " * and restores the group and graph structure in the cells.",
          " * Returns a new {@link mxCell} instance that represents the",
          " * given node.",
          " *",
          " * @param node XML node that contains the cell data.",
          " * @param restoreStructures Optional boolean indicating whether",
          " * the graph structure should be restored by calling insert",
          " * and insertEdge on the parent and terminals, respectively.",
          " * Default is true.",
          " */"
        ]
      ],
      "insertIntoGraph": [
        "insertIntoGraph(cell: mxCell): void;",
        [
          "/**",
          " * Inserts the given cell into its parent and terminal cells.",
          " */"
        ]
      ],
      "setAttribute": [
        "setAttribute(node: Node, attribute: string, value: any): void;",
        [
          "/**",
          " * Sets the attribute on the specified node to value. This is a",
          " * helper method that makes sure the attribute and value arguments",
          " * are not null.",
          " *",
          " * @param node XML node to set the attribute for.",
          " * @param attributes Attributename to be set.",
          " * @param value New value of the attribute.",
          " */"
        ]
      ]
    }
  ],
  "mxEditor": [
    [
      "/**",
      " * Extends {@link mxEventSource} to implement an application wrapper for a graph that",
      " * adds {@link actions}, I/O using {@link mxCodec}, auto-layout using {@link mxLayoutManager},",
      " * command history using {@link undoManager}, and standard dialogs and widgets, eg.",
      " * properties, help, outline, toolbar, and popupmenu. It also adds {@link templates}",
      " * to be used as cells in toolbars, auto-validation using the {@link validation}",
      " * flag, attribute cycling using {@link cycleAttributeValues}, higher-level events",
      " * such as {@link root}, and backend integration using <urlPost> and {@link urlImage}.",
      " *",
      " * ### Actions:",
      " *",
      " * Actions are functions stored in the <actions> array under their names. The",
      " * functions take the <mxEditor> as the first, and an optional <mxCell> as the",
      " * second argument and are invoked using <execute>. Any additional arguments",
      " * passed to execute are passed on to the action as-is.",
      " *",
      " * A list of built-in actions is available in the <addActions> description.",
      " *",
      " * ### Read/write Diagrams:",
      " *",
      " * To read a diagram from an XML string, for example from a textfield within the",
      " * page, the following code is used:",
      " *",
      " * @example",
      " * ```javascript",
      " * var doc = mxUtils.parseXML(xmlString);",
      " * var node = doc.documentElement;",
      " * editor.readGraphModel(node);",
      " * ```",
      " *",
      " * For reading a diagram from a remote location, use the {@link open} method.",
      " *",
      " * To save diagrams in XML on a server, you can set the {@link urlPost} variable.",
      " * This variable will be used in {@link getUrlPost} to construct a URL for the post",
      " * request that is issued in the {@link save} method. The post request contains the",
      " * XML representation of the diagram as returned by {@link writeGraphModel} in the",
      " * xml parameter.",
      " *",
      " * On the server side, the post request is processed using standard",
      " * technologies such as Java Servlets, CGI, .NET or ASP.",
      " *",
      " * Here are some examples of processing a post request in various languages.",
      " *",
      " * - Java: URLDecoder.decode(request.getParameter(\"xml\"), \"UTF-8\").replace(\"\\n\", \"&#xa;\")",
      " *",
      " * Note that the linefeeds should only be replaced if the XML is",
      " * processed in Java, for example when creating an image, but not",
      " * if the XML is passed back to the client-side.",
      " *",
      " * - .NET: HttpUtility.UrlDecode(context.Request.Params[\"xml\"])",
      " * - PHP: urldecode($_POST[\"xml\"])",
      " *",
      " * ### Creating images:",
      " *",
      " * A backend (Java, PHP or C#) is required for creating images. The",
      " * distribution contains an example for each backend (ImageHandler.java,",
      " * ImageHandler.cs and graph.php). More information about using a backend",
      " * to create images can be found in the readme.html files. Note that the",
      " * preview is implemented using VML/SVG in the browser and does not require",
      " * a backend. The backend is only required to creates images (bitmaps).",
      " *",
      " * ### Special characters:",
      " *",
      " * Note There are five characters that should always appear in XML content as",
      " * escapes, so that they do not interact with the syntax of the markup. These",
      " * are part of the language for all documents based on XML and for HTML.",
      " *",
      " * - &lt; (<)",
      " * - &gt; (>)",
      " * - &amp; (&)",
      " * - &quot; (\")",
      " * - &apos; (')",
      " *",
      " * Although it is part of the XML language, &apos; is not defined in HTML.",
      " * For this reason the XHTML specification recommends instead the use of",
      " * &#39; if text may be passed to a HTML user agent.",
      " *",
      " * If you are having problems with special characters on the server-side then",
      " * you may want to try the {@link escapePostData} flag.",
      " *",
      " * For converting decimal escape sequences inside strings, a user has provided",
      " * us with the following function:",
      " *",
      " * @example",
      " * ```javascript",
      " * function html2js(text)",
      " * {",
      " *   var entitySearch = /&#[0-9]+;/;",
      " *   var entity;",
      " *",
      " *   while (entity = entitySearch.exec(text))",
      " *   {",
      " *     var charCode = entity[0].substring(2, entity[0].length -1);",
      " *     text = text.substring(0, entity.index)",
      " *            + String.fromCharCode(charCode)",
      " *            + text.substring(entity.index + entity[0].length);",
      " *   }",
      " *",
      " *   return text;",
      " * }",
      " * ```",
      " *",
      " * Otherwise try using hex escape sequences and the built-in unescape function",
      " * for converting such strings.",
      " *",
      " * ### Local Files:",
      " *",
      " * For saving and opening local files, no standardized method exists that",
      " * works across all browsers. The recommended way of dealing with local files",
      " * is to create a backend that streams the XML data back to the browser (echo)",
      " * as an attachment so that a Save-dialog is displayed on the client-side and",
      " * the file can be saved to the local disk.",
      " *",
      " * For example, in PHP the code that does this looks as follows.",
      " *",
      " * @example",
      " * ```javascript",
      " * $xml = stripslashes($_POST[\"xml\"]);",
      " * header(\"Content-Disposition: attachment; filename=\\\"diagram.xml\\\"\");",
      " * echo($xml);",
      " * ```",
      " *",
      " * To open a local file, the file should be uploaded via a form in the browser",
      " * and then opened from the server in the editor.",
      " *",
      " * ### Cell Properties:",
      " *",
      " * The properties displayed in the properties dialog are the attributes and",
      " * values of the cell's user object, which is an XML node. The XML node is",
      " * defined in the templates section of the config file.",
      " *",
      " * The templates are stored in {@link mxEditor.templates} and contain cells which",
      " * are cloned at insertion time to create new vertices by use of drag and",
      " * drop from the toolbar. Each entry in the toolbar for adding a new vertex",
      " * must refer to an existing template.",
      " *",
      " * In the following example, the task node is a business object and only the",
      " * mxCell node and its mxGeometry child contain graph information:",
      " *",
      " * @example",
      " * ```javascript",
      " * <Task label=\"Task\" description=\"\">",
      " *   <mxCell vertex=\"true\">",
      " *     <mxGeometry as=\"geometry\" width=\"72\" height=\"32\"/>",
      " *   </mxCell>",
      " * </Task>",
      " * ```",
      " *",
      " * The idea is that the XML representation is inverse from the in-memory",
      " * representation: The outer XML node is the user object and the inner node is",
      " * the cell. This means the user object of the cell is the Task node with no",
      " * children for the above example:",
      " *",
      " * @example",
      " * ```javascript",
      " * <Task label=\"Task\" description=\"\"/>",
      " * ```",
      " *",
      " * The Task node can have any tag name, attributes and child nodes. The",
      " * {@link mxCodec} will use the XML hierarchy as the user object, while removing the",
      " * \"known annotations\", such as the mxCell node. At save-time the cell data",
      " * will be \"merged\" back into the user object. The user object is only modified",
      " * via the properties dialog during the lifecycle of the cell.",
      " *",
      " * In the default implementation of {@link createProperties}, the user object's",
      " * attributes are put into a form for editing. Attributes are changed using",
      " * the {@link mxCellAttributeChange} action in the model. The dialog can be replaced",
      " * by overriding the {@link createProperties} hook or by replacing the showProperties",
      " * action in {@link action}. Alternatively, the entry in the config file's popupmenu",
      " * section can be modified to invoke a different action.",
      " *",
      " * If you want to displey the properties dialog on a doubleclick, you can set",
      " * {@link mxEditor.dblClickAction} to showProperties as follows:",
      " *",
      " * @example",
      " * ```javascript",
      " * editor.dblClickAction = 'showProperties';",
      " * ```",
      " *",
      " * ### Popupmenu and Toolbar:",
      " *",
      " * The toolbar and popupmenu are typically configured using the respective",
      " * sections in the config file, that is, the popupmenu is defined as follows:",
      " *",
      " * @example",
      " * ```javascript",
      " * <mxEditor>",
      " *   <mxDefaultPopupMenu as=\"popupHandler\">",
      " * \t\t<add as=\"cut\" action=\"cut\" icon=\"images/cut.gif\"/>",
      " *      ...",
      " * ```",
      " *",
      " * New entries can be added to the toolbar by inserting an add-node into the",
      " * above configuration. Existing entries may be removed and changed by",
      " * modifying or removing the respective entries in the configuration.",
      " * The configuration is read by the {@link mxDefaultPopupMenuCodec}, the format of the",
      " * configuration is explained in {@link mxDefaultPopupMenu.decode}.",
      " *",
      " * The toolbar is defined in the mxDefaultToolbar section. Items can be added",
      " * and removed in this section.",
      " *",
      " * @example",
      " * ```javascript",
      " * <mxEditor>",
      " *   <mxDefaultToolbar>",
      " *     <add as=\"save\" action=\"save\" icon=\"images/save.gif\"/>",
      " *     <add as=\"Swimlane\" template=\"swimlane\" icon=\"images/swimlane.gif\"/>",
      " *     ...",
      " * ```",
      " *",
      " * The format of the configuration is described in",
      " * {@link mxDefaultToolbarCodec.decode}.",
      " *",
      " * Ids:",
      " *",
      " * For the IDs, there is an implicit behaviour in {@link mxCodec}: It moves the Id",
      " * from the cell to the user object at encoding time and vice versa at decoding",
      " * time. For example, if the Task node from above has an id attribute, then",
      " * the {@link mxCell.id} of the corresponding cell will have this value. If there",
      " * is no Id collision in the model, then the cell may be retrieved using this",
      " * Id with the {@link mxGraphModel.getCell} function. If there is a collision, a new",
      " * Id will be created for the cell using {@link mxGraphModel.createId}. At encoding",
      " * time, this new Id will replace the value previously stored under the id",
      " * attribute in the Task node.",
      " *",
      " * See {@link mxEditorCodec}, {@link mxDefaultToolbarCodec} and {@link mxDefaultPopupMenuCodec}",
      " * for information about configuring the editor and user interface.",
      " *",
      " * Programmatically inserting cells:",
      " *",
      " * For inserting a new cell, say, by clicking a button in the document,",
      " * the following code can be used. This requires an reference to the editor.",
      " *",
      " * @example",
      " * ```javascript",
      " * var userObject = new Object();",
      " * var parent = editor.graph.getDefaultParent();",
      " * var model = editor.graph.model;",
      " * model.beginUpdate();",
      " * try",
      " * {",
      " *   editor.graph.insertVertex(parent, null, userObject, 20, 20, 80, 30);",
      " * }",
      " * finally",
      " * {",
      " *   model.endUpdate();",
      " * }",
      " * ```",
      " *",
      " * If a template cell from the config file should be inserted, then a clone",
      " * of the template can be created as follows. The clone is then inserted using",
      " * the add function instead of addVertex.",
      " *",
      " * @example",
      " * ```javascript",
      " * var template = editor.templates['task'];",
      " * var clone = editor.graph.model.cloneCell(template);",
      " * ```",
      " *",
      " * #### Resources:",
      " *",
      " * resources/editor - Language resources for mxEditor",
      " *",
      " * #### Callback: onInit",
      " *",
      " * Called from within the constructor. In the callback,",
      " * \"this\" refers to the editor instance.",
      " *",
      " * #### Cookie: mxgraph=seen",
      " *",
      " * Set when the editor is started. Never expires. Use",
      " * {@link resetFirstTime} to reset this cookie. This cookie",
      " * only exists if {@link onInit} is implemented.",
      " *",
      " * #### Event: mxEvent.OPEN",
      " *",
      " * Fires after a file was opened in {@link open}. The <code>filename</code> property",
      " * contains the filename that was used. The same value is also available in",
      " * {@link filename}.",
      " *",
      " * #### Event: mxEvent.SAVE",
      " *",
      " * Fires after the current file was saved in {@link save}. The <code>url</code>",
      " * property contains the URL that was used for saving.",
      " *",
      " * #### Event: mxEvent.POST",
      " *",
      " * Fires if a successful response was received in {@link postDiagram}. The",
      " * <code>request</code> property contains the <mxXmlRequest>, the",
      " * <code>url</code> and <code>data</code> properties contain the URL and the",
      " * data that were used in the post request.",
      " *",
      " * #### Event: mxEvent.ROOT",
      " *",
      " * Fires when the current root has changed, or when the title of the current",
      " * root has changed. This event has no properties.",
      " *",
      " * #### Event: mxEvent.BEFORE_ADD_VERTEX",
      " *",
      " * Fires before a vertex is added in {@link addVertex}. The <code>vertex</code>",
      " * property contains the new vertex and the <code>parent</code> property",
      " * contains its parent.",
      " *",
      " * #### Event: mxEvent.ADD_VERTEX",
      " *",
      " * Fires between begin- and endUpdate in <addVertex>. The <code>vertex</code>",
      " * property contains the vertex that is being inserted.",
      " *",
      " * #### Event: mxEvent.AFTER_ADD_VERTEX",
      " *",
      " * Fires after a vertex was inserted and selected in <addVertex>. The",
      " * <code>vertex</code> property contains the new vertex.",
      " *",
      " * ### Example:",
      " *",
      " * For starting an in-place edit after a new vertex has been added to the",
      " * graph, the following code can be used.",
      " *",
      " * @example",
      " * ```javascript",
      " * editor.addListener(mxEvent.AFTER_ADD_VERTEX, function(sender, evt)",
      " * {",
      " *   var vertex = evt.getProperty('vertex');",
      " *",
      " *   if (editor.graph.isCellEditable(vertex))",
      " *   {",
      " *   \teditor.graph.startEditingAtCell(vertex);",
      " *   }",
      " * });",
      " * ```",
      " *",
      " * ### Event: mxEvent.ESCAPE",
      " *",
      " * Fires when the escape key is pressed. The <code>event</code> property",
      " * contains the key event.",
      " *",
      " * ### Constructor: mxEditor",
      " *",
      " * Constructs a new editor. This function invokes the {@link onInit} callback",
      " * upon completion.",
      " *",
      " * @example",
      " * ```javascript",
      " * var config = mxUtils.load('config/diagrameditor.xml').getDocumentElement();",
      " * var editor = new mxEditor(config);",
      " * ```",
      " *",
      " * @class mxEditor",
      " * @extends mxEventSource",
      " */"
    ],
    {
      "constructor": [
        "constructor(config?: any);",
        [
          "/**",
          " * @param config Optional XML node that contains the configuration",
          " */"
        ]
      ],
      "askZoomResource": [
        "askZoomResource: 'askZoom' | '';",
        [
          "/**",
          " * Specifies the resource key for the zoom dialog. If the resource for this",
          " * key does not exist then the value is used as the error message. Default is 'askZoom'.",
          " * @default 'askZoom'",
          " */"
        ]
      ],
      "lastSavedResource": [
        "lastSavedResource: 'lastSaved' | '';",
        [
          "/**",
          " * Specifies the resource key for the last saved info. If the resource for",
          " * this key does not exist then the value is used as the error message. Default is 'lastSaved'.",
          " * @default 'lastSaved'.",
          " */"
        ]
      ],
      "currentFileResource": [
        "currentFileResource: 'currentFile' | '';",
        [
          "/**",
          " * Specifies the resource key for the current file info. If the resource for",
          " * this key does not exist then the value is used as the error message. Default is 'currentFile'.",
          " * @default 'currentFile'",
          " */"
        ]
      ],
      "propertiesResource": [
        "propertiesResource: 'properties' | '';",
        [
          "/**",
          " * Specifies the resource key for the properties window title. If the",
          " * resource for this key does not exist then the value is used as the",
          " * error message. Default is 'properties'.",
          " * @default 'properties'",
          " */"
        ]
      ],
      "tasksResource": [
        "tasksResource: 'tasks' | '';",
        [
          "/**",
          " * Specifies the resource key for the tasks window title. If the",
          " * resource for this key does not exist then the value is used as the",
          " * error message. Default is 'tasks'.",
          " * @default 'tasks'",
          " */"
        ]
      ],
      "helpResource": [
        "helpResource: 'help' | '';",
        [
          "/**",
          " * Specifies the resource key for the help window title. If the",
          " * resource for this key does not exist then the value is used as the",
          " * error message. Default is 'help'.",
          " * @default 'help'",
          " */"
        ]
      ],
      "outlineResource": [
        "outlineResource: 'outline' | '';",
        [
          "/**",
          " * Specifies the resource key for the outline window title. If the",
          " * resource for this key does not exist then the value is used as the",
          " * error message. Default is 'outline'.",
          " * @default 'outline'",
          " */"
        ]
      ],
      "outline": [
        "outline: any;",
        [
          "/**",
          " * Reference to the {@link mxWindow} that contains the outline. The {@link mxOutline}",
          " * is stored in outline.outline.",
          " */"
        ]
      ],
      "graph": [
        "graph: mxGraph;",
        [
          "/**",
          " * Holds a {@link mxGraph} for displaying the diagram. The graph",
          " * is created in {@link setGraphContainer}.",
          " */"
        ]
      ],
      "graphRenderHint": [
        "graphRenderHint: any;",
        [
          "/**",
          " * Holds the render hint used for creating the",
          " * graph in {@link setGraphContainer}. See {@link mxGraph}. Default is null.",
          " * @default null",
          " */"
        ]
      ],
      "toolbar": [
        "toolbar: any;",
        [
          "/**",
          " * Holds a {@link mxDefaultToolbar} for displaying the toolbar. The",
          " * toolbar is created in {@link setToolbarContainer}.",
          " */"
        ]
      ],
      "status": [
        "status: any;",
        [
          "/**",
          " * DOM container that holds the statusbar.",
          " * Use {@link setStatusContainer} to set this value.",
          " */"
        ]
      ],
      "popupHandler": [
        "popupHandler: mxDefaultPopupMenu;",
        [
          "/**",
          " * Holds a {@link mxDefaultPopupMenu} for displaying popupmenus.",
          " */"
        ]
      ],
      "undoManager": [
        "undoManager: mxUndoManager;",
        [
          "/**",
          " * Holds an {@link mxUndoManager} for the command history.",
          " */"
        ]
      ],
      "keyHandler": [
        "keyHandler: mxDefaultKeyHandler;",
        [
          "/**",
          " * Holds a {@link mxDefaultKeyHandler} for handling keyboard events.",
          " * The handler is created in {@link setGraphContainer}.",
          " */"
        ]
      ],
      "actions": [
        "actions: Function;",
        [
          "/**",
          " * Maps from actionnames to actions, which are functions taking",
          " * the editor and the cell as arguments. Use {@link addAction}",
          " * to add or replace an action and {@link execute} to execute an action",
          " * by name, passing the cell to be operated upon as the second",
          " * argument.",
          " */"
        ]
      ],
      "dblClickAction": [
        "dblClickAction: 'edit';",
        [
          "/**",
          " * Specifies the name of the action to be executed",
          " * when a cell is double clicked. Default is 'edit'.",
          " *",
          " * To handle a singleclick, use the following code.",
          " *",
          " * @example",
          " * ```javascript",
          " * editor.graph.addListener(mxEvent.CLICK, function(sender, evt)",
          " * {",
          " *   var e = evt.getProperty('event');",
          " *   var cell = evt.getProperty('cell');",
          " *",
          " *   if (cell != null && !e.isConsumed())",
          " *   {",
          " *     // Do something useful with cell...",
          " *     e.consume();",
          " *   }",
          " * });",
          " * ```",
          " * @default 'edit'",
          " */"
        ]
      ],
      "swimlaneRequired": [
        "swimlaneRequired: boolean;",
        [
          "/**",
          " * Specifies if new cells must be inserted",
          " * into an existing swimlane. Otherwise, cells",
          " * that are not swimlanes can be inserted as",
          " * top-level cells. Default is false.",
          " * @default false",
          " */"
        ]
      ],
      "disableContextMenu": [
        "disableContextMenu: boolean;",
        [
          "/**",
          " * Specifies if the context menu should be disabled in the graph container.",
          " * Default is true.",
          " * @default true",
          " */"
        ]
      ],
      "insertFunction": [
        "insertFunction: Function;",
        [
          "/**",
          " * Specifies the function to be used for inserting new",
          " * cells into the graph. This is assigned from the",
          " * {@link mxDefaultToolbar} if a vertex-tool is clicked.",
          " */"
        ]
      ],
      "forcedInserting": [
        "forcedInserting: boolean;",
        [
          "/**",
          " * Specifies if a new cell should be inserted on a single",
          " * click even using {@link insertFunction} if there is a cell",
          " * under the mousepointer, otherwise the cell under the",
          " * mousepointer is selected. Default is false.",
          " * @default false",
          " */"
        ]
      ],
      "templates": [
        "templates: any;",
        [
          "/**",
          " * Maps from names to protoype cells to be used",
          " * in the toolbar for inserting new cells into",
          " * the diagram.",
          " */"
        ]
      ],
      "defaultEdge": [
        "defaultEdge: any;",
        [
          "/**",
          " * Prototype edge cell that is used for creating new edges.",
          " */"
        ]
      ],
      "defaultEdgeStyle": [
        "defaultEdgeStyle: any;",
        [
          "/**",
          " * Specifies the edge style to be returned in {@link getEdgeStyle}. Default is null.",
          " * @default null",
          " */"
        ]
      ],
      "defaultGroup": [
        "defaultGroup: any;",
        [
          "/**",
          " * Prototype group cell that is used for creating new groups.",
          " */"
        ]
      ],
      "groupBorderSize": [
        "groupBorderSize: any;",
        [
          "/**",
          " * Default size for the border of new groups. If null,",
          " * then then <mxGraph.gridSize> is used. Default is null.",
          " * @default null",
          " */"
        ]
      ],
      "filename": [
        "filename: string;",
        [
          "/**",
          " * Contains the URL of the last opened file as a string. Default is null.",
          " * @default null",
          " */"
        ]
      ],
      "linefeed": [
        "linefeed: '&#xa;';",
        [
          "/**",
          " * Character to be used for encoding linefeeds in {@link save}. Default is '&#xa;'.",
          " * @default '&#xa;'",
          " */"
        ]
      ],
      "postParameterName": [
        "postParameterName: 'xml';",
        [
          "/**",
          " * Specifies if the name of the post parameter that contains the diagram",
          " * data in a post request to the server. Default is 'xml'.",
          " * @default 'xml'",
          " */"
        ]
      ],
      "escapePostData": [
        "escapePostData: boolean;",
        [
          "/**",
          " * Specifies if the data in the post request for saving a diagram",
          " * should be converted using encodeURIComponent. Default is true.",
          " * @default true",
          " */"
        ]
      ],
      "urlPost": [
        "urlPost: string;",
        [
          "/**",
          " * Specifies the URL to be used for posting the diagram",
          " * to a backend in {@link save}.",
          " * @default null",
          " */"
        ]
      ],
      "urlImage": [
        "urlImage: string;",
        [
          "/**",
          " * Specifies the URL to be used for creating a bitmap of",
          " * the graph in the image action.",
          " * @default null",
          " */"
        ]
      ],
      "horizontalFlow": [
        "horizontalFlow: boolean;",
        [
          "/**",
          " * Specifies the direction of the flow",
          " * in the diagram. This is used in the",
          " * layout algorithms. Default is false,",
          " * ie. vertical flow.",
          " * @default false",
          " */"
        ]
      ],
      "layoutDiagram": [
        "layoutDiagram: boolean;",
        [
          "/**",
          " * Specifies if the top-level elements in the",
          " * diagram should be layed out using a vertical",
          " * or horizontal stack depending on the setting",
          " * of {@link horizontalFlow}. The spacing between the",
          " * swimlanes is specified by {@link swimlaneSpacing}.",
          " * Default is false.",
          " *",
          " * If the top-level elements are swimlanes, then",
          " * the intra-swimlane layout is activated by",
          " * the {@link layoutSwimlanes} switch.",
          " * @default false",
          " */"
        ]
      ],
      "swimlaneSpacing": [
        "swimlaneSpacing: number;",
        [
          "/**",
          " * Specifies the spacing between swimlanes if",
          " * automatic layout is turned on in",
          " * {@link layoutDiagram}. Default is 0.",
          " * @default 0",
          " */"
        ]
      ],
      "maintainSwimlanes": [
        "maintainSwimlanes: boolean;",
        [
          "/**",
          " * Specifies if the swimlanes should be kept at the same",
          " * width or height depending on the setting of",
          " * {@link horizontalFlow}. Default is false.",
          " *",
          " * For horizontal flows, all swimlanes",
          " * have the same height and for vertical flows, all swimlanes",
          " * have the same width. Furthermore, the swimlanes are",
          " * automatically \"stacked\" if {@link layoutDiagram} is true.",
          " * @default false",
          " */"
        ]
      ],
      "layoutSwimlanes": [
        "layoutSwimlanes: boolean;",
        [
          "/**",
          " * Specifies if the children of swimlanes should",
          " * be layed out, either vertically or horizontally",
          " * depending on {@link horizontalFlow}. Default is false.",
          " * @default false",
          " */"
        ]
      ],
      "cycleAttributeValues": [
        "cycleAttributeValues: any[];",
        [
          "/**",
          " * Specifies the attribute values to be cycled when inserting new swimlanes.",
          " * Default is an empty array.",
          " * @default any[]",
          " */"
        ]
      ],
      "cycleAttributeIndex": [
        "cycleAttributeIndex: number;",
        [
          "/**",
          " * Index of the last consumed attribute index. If a new",
          " * swimlane is inserted, then the {@link cycleAttributeValues}",
          " * at this index will be used as the value for",
          " * {@link cycleAttributeName}. Default is 0.",
          " * @default 0",
          " */"
        ]
      ],
      "cycleAttributeName": [
        "cycleAttributeName: 'fillColor';",
        [
          "/**",
          " * Name of the attribute to be assigned a {@link cycleAttributeValues}",
          " * when inserting new swimlanes. Default is 'fillColor'.",
          " * @default 'fillColor'",
          " */"
        ]
      ],
      "tasks": [
        "tasks: any;",
        [
          "/**",
          " * Holds the [@link mxWindow} created in {@link showTasks}.",
          " */"
        ]
      ],
      "tasksWindowImage": [
        "tasksWindowImage: any;",
        [
          "/**",
          " * Icon for the tasks window.",
          " */"
        ]
      ],
      "tasksTop": [
        "tasksTop: number;",
        [
          "/**",
          " * Specifies the top coordinate of the tasks window in pixels. Default is 20.",
          " * @default 20",
          " */"
        ]
      ],
      "help": [
        "help: any;",
        [
          "/**",
          " * Holds the {@link mxWindow} created in {@link showHelp}",
          " */"
        ]
      ],
      "helpWindowImage": [
        "helpWindowImage: any;",
        [
          "/**",
          " * Icon for the help window.",
          " */"
        ]
      ],
      "urlHelp": [
        "urlHelp: string;",
        [
          "/**",
          " * Specifies the URL to be used for the contents of the",
          " * Online Help window. This is usually specified in the",
          " * resources file under urlHelp for language-specific",
          " * online help support.",
          " */"
        ]
      ],
      "helpWidth": [
        "helpWidth: number;",
        [
          "/**",
          " * Specifies the width of the help window in pixels. Default is 300.",
          " * @default 300",
          " */"
        ]
      ],
      "helpHeight": [
        "helpHeight: number;",
        [
          "/**",
          " * Specifies the height of the help window in pixels. Default is 260.",
          " * @default 260",
          " */"
        ]
      ],
      "propertiesWidth": [
        "propertiesWidth: number;",
        [
          "/**",
          " * Specifies the width of the properties window in pixels. Default is 240.",
          " * @default 240",
          " */"
        ]
      ],
      "propertiesHeight": [
        "propertiesHeight: number;",
        [
          "/**",
          " * Specifies the height of the properties window in pixels.",
          " * If no height is specified then the window will be automatically",
          " * sized to fit its contents. Default is null.",
          " * @default null",
          " */"
        ]
      ],
      "movePropertiesDialog": [
        "movePropertiesDialog: boolean;",
        [
          "/**",
          " * Specifies if the properties dialog should be automatically",
          " * moved near the cell it is displayed for, otherwise the",
          " * dialog is not moved. This value is only taken into",
          " * account if the dialog is already visible. Default is false.",
          " * @default false",
          " */"
        ]
      ],
      "validating": [
        "validating: boolean;",
        [
          "/**",
          " * Specifies if <{@link xGraph.validateGraph} should automatically be invoked after",
          " * each change. Default is false.",
          " * @default false",
          " */"
        ]
      ],
      "modified": [
        "modified: boolean;",
        [
          "/**",
          " * True if the graph has been modified since it was last saved.",
          " */"
        ]
      ],
      "isModified": [
        "isModified(): boolean;",
        [
          "/**",
          " * Returns {@link modified}.",
          " */"
        ]
      ],
      "setModified": [
        "setModified(value: boolean): void;",
        [
          "/**",
          " * Sets {@link modified} to the specified boolean value.",
          " * @param value",
          " */"
        ]
      ],
      "addActions": [
        "addActions(): void;",
        [
          "/**",
          " * Adds the built-in actions to the editor instance.",
          " * save - Saves the graph using <urlPost>.",
          " * print - Shows the graph in a new print preview window.",
          " * show - Shows the graph in a new window.",
          " * exportImage - Shows the graph as a bitmap image using <getUrlImage>.",
          " * refresh - Refreshes the graph's display.",
          " * cut - Copies the current selection into the clipboard",
          " * and removes it from the graph.",
          " * copy - Copies the current selection into the clipboard.",
          " * paste - Pastes the clipboard into the graph.",
          " * delete - Removes the current selection from the graph.",
          " * group - Puts the current selection into a new group.",
          " * ungroup - Removes the selected groups and selects the children.",
          " * undo - Undoes the last change on the graph model.",
          " * redo - Redoes the last change on the graph model.",
          " * zoom - Sets the zoom via a dialog.",
          " * zoomIn - Zooms into the graph.",
          " * zoomOut - Zooms out of the graph",
          " * actualSize - Resets the scale and translation on the graph.",
          " * fit - Changes the scale so that the graph fits into the window.",
          " * showProperties - Shows the properties dialog.",
          " * selectAll - Selects all cells.",
          " * selectNone - Clears the selection.",
          " * selectVertices - Selects all vertices.",
          " * selectEdges = Selects all edges.",
          " * edit - Starts editing the current selection cell.",
          " * enterGroup - Drills down into the current selection cell.",
          " * exitGroup - Moves up in the drilling hierachy",
          " * home - Moves to the topmost parent in the drilling hierarchy",
          " * selectPrevious - Selects the previous cell.",
          " * selectNext - Selects the next cell.",
          " * selectParent - Selects the parent of the selection cell.",
          " * selectChild - Selects the first child of the selection cell.",
          " * collapse - Collapses the currently selected cells.",
          " * expand - Expands the currently selected cells.",
          " * bold - Toggle bold text style.",
          " * italic - Toggle italic text style.",
          " * underline - Toggle underline text style.",
          " * alignCellsLeft - Aligns the selection cells at the left.",
          " * alignCellsCenter - Aligns the selection cells in the center.",
          " * alignCellsRight - Aligns the selection cells at the right.",
          " * alignCellsTop - Aligns the selection cells at the top.",
          " * alignCellsMiddle - Aligns the selection cells in the middle.",
          " * alignCellsBottom - Aligns the selection cells at the bottom.",
          " * alignFontLeft - Sets the horizontal text alignment to left.",
          " * alignFontCenter - Sets the horizontal text alignment to center.",
          " * alignFontRight - Sets the horizontal text alignment to right.",
          " * alignFontTop - Sets the vertical text alignment to top.",
          " * alignFontMiddle - Sets the vertical text alignment to middle.",
          " * alignFontBottom - Sets the vertical text alignment to bottom.",
          " * toggleTasks - Shows or hides the tasks window.",
          " * toggleHelp - Shows or hides the help window.",
          " * toggleOutline - Shows or hides the outline window.",
          " * toggleConsole - Shows or hides the console window.",
          " */"
        ]
      ],
      "configure": [
        "configure(node: any): void;",
        [
          "/**",
          " * Configures the editor using the specified node. To load the",
          " * configuration from a given URL the following code can be used to obtain",
          " * the XML node.",
          " *",
          " * @example",
          " * ```javascript",
          " * var node = mxUtils.load(url).getDocumentElement();",
          " * ```",
          " * @param node XML node that contains the configuration.",
          " */"
        ]
      ],
      "resetFirstTime": [
        "resetFirstTime(): void;",
        [
          "/**",
          " * Resets the cookie that is used to remember if the editor has already been used.",
          " */"
        ]
      ],
      "resetHistory": [
        "resetHistory(): void;",
        [
          "/**",
          " * Resets the command history, modified state and counters.",
          " */"
        ]
      ],
      "addAction": [
        "addAction(actionname: string, funct: Function): void;",
        [
          "/**",
          " * Binds the specified actionname to the specified function.",
          " *",
          " * @example",
          " * ```javascript",
          " * editor.addAction('test', function(editor, cell)",
          " * {",
          " * \t\tmxUtils.alert(\"test \"+cell);",
          " * });",
          " * ```",
          " * @param actionname String that specifies the name of the action to be added.",
          " * @param funct Function that implements the new action. The first argument",
          " * of the function is the editor it is used with,",
          " * the second argument is the cell it operates upon.",
          " */"
        ]
      ],
      "execute": [
        "execute(actionname: string, cell?: any, evt?: Event): void;",
        [
          "/**",
          " * Executes the function with the given name in {@link actions} passing the",
          " * editor instance and given cell as the first and second argument. All",
          " * additional arguments are passed to the action as well. This method",
          " * contains a try-catch block and displays an error message if an action",
          " * causes an exception. The exception is re-thrown after the error",
          " * message was displayed.",
          " *",
          " * @example",
          " * ```javascript",
          " * editor.execute(\"showProperties\", cell);",
          " * ```",
          " * @param actionname",
          " * @param cell",
          " * @param evt",
          " */"
        ]
      ],
      "addTemplate": [
        "addTemplate(name: any, template: any): void;",
        [
          "/**",
          " * Adds the specified template under the given name in {@link templates}.",
          " * @param name",
          " * @param template",
          " */"
        ]
      ],
      "getTemplate": [
        "getTemplate(name: string): any;",
        [
          "/**",
          " * Returns the template for the given name.",
          " * @param name",
          " */"
        ]
      ],
      "createGraph": [
        "createGraph(): mxGraph;",
        [
          "/**",
          " * Creates the {@link graph} for the editor. The graph is created with no",
          " * container and is initialized from {@link setGraphContainer}.",
          " * @returns mxGraph instance",
          " */"
        ]
      ],
      "createSwimlaneManager": [
        "createSwimlaneManager(graph: any): mxSwimlaneManager;",
        [
          "/**",
          " * Sets the graph's container using [@link mxGraph.init}.",
          " * @param graph",
          " * @returns mxSwimlaneManager instance",
          " */"
        ]
      ],
      "createLayoutManager": [
        "createLayoutManager(graph: any): mxLayoutManager;",
        [
          "/**",
          " * Creates a layout manager for the swimlane and diagram layouts, that",
          " * is, the locally defined inter and intraswimlane layouts.",
          " * @param graph",
          " * @returns mxLayoutManager instance",
          " */"
        ]
      ],
      "setGraphContainer": [
        "setGraphContainer(container: any): void;",
        [
          "/**",
          " * Sets the graph's container using {@link mxGraph.init}.",
          " * @param container",
          " */"
        ]
      ],
      "installDblClickHandler": [
        "installDblClickHandler(graph: any): void;",
        [
          "/**",
          " * Overrides {@link mxGraph.dblClick} to invoke {@link dblClickAction}",
          " * on a cell and reset the selection tool in the toolbar.",
          " * @param graph",
          " */"
        ]
      ],
      "installUndoHandler": [
        "installUndoHandler(graph: any): void;",
        [
          "/**",
          " * Adds the {@link undoManager} to the graph model and the view.",
          " * @param graph",
          " */"
        ]
      ],
      "installDrillHandler": [
        "installDrillHandler(graph: any): void;",
        [
          "/**",
          " * Installs listeners for dispatching the {@link root} event.",
          " * @param graph",
          " */"
        ]
      ],
      "installChangeHandler": [
        "installChangeHandler(graph: any): void;",
        [
          "/**",
          " * Installs the listeners required to automatically validate",
          " * the graph. On each change of the root, this implementation",
          " * fires a {@link root} event.",
          " * @param graph",
          " */"
        ]
      ],
      "installInsertHandler": [
        "installInsertHandler(graph: any): void;",
        [
          "/**",
          " * Installs the handler for invoking {@link insertFunction} if one is defined.",
          " * @param graph",
          " */"
        ]
      ],
      "createDiagramLayout": [
        "createDiagramLayout(): mxStackLayout;",
        [
          "/**",
          " * Creates the layout instance used to layout the",
          " * swimlanes in the diagram.",
          " * @returns mxStackLayout instance",
          " */"
        ]
      ],
      "createSwimlaneLayout": [
        "createSwimlaneLayout(): mxCompactTreeLayout;",
        [
          "/**",
          " * Creates the layout instance used to layout the",
          " * children of each swimlane.",
          " * @returns mxCompactTreeLayout instance",
          " */"
        ]
      ],
      "createToolbar": [
        "createToolbar(): mxDefaultToolbar;",
        [
          "/**",
          " * Creates the {@link toolbar} with no container.",
          " * @returns mxDefaultToolbar instance",
          " */"
        ]
      ],
      "setToolbarContainer": [
        "setToolbarContainer(container: any): void;",
        [
          "/**",
          " * Initializes the toolbar for the given container.",
          " * @param container",
          " */"
        ]
      ],
      "setStatusContainer": [
        "setStatusContainer(container: any): void;",
        [
          "/**",
          " * Creates the {@link status} using the specified container.",
          " * This implementation adds listeners in the editor to",
          " * display the last saved time and the current filename",
          " * in the status bar.",
          " * @param container DOM node that will contain the statusbar.",
          " */"
        ]
      ],
      "setStatus": [
        "setStatus(message: string): void;",
        [
          "/**",
          " * Display the specified message in the status bar.",
          " * @param message String the specified the message to be displayed.",
          " */"
        ]
      ],
      "setTitleContainer": [
        "setTitleContainer(container: any): void;",
        [
          "/**",
          " * Creates a listener to update the inner HTML of the",
          " * specified DOM node with the value of {@link getTitle}.",
          " * @param container DOM node that will contain the title.",
          " */"
        ]
      ],
      "treeLayout": [
        "treeLayout(cell: mxCell, horizontal: boolean): void;",
        [
          "/**",
          " * Executes a vertical or horizontal compact tree layout",
          " * using the specified cell as an argument. The cell may",
          " * either be a group or the root of a tree.",
          " * @param cell {@link mxCell} to use in the compact tree layout.",
          " * @param horizontal Optional boolean to specify the tree's",
          " * orientation. Default is true.",
          " */"
        ]
      ],
      "getTitle": [
        "getTitle(): string;",
        [
          "/**",
          " * Returns the string value for the current root of the diagram.",
          " */"
        ]
      ],
      "getRootTitle": [
        "getRootTitle(): string;",
        [
          "/**",
          " * Returns the string value of the root cell in {@link mxGraph.model}.",
          " */"
        ]
      ],
      "undo": [
        "undo(): void;",
        [
          "/**",
          " * Undo the last change in {@link graph}.",
          " */"
        ]
      ],
      "redo": [
        "redo(): void;",
        [
          "/**",
          " * Redo the last change in {@link graph}.",
          " */"
        ]
      ],
      "groupCells": [
        "groupCells(): any;",
        [
          "/**",
          " * Invokes {@link createGroup} to create a new group cell and the invokes",
          " * {@link mxGraph.groupCells}, using the grid size of the graph as the spacing",
          " * in the group's content area.",
          " */"
        ]
      ],
      "createGroup": [
        "createGroup(): mxCell;",
        [
          "/**",
          " * Creates and returns a clone of {@link defaultGroup} to be used",
          " * as a new group cell in {@link group}.",
          " * @returns mxCell",
          " */"
        ]
      ],
      "open": [
        "open(filename: string): void;",
        [
          "/**",
          " * Opens the specified file synchronously and parses it using",
          " * {@link readGraphModel}. It updates {@link filename} and fires an <open>-event after",
          " * the file has been opened. Exceptions should be handled as follows:",
          " *",
          " * @example",
          " * ```javascript",
          " * try",
          " * {",
          " *   editor.open(filename);",
          " * }",
          " * catch (e)",
          " * {",
          " *   mxUtils.error('Cannot open ' + filename +",
          " *     ': ' + e.message, 280, true);",
          " * }",
          " * ```",
          " *",
          " * @param filename URL of the file to be opened.",
          " */"
        ]
      ],
      "readGraphModel": [
        "readGraphModel(node: any): void;",
        [
          "/**",
          " * Reads the specified XML node into the existing graph model and resets",
          " * the command history and modified state.",
          " * @param node",
          " */"
        ]
      ],
      "save": [
        "save(url: any, linefeed: any): void;",
        [
          "/**",
          " * Posts the string returned by {@link writeGraphModel} to the given URL or the",
          " * URL returned by {@link getUrlPost}. The actual posting is carried out by",
          " * {@link postDiagram}. If the URL is null then the resulting XML will be",
          " * displayed using {@link mxUtils.popup}. Exceptions should be handled as",
          " * follows:",
          " *",
          " * @example",
          " * ```javascript",
          " * try",
          " * {",
          " *   editor.save();",
          " * }",
          " * catch (e)",
          " * {",
          " *   mxUtils.error('Cannot save : ' + e.message, 280, true);",
          " * }",
          " * ```",
          " *",
          " * @param url",
          " * @param linefeed",
          " */"
        ]
      ],
      "postDiagram": [
        "postDiagram(url: any, data: any): void;",
        [
          "/**",
          " * Hook for subclassers to override the posting of a diagram",
          " * represented by the given node to the given URL. This fires",
          " * an asynchronous {@link post} event if the diagram has been posted.",
          " *",
          " * ### Example:",
          " *",
          " * To replace the diagram with the diagram in the response, use the",
          " * following code.",
          " *",
          " * @example",
          " * ```javascript",
          " * editor.addListener(mxEvent.POST, function(sender, evt)",
          " * {",
          " *   // Process response (replace diagram)",
          " *   var req = evt.getProperty('request');",
          " *   var root = req.getDocumentElement();",
          " *   editor.graph.readGraphModel(root)",
          " * });",
          " * ```",
          " * @param url",
          " * @param data",
          " */"
        ]
      ],
      "writeGraphModel": [
        "writeGraphModel(linefeed: string): string;",
        [
          "/**",
          " * Hook to create the string representation of the diagram. The default",
          " * implementation uses an {@link mxCodec} to encode the graph model as",
          " * follows:",
          " *",
          " * @example",
          " * ```javascript",
          " * var enc = new mxCodec();",
          " * var node = enc.encode(this.graph.getModel());",
          " * return mxUtils.getXml(node, this.linefeed);",
          " * ```",
          " *",
          " * @param linefeed Optional character to be used as the linefeed. Default is {@link linefeed}.",
          " */"
        ]
      ],
      "getUrlPost": [
        "getUrlPost(): string;",
        [
          "/**",
          " * Returns the URL to post the diagram to. This is used",
          " * in {@link save}. The default implementation returns {@link urlPost},",
          " * adding <code>?draft=true</code>.",
          " */"
        ]
      ],
      "getUrlImage": [
        "getUrlImage(): string;",
        [
          "/**",
          " * Returns the URL to create the image with. This is typically",
          " * the URL of a backend which accepts an XML representation",
          " * of a graph view to create an image. The function is used",
          " * in the image action to create an image. This implementation",
          " * returns {@link urlImage}.",
          " */"
        ]
      ],
      "swapStyles": [
        "swapStyles(first: any, second: any): void;",
        [
          "/**",
          " * Swaps the styles for the given names in the graph's",
          " * stylesheet and refreshes the graph.",
          " * @param first",
          " * @param second",
          " */"
        ]
      ],
      "showProperties": [
        "showProperties(cell: mxCell): void;",
        [
          "/**",
          " * Creates and shows the properties dialog for the given",
          " * cell. The content area of the dialog is created using",
          " * {@link createProperties}.",
          " * @param cell",
          " */"
        ]
      ],
      "isPropertiesVisible": [
        "isPropertiesVisible(): boolean;",
        [
          "/**",
          " * Returns true if the properties dialog is currently visible.",
          " */"
        ]
      ],
      "createProperties": [
        "createProperties(cell: any): HTMLTableElement | null;",
        [
          "/**",
          " * Creates and returns the DOM node that represents the contents",
          " * of the properties dialog for the given cell. This implementation",
          " * works for user objects that are XML nodes and display all the",
          " * node attributes in a form.",
          " */"
        ]
      ],
      "hideProperties": [
        "hideProperties(): void;",
        [
          "/**",
          " * Hides the properties dialog.",
          " */"
        ]
      ],
      "showTasks": [
        "showTasks(): void;",
        [
          "/**",
          " * Shows the tasks window. The tasks window is created using {@link createTasks}. The",
          " * default width of the window is 200 pixels, the y-coordinate of the location",
          " * can be specifies in {@link tasksTop} and the x-coordinate is right aligned with a",
          " * 20 pixel offset from the right border. To change the location of the tasks",
          " * window, the following code can be used:",
          " *",
          " * @example",
          " * ```javascript",
          " * var oldShowTasks = mxEditor.prototype.showTasks;",
          " * mxEditor.prototype.showTasks = function()",
          " * {",
          " *   oldShowTasks.apply(this, arguments); // \"supercall\"",
          " *",
          " *   if (this.tasks != null)",
          " *   {",
          " *     this.tasks.setLocation(10, 10);",
          " *   }",
          " * };",
          " * ```",
          " */"
        ]
      ],
      "refreshTasks": [
        "refreshTasks(div: any): void;",
        [
          "/**",
          " * Updates the contents of the tasks window using {@link createTasks}.",
          " * @param div",
          " */"
        ]
      ],
      "createTasks": [
        "createTasks(div: any): void;",
        [
          "/**",
          " * Updates the contents of the given DOM node to",
          " * display the tasks associated with the current",
          " * editor state. This is invoked whenever there",
          " * is a possible change of state in the editor.",
          " * Default implementation is empty.",
          " * @param div",
          " */"
        ]
      ],
      "showHelp": [
        "showHelp(tasks: any): void;",
        [
          "/**",
          " * Shows the help window. If the help window does not exist",
          " * then it is created using an iframe pointing to the resource",
          " * for the <code>urlHelp</code> key or {@link urlHelp} if the resource",
          " * is undefined.",
          " * @param tasks",
          " */"
        ]
      ],
      "showOutline": [
        "showOutline(): void;",
        [
          "/**",
          " * Shows the outline window. If the window does not exist, then it is",
          " * created using an {@link mxOutline}.",
          " */"
        ]
      ],
      "setMode": [
        "setMode(modename: any): void;",
        [
          "/**",
          " * Puts the graph into the specified mode. The following modenames are",
          " * supported:",
          " *",
          " * select - Selects using the left mouse button, new connections are disabled.",
          " * connect - Selects using the left mouse button or creates new connections if mouse over cell hotspot.",
          " * See {@link mxConnectionHandler}.",
          " * pan - Pans using the left mouse button, new connections are disabled.",
          " * @param modename",
          " */"
        ]
      ],
      "createPopupMenu": [
        "createPopupMenu(menu: any, cell: any, evt: any): void;",
        [
          "/**",
          " * Uses {@link popupHandler} to create the menu in the graph's",
          " * panning handler. The redirection is setup in {@link setToolbarContainer}.",
          " * @param menu",
          " * @param cell",
          " * @param evt",
          " */"
        ]
      ],
      "createEdge": [
        "createEdge(source: any, target: any): void;",
        [
          "/**",
          " * Uses {@link defaultEdge} as the prototype for creating new edges",
          " * in the connection handler of the graph. The style of the",
          " * edge will be overridden with the value returned by {@link getEdgeStyle}.",
          " * @param source",
          " * @param target",
          " */"
        ]
      ],
      "getEdgeStyle": [
        "getEdgeStyle(): string;",
        [
          "/**",
          " * Returns a string identifying the style of new edges.",
          " * The function is used in {@link createEdge} when new edges",
          " * are created in the graph.",
          " */"
        ]
      ],
      "consumeCycleAttribute": [
        "consumeCycleAttribute(cell: any): any;",
        [
          "/**",
          " * Returns the next attribute in {@link cycleAttributeValues}",
          " * or null, if not attribute should be used in the specified cell.",
          " * @param cell",
          " */"
        ]
      ],
      "cycleAttribute": [
        "cycleAttribute(cell: any): void;",
        [
          "/**",
          " * Uses the returned value from {@link consumeCycleAttribute}",
          " * as the value for the {@link cycleAttributeName} key in the given cell's style.",
          " * @param cell",
          " */"
        ]
      ],
      "addVertex": [
        "addVertex(parent: any, vertex: any, x: any, y: any): any;",
        [
          "/**",
          " * Adds the given vertex as a child of parent at the specified",
          " * x and y coordinate and fires an {@link addVertex} event.",
          " * @param parent",
          " * @param vertex",
          " * @param x",
          " * @param y",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Removes the editor and all its associated resources. This does not",
          " * normally need to be called, it is called automatically when the window",
          " * unloads.",
          " */"
        ]
      ]
    }
  ],
  "mxDefaultToolbar": [
    [
      "/**",
      " * Toolbar for the editor. This modifies the state of the graph",
      " * or inserts new cells upon mouse clicks.",
      " *",
      " * @Example:",
      " *",
      " * Create a toolbar with a button to copy the selection into the clipboard,",
      " * and a combo box with one action to paste the selection from the clipboard",
      " * into the graph.",
      " *",
      " * ```",
      " * var toolbar = new mxDefaultToolbar(container, editor);",
      " * toolbar.addItem('Copy', null, 'copy');",
      " *",
      " * var combo = toolbar.addActionCombo('More actions...');",
      " * toolbar.addActionOption(combo, 'Paste', 'paste');",
      " * ```",
      " *",
      " * @Codec:",
      " *",
      " * This class uses the {@link mxDefaultToolbarCodec} to read configuration",
      " * data into an existing instance. See {@link mxDefaultToolbarCodec} for a",
      " * description of the configuration format.",
      " */"
    ],
    {
      "constructor": [
        "constructor(container: HTMLElement, editor: mxEditor);",
        [
          "/**",
          " * Constructs a new toolbar for the given container and editor. The",
          " * container and editor may be null if a prototypical instance for a",
          " * {@link mxDefaultKeyHandlerCodec} is created.",
          " *",
          " * @param container - DOM node that contains the toolbar.",
          " * @param editor - Reference to the enclosing {@link mxEditor}.",
          " */"
        ]
      ],
      "editor": [
        "editor: mxEditor;",
        [
          "/**",
          " * Reference to the enclosing {@link mxEditor}.",
          " */"
        ]
      ],
      "toolbar": [
        "toolbar: mxToolbar;",
        [
          "/**",
          " * Holds the internal {@link mxToolbar}.",
          " */"
        ]
      ],
      "resetHandler": [
        "resetHandler: Function;",
        [
          "/**",
          " * Reference to the function used to reset the {@link toolbar}.",
          " */"
        ]
      ],
      "spacing": [
        "spacing: number;",
        [
          "/**",
          " * Defines the spacing between existing and new vertices in gridSize units when a new vertex is dropped on an existing cell.  Default is 4 (40 pixels).",
          " *",
          " * @Default is 4",
          " */"
        ]
      ],
      "connectOnDrop": [
        "connectOnDrop: boolean;",
        [
          "/**",
          " * Specifies if elements should be connected if new cells are dropped onto connectable elements.",
          " *",
          " * @Default is false.",
          " */"
        ]
      ],
      "init": [
        "init(container: HTMLElement): void;",
        [
          "/**",
          " * Constructs the {@link toolbar} for the given container and installs a listener that updates the {@link mxEditor.insertFunction} on {@link editor} if an item is selected in the toolbar.  This assumes that {@link editor} is not null.",
          " */"
        ]
      ],
      "addItem": [
        "addItem(title: string, icon: string, action: string, pressed?: string): any;",
        [
          "/**",
          " * Adds a new item that executes the given action in {@link editor}. The title,",
          " * icon and pressedIcon are used to display the toolbar item.",
          " *",
          " * @param title - String that represents the title (tooltip) for the item.",
          " * @param icon - URL of the icon to be used for displaying the item.",
          " * @param action - Name of the action to execute when the item is clicked.",
          " * @param pressed - Optional URL of the icon for the pressed state.",
          " */"
        ]
      ],
      "addSeparator": [
        "addSeparator(icon?: string): void;",
        [
          "/**",
          " * Adds a vertical separator using the optional icon.",
          " *",
          " * @param icon - Optional URL of the icon that represents the vertical separator. Default is {@link mxClient.imageBasePath} + /separator.gif.",
          " */"
        ]
      ],
      "addCombo": [
        "addCombo(): HTMLElement;",
        [
          "/**",
          " * Helper method to invoke {@link mxToolbar.addCombo} on toolbar and return the resulting DOM node.",
          " */"
        ]
      ],
      "addActionOption": [
        "addActionOption(combo: HTMLElement, title: string, action: string): void;",
        [
          "/**",
          " * Binds the given action to a option with the specified label in the given combo.  Combo is an object returned from an earlier call to {@link addCombo} or {@link addActionCombo}.",
          " *",
          " * @param combo - DOM node that represents the combo box.",
          " * @param title - String that represents the title of the combo.",
          " * @param action - Name of the action to execute in {@link editor}.",
          " */"
        ]
      ],
      "addOption": [
        "addOption(combo: HTMLElement, title: string, value: object): HTMLElement;",
        [
          "/**",
          " * Helper method to invoke {@link mxToolbar.addOption} on {@link toolbar} and return the resulting DOM node that represents the option.",
          " *",
          " * @param combo - DOM node that represents the combo box.",
          " * @param title - String that represents the title of the combo.",
          " * @param value - Object that represents the value of the option.",
          " */"
        ]
      ],
      "addMode": [
        "addMode(title: string, icon: string, mode: string, pressed?: string, funct?: Function): any;",
        [
          "/**",
          " * Creates an item for selecting the given mode in the {@link editor}'s graph.",
          " * Supported modenames are select, connect and pan.",
          " *",
          " * @param title - String that represents the title of the item.",
          " * @param icon - URL of the icon that represents the item.",
          " * @param mode - String that represents the mode name to be used in {@link mxEditor.setMode}.",
          " * @param pressed - Optional URL of the icon that represents the pressed state.",
          " * @param funct - Optional JavaScript function that takes the {@link mxEditor} as the first and only argument that is executed after the mode has been selected.",
          " */"
        ]
      ],
      ")": [
        "): mxCell | null;",
        [
          "/**",
          " * Creates an item for inserting a clone of the specified prototype cell into",
          " * the {@link editor}'s graph. The ptype may either be a cell or a function that",
          " * returns a cell.",
          " *",
          " * @param title - String that represents the title of the item.",
          " * @param icon - URL of the icon that represents the item.",
          " * @param ptype - Function or object that represents the prototype cell. If ptype",
          " * is a function then it is invoked with no arguments to create new",
          " * instances.",
          " * @param pressed - Optional URL of the icon that represents the pressed state.",
          " * @param insert - Optional JavaScript function that handles an insert of the new",
          " * cell. This function takes the {@link mxEditor}, new cell to be inserted, mouse",
          " * event and optional {@link mxCell} under the mouse pointer as arguments.",
          " * @param toggle - Optional boolean that specifies if the item can be toggled. Default is true.",
          " */"
        ]
      ],
      "drop": [
        "drop(vertex: mxCell, evt: MouseEvent, target?: mxCell): void;",
        [
          "/**",
          " * Handles a drop from a toolbar item to the graph. The given vertex",
          " * represents the new cell to be inserted. This invokes {@link insert} or",
          " * {@link connect} depending on the given target cell.",
          " *",
          " * Parameters:",
          " *",
          " * @param vertex - {@link mxCell} to be inserted.",
          " * @param evt - Mouse event that represents the drop.",
          " * @param target - Optional {@link mxCell} that represents the drop target.",
          " */"
        ]
      ],
      "insert": [
        "insert(vertex: mxCell, evt: MouseEvent, target?: mxCell): any;",
        [
          "/**",
          " * Handles a drop by inserting the given vertex into the given parent cell",
          " * or the default parent if no parent is specified.",
          " *",
          " * @param vertex - {@link mxCell} to be inserted.",
          " * @param evt - Mouse event that represents the drop.",
          " * @param target - Optional {@link mxCell} that represents the parent.",
          " */"
        ]
      ],
      "connect": [
        "connect(vertex: mxCell, evt: MouseEvent, source?: mxCell): void;",
        [
          "/**",
          " * Handles a drop by connecting the given vertex to the given source cell.",
          " *",
          " * @param vertex - {@link mxCell} to be inserted.",
          " * @param evt - Mouse event that represents the drop.",
          " * @param source - Optional {@link mxCell} that represents the source terminal.",
          " */"
        ]
      ],
      "installDropHandler": [
        "installDropHandler(img: HTMLElement, dropHandler: Function): void;",
        [
          "/**",
          " * Makes the given img draggable using the given function for handling a drop event.",
          " *",
          " * @param img - DOM node that represents the image.",
          " * @param dropHandler - Function that handles a drop of the image.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Destroys the {@link toolbar} associated with this object and removes all installed listeners.",
          " * This does normally not need to be called, the {@link toolbar} is destroyed automatically when the window unloads (in IE) by {@link mxEditor}.",
          " */"
        ]
      ],
      "key": [
        "[key: string]: any;",
        [
          "/**",
          " * Destroys the {@link toolbar} associated with this object and removes all installed listeners.",
          " * This does normally not need to be called, the {@link toolbar} is destroyed automatically when the window unloads (in IE) by {@link mxEditor}.",
          " */"
        ]
      ]
    }
  ],
  "mxDefaultKeyHandler": [
    [
      "/**",
      " * Binds keycodes to actionnames in an editor.  This aggregates an internal {@link handler} and extends the implementation of {@link mxKeyHandler.escape} to not only cancel the editing, but also hide the properties dialog and fire an <mxEditor.escape> event via {@link editor}.  An instance of this class is created by {@link mxEditor} and stored in {@link mxEditor.keyHandler}.",
      " *",
      " * @Example",
      " * Bind the delete key to the delete action in an existing editor.",
      " * ```javascript",
      " * var keyHandler = new mxDefaultKeyHandler(editor);",
      " * keyHandler.bindAction(46, 'delete');",
      " * ```",
      " *",
      " * @Codec",
      " * This class uses the {@link mxDefaultKeyHandlerCodec} to read configuration data into an existing instance.  See {@link mxDefaultKeyHandlerCodec} for a description of the configuration format.",
      " *",
      " * @Keycodes",
      " * See {@link mxKeyHandler}.",
      " * An {@link mxEvent.ESCAPE} event is fired via the editor if the escape key is pressed.",
      " */"
    ],
    {
      "constructor": [
        "constructor(editor: mxEditor);",
        [
          "/**",
          " * Constructs a new default key handler for the {@link mxEditor.graph} in the given {@link mxEditor}.  (The editor may be null if a prototypical instance for a {@link mxDefaultKeyHandlerCodec} is created.)",
          " *",
          " * @param editor",
          " */"
        ]
      ],
      "editor": [
        "editor: mxEditor;",
        [
          "/**",
          " * Reference to the enclosing {@link mxEditor}.",
          " */"
        ]
      ],
      "handler": [
        "handler: mxKeyHandler;",
        [
          "/**",
          " * Holds the {@link mxKeyHandler} for key event handling.",
          " */"
        ]
      ],
      "bindAction": [
        "bindAction(code: number, action: string, control?: boolean): void;",
        [
          "/**",
          " * Binds the specified keycode to the given action in {@link editor}.  The optional control flag specifies if the control key must be pressed to trigger the action.",
          " *",
          " * @param code      Integer that specifies the keycode.",
          " * @param action    Name of the action to execute in {@link editor}.",
          " * @param control   Optional boolean that specifies if control must be pressed.  Default is false.",
          " */"
        ]
      ],
      "destroy": [
        "destroy(): void;",
        [
          "/**",
          " * Destroys the {@link handler} associated with this object.  This does normally not need to be called, the {@link handler} is destroyed automatically when the window unloads (in IE) by {@link mxEditor}.",
          " */"
        ]
      ],
      "key": [
        "[key: string]: any;",
        [
          "/**",
          " * Destroys the {@link handler} associated with this object.  This does normally not need to be called, the {@link handler} is destroyed automatically when the window unloads (in IE) by {@link mxEditor}.",
          " */"
        ]
      ]
    }
  ],
  "mxDefaultPopupMenu": [
    [
      "/**",
      " * Creates popupmenus for mouse events.  This object holds an XML node which is a description of the popup menu to be created.  In {@link createMenu}, the configuration is applied to the context and the resulting menu items are added to the menu dynamically.  See {@link createMenu} for a description of the configuration format.",
      " * This class does not create the DOM nodes required for the popup menu, it only parses an XML description to invoke the respective methods on an {@link mxPopupMenu} each time the menu is displayed.",
      " *",
      " * @Codec",
      " * This class uses the {@link mxDefaultPopupMenuCodec} to read configuration data into an existing instance, however, the actual parsing is done by this class during program execution, so the format is described below.",
      " */"
    ],
    {
      "constructor": [
        "constructor(config: Element);",
        [
          "/**",
          " * Constructs a new popupmenu-factory based on given configuration.",
          " *",
          " * @param config     XML node that contains the configuration data.",
          " */"
        ]
      ],
      "imageBasePath": [
        "imageBasePath: string;",
        [
          "/**",
          " * Base path for all icon attributes in the config.  Default is null.",
          " *",
          " * @default null",
          " */"
        ]
      ],
      "config": [
        "config: Element;",
        [
          "/**",
          " * XML node used as the description of new menu items.  This node is used in {@link createMenu} to dynamically create the menu items if their respective conditions evaluate to true for the given arguments.",
          " */"
        ]
      ],
      "createMenu": [
        "createMenu(editor: mxEditor, menu: mxPopupMenu, cell?: mxCell, evt?: MouseEvent): void;",
        [
          "/**",
          " * This function is called from {@link mxEditor} to add items to the",
          " * given menu based on {@link config}. The config is a sequence of",
          " * the following nodes and attributes.",
          " *",
          " * @ChildNodes:",
          " *",
          " * add - Adds a new menu item. See below for attributes.",
          " * separator - Adds a separator. No attributes.",
          " * condition - Adds a custom condition. Name attribute.",
          " *",
          " * The add-node may have a child node that defines a function to be invoked",
          " * before the action is executed (or instead of an action to be executed).",
          " *",
          " * @Attributes:",
          " *",
          " * as - Resource key for the label (needs entry in property file).",
          " * action - Name of the action to execute in enclosing editor.",
          " * icon - Optional icon (relative/absolute URL).",
          " * iconCls - Optional CSS class for the icon.",
          " * if - Optional name of condition that must be true (see below).",
          " * enabled-if - Optional name of condition that specifies if the menu item",
          " * should be enabled.",
          " * name - Name of custom condition. Only for condition nodes.",
          " *",
          " * @Conditions:",
          " *",
          " * nocell - No cell under the mouse.",
          " * ncells - More than one cell selected.",
          " * notRoot - Drilling position is other than home.",
          " * cell - Cell under the mouse.",
          " * notEmpty - Exactly one cell with children under mouse.",
          " * expandable - Exactly one expandable cell under mouse.",
          " * collapsable - Exactly one collapsable cell under mouse.",
          " * validRoot - Exactly one cell which is a possible root under mouse.",
          " * swimlane - Exactly one cell which is a swimlane under mouse.",
          " *",
          " * @Example:",
          " *",
          " * To add a new item for a given action to the popupmenu:",
          " *",
          " * ```",
          " * <mxDefaultPopupMenu as=\"popupHandler\">",
          " *   <add as=\"delete\" action=\"delete\" icon=\"images/delete.gif\" if=\"cell\"/>",
          " * </mxDefaultPopupMenu>",
          " * ```",
          " *",
          " * To add a new item for a custom function:",
          " *",
          " * ```",
          " * <mxDefaultPopupMenu as=\"popupHandler\">",
          " *   <add as=\"action1\"><![CDATA[",
          " *\t\tfunction (editor, cell, evt)",
          " *\t\t{",
          " *\t\t\teditor.execute('action1', cell, 'myArg');",
          " *\t\t}",
          " *   ]]></add>",
          " * </mxDefaultPopupMenu>",
          " * ```",
          " *",
          " * The above example invokes action1 with an additional third argument via",
          " * the editor instance. The third argument is passed to the function that",
          " * defines action1. If the add-node has no action-attribute, then only the",
          " * function defined in the text content is executed, otherwise first the",
          " * function and then the action defined in the action-attribute is",
          " * executed. The function in the text content has 3 arguments, namely the",
          " * {@link mxEditor} instance, the {@link mxCell} instance under the mouse, and the",
          " * native mouse event.",
          " *",
          " * Custom Conditions:",
          " *",
          " * To add a new condition for popupmenu items:",
          " *",
          " * ```",
          " * <condition name=\"condition1\"><![CDATA[",
          " *   function (editor, cell, evt)",
          " *   {",
          " *     return cell != null;",
          " *   }",
          " * ]]></condition>",
          " * ```",
          " *",
          " * The new condition can then be used in any item as follows:",
          " *",
          " * ```",
          " * <add as=\"action1\" action=\"action1\" icon=\"action1.gif\" if=\"condition1\"/>",
          " * ```",
          " *",
          " * The order in which the items and conditions appear is not significant as",
          " * all conditions are evaluated before any items are created.",
          " *",
          " * Parameters:",
          " *",
          " * @param editor - Enclosing {@link mxEditor} instance.",
          " * @param menu - {@link mxPopupMenu} that is used for adding items and separators.",
          " * @param cell - Optional {@link mxCell} which is under the mousepointer.",
          " * @param evt - Optional mouse event which triggered the menu.",
          " */"
        ]
      ],
      ")": [
        "): void;",
        [
          "/**",
          " * Helper method to bind an action to a new menu item.",
          " *",
          " * @param menu - {@link mxPopupMenu} that is used for adding items and separators.",
          " * @param editor - Enclosing {@link mxEditor} instance.",
          " * @param lab - String that represents the label of the menu item.",
          " * @param parent - DOM node that represents the parent menu item.",
          " * @param icon - Optional URL that represents the icon of the menu item.",
          " * @param action - Optional name of the action to execute in the given editor.",
          " * @param funct - Optional function to execute before the optional action. The function takes an {@link mxEditor}, the {@link mxCell} under the mouse and the mouse event that triggered the call.",
          " * @param cell - Optional {@link mxCell} to use as an argument for the action.",
          " * @param iconCls - Optional CSS class for the menu icon.",
          " * @param enabled - Optional boolean that specifies if the menu item is enabled. Default is true.",
          " */"
        ]
      ],
      "createConditions": [
        "createConditions(editor: mxEditor, cell: mxCell, evt: MouseEvent): void;",
        [
          "/**",
          " * Evaluates the default conditions for the given context.",
          " *",
          " * @param editor",
          " * @param cell",
          " * @param evt",
          " */"
        ]
      ],
      "key": [
        "[key: string]: any;",
        [
          "/**",
          " * Evaluates the default conditions for the given context.",
          " *",
          " * @param editor",
          " * @param cell",
          " * @param evt",
          " */"
        ]
      ]
    }
  ]
}